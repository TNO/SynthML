
package com.github.tno.pokayoke.transform.app;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.annotations.AnnotationArgument;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.cif.metamodel.java.CifConstructors;

import com.google.common.base.Verify;
import com.google.common.collect.Sets;

/**
 * Helper for the language equivalence check. Assumes that the CIF models are generated by the CIF state space explorer.
 */
public class StateAwareWeakLanguageEquivalenceHelper {
    private StateAwareWeakLanguageEquivalenceHelper() {
    }

    /**
     * Prepares two CIF models for the language equivalence check. Performs sanity checks, and removes internal
     * variables from state annotations. Returns a record containing the filtered state annotations.
     *
     * @param model1 The first CIF model.
     * @param model2 The second CIF model.
     * @param externalVariableNames The set containing non-escaped external variable names.
     * @return The model preparation result.
     */
    public static ModelPreparationResult prepareModels(Specification model1, Specification model2,
            Set<String> externalVariableNames)
    {
        // Sanity checks. The models should only have one component, an automaton.
        Verify.verify(model1.getComponents().size() == 1, StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                + "the first model contains more than one component.");
        Verify.verify(model2.getComponents().size() == 1, StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                + "the second model contains more than one component.");
        Verify.verify(model1.getComponents().get(0) instanceof Automaton,
                StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + "the first model's component is not an automaton.");
        Verify.verify(model2.getComponents().get(0) instanceof Automaton,
                StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + "the second model's component is not an automaton.");

        // Filter internal variables from state annotations.
        Map<Location, Annotation> filteredStateAnn1 = filterStateAnnotations(model1, externalVariableNames);
        Map<Location, Annotation> filteredStateAnn2 = filterStateAnnotations(model2, externalVariableNames);

        return new ModelPreparationResult(filteredStateAnn1, filteredStateAnn2);
    }

    private static Map<Location, Annotation> filterStateAnnotations(Specification model,
            Set<String> externalVariableNames)
    {
        // Get state annotations for the CIF model.
        Map<Location, List<Annotation>> locToAnnotations = StateAnnotationHelper.getStateAnnotations(model);

        // Verify that each location has only one annotation. This is always the case with CIF model generated with the
        // state space exploration.
        List<String> locsWithErrors = locToAnnotations.entrySet().stream().filter(e -> e.getValue().size() != 1)
                .map(a -> a.getKey().getName()).toList();
        if (!locsWithErrors.isEmpty()) {
            throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX + String.format(
                    "state space '%s' contains state(s) %s that don't have exactly one state annotation.",
                    model.getComponents().get(0).getName(), String.join(", ", locsWithErrors)));
        }

        // Filter the state annotations, by removing the internal variables from them.
        Map<Location, Annotation> locToFilteredAnnotations = new LinkedHashMap<>();

        for (Entry<Location, List<Annotation>> locToAnnotation: locToAnnotations.entrySet()) {
            Location loc = locToAnnotation.getKey();
            List<Annotation> annotations = locToAnnotation.getValue();
            Annotation annotation = annotations.get(0);

            // Filter and create new annotation. External variable names are not escaped.
            List<AnnotationArgument> filteredArgs = annotation.getArguments().stream()
                    .filter(arg -> externalVariableNames.contains(arg.getName())).toList();
            Annotation filteredAnnotation = CifConstructors.newAnnotation(filteredArgs, annotation.getName(),
                    annotation.getPosition());
            locToFilteredAnnotations.put(loc, filteredAnnotation);
        }

        return locToFilteredAnnotations;
    }

    private static void checkAlphabetCoverage(Automaton stateSpace, Map<String, List<Event>> namesToEvents,
            Set<Event> tauEvents)
    {
        // Check that the alphabet of the state space is equal to the union of non-tau and the tau events. This check is
        // performed by absolute names, since they are different objects.
        Set<Event> eventsMerged = new LinkedHashSet<>();
        namesToEvents.values().forEach(e -> eventsMerged.addAll(e));
        eventsMerged.addAll(tauEvents);

        Set<Event> stateSpaceAlphabet = CifEventUtils.getAlphabet(stateSpace);
        Set<String> absNamesStateSpace = stateSpaceAlphabet.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesEventsMerged = eventsMerged.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        if (!absNamesStateSpace.equals(absNamesEventsMerged)) {
            Set<String> onlyInMerged = Sets.difference(absNamesEventsMerged, absNamesStateSpace);
            Set<String> onlyInStateSpace = Sets.difference(absNamesStateSpace, absNamesEventsMerged);

            if (!onlyInStateSpace.isEmpty()) {
                throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + String.format("state space '%s' contains events that are neither internal nor external: %s.",
                                stateSpace.getName(), String.join(", ", onlyInStateSpace)));
            } else {
                absNamesEventsMerged.removeAll(absNamesStateSpace);
                throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX + String.format(
                        "There are internal/external events that do not belong to the state space '%s' alphabet: %s.",
                        stateSpace.getName(), String.join(", ", onlyInMerged)));
            }
        }
    }

    private static Set<String> removeAndGetUnusedEvents(Automaton stateSpace) {
        // Removes the unused events from the alphabet, and returns the unused events names.
        Set<Event> preFilterAlphabet = CifEventUtils.getAlphabet(stateSpace);
        stateSpace.setAlphabet(null);
        Set<Event> postFilterAlphabet = CifEventUtils.getAlphabet(stateSpace);
        preFilterAlphabet.removeAll(postFilterAlphabet);
        return preFilterAlphabet.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
    }

    /**
     * Compute the events from two state spaces that represent the same UML element, and pair them together. If the
     * events in one state space are not related to any event in the other state space, throws an error.
     *
     * @param namesToEvents1 The map from the name of the UML element to the list of events related to it, in the first
     *     state space.
     * @param unusedEvents1 Names of events that are not used in the first state space.
     * @param stateSpace1Name The name of the first state space.
     * @param namesToEvents2 The map from the name of the UML element to the list of events related to it, in the second
     *     state space.
     * @param unusedEvents2 Names of events that are not used in the second state space.
     * @param stateSpace2Name The name of the second state space.
     * @return The set containing pairs of corresponding (lists of) events for the two state space automata. All events
     *     in the first list of events are equivalent to all the events in the second list of events.
     */
    private static Set<Pair<List<Event>, List<Event>>> getPairedEvents(Map<String, List<Event>> namesToEvents1,
            Set<String> unusedEvents1, String stateSpace1Name, Map<String, List<Event>> namesToEvents2,
            Set<String> unusedEvents2, String stateSpace2Name)
    {
        Set<Pair<List<Event>, List<Event>>> pairedEvents = new LinkedHashSet<>();
        for (Entry<String, List<Event>> entry: namesToEvents1.entrySet()) {
            String umlElementName = entry.getKey();
            List<Event> events1 = entry.getValue();
            List<Event> events2 = namesToEvents2.getOrDefault(umlElementName, new ArrayList<>());

            // Remove events that are not used.
            List<Event> usedEvents1 = events1.stream().filter(e -> !unusedEvents1.contains(CifTextUtils.getAbsName(e)))
                    .toList();
            List<Event> usedEvents2 = events2.stream().filter(e -> !unusedEvents2.contains(CifTextUtils.getAbsName(e)))
                    .toList();

            // Remove the item from the second map, to later check that all items from the second map have been looped
            // through.
            namesToEvents2.remove(umlElementName);

            if (!usedEvents1.isEmpty() && !usedEvents2.isEmpty()) {
                // Pair the two lists of equivalent events.
                pairedEvents.add(Pair.of(usedEvents1, usedEvents2));
            } else if (usedEvents1.isEmpty() != usedEvents2.isEmpty()) {
                // If one set of events is empty and the other is not, one model can have a transition while the other
                // model cannot; this means that the two state spaces are not equivalent, thus throw an error.
                String emptyEventSSpaceName;
                String fullEventSSpaceName;
                String eventName;
                if (usedEvents1.isEmpty()) {
                    emptyEventSSpaceName = stateSpace1Name;
                    fullEventSSpaceName = stateSpace2Name;
                    eventName = usedEvents2.get(0).getName();
                } else {
                    emptyEventSSpaceName = stateSpace2Name;
                    fullEventSSpaceName = stateSpace1Name;
                    eventName = usedEvents1.get(0).getName();
                }

                throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX + String.format(
                        "found non-matching events related to UML element '%s'. "
                                + "The state space '%s' has no events, while the state space '%s' has event '%s'.",
                        umlElementName, emptyEventSSpaceName, fullEventSSpaceName, eventName));
            }
        }

        // If second map is not empty, the two state spaces are not equivalent.
        if (!namesToEvents2.isEmpty()) {
            throw new RuntimeException(String.format("The second model contains non-matching events, e.g. '%s'.",
                    namesToEvents2.keySet().iterator().next()));
        }

        return pairedEvents;
    }

    /**
     * The result of the preparation of the two CIF state spaces.
     *
     * @param stateAnnotations1 The filtered state annotations for the first state space.
     * @param stateAnnotations2 The filtered state annotations for the second state space.
     */
    record ModelPreparationResult(Map<Location, Annotation> stateAnnotations1,
            Map<Location, Annotation> stateAnnotations2)
    {
    }
}
