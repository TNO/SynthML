/**
 *
 */

package com.github.tno.pokayoke.transform.activitysynthesis;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.bdd.spec.CifBddSpec;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.io.CifWriter;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.common.app.framework.AppEnv;

import com.google.common.base.Verify;

/**
 * Removes redundant paths from any initial CIF locations to any CIF marked location. Assumes the input is generated
 * from CIF state space exploration.
 */
public class RedundantPathsCleaner {
    /** The set of locations that belong to a shortest path; these are called essential or non-redundant. */
    private Set<Location> essentialLocs = new LinkedHashSet<>();

    /** The map from essential locations to their essential edges. */
    private Map<Location, Set<Edge>> essentialLocsToEssentialEdges = new LinkedHashMap<>();

    /** The set of all initial locations of the automaton. */
    private Set<Location> initialLocs = new LinkedHashSet<>();

    /** The set of all marked locations of the automaton. */
    private Set<Location> markedLocs = new LinkedHashSet<>();

    /** The map from any location to all one-step forward reachable locations. */
    private Map<Location, Set<Location>> forwardNeighbors = new LinkedHashMap<>();

    /** The map from any location to all one-step backward reachable locations. */
    private Map<Location, Set<Location>> backwardNeighbors = new LinkedHashMap<>();

    /** The map from a pair of locations to the set of edges connecting them. */
    private Map<Pair<Location, Location>, Set<Edge>> neighborsEdges = new LinkedHashMap<>();

    public RedundantPathsCleaner() {
        // Static class.
    }

    /**
     * Removes the redundant paths from a CIF model generated by the state space exploration. From each initial location
     * finds the shortest path to a marked location, accounting for paths emerging from uncontrollable edges.
     *
     * @param model The input CIF specification, generated from the state space exploration.
     * @param bddSpec The CIF-BDD specification.
     * @param outputFilePath The path to the output file to write the transformation result to.
     * @param outputFolderPath The path to the folder in which the transformation result is to be written.
     */
    public void clean(Specification model, CifBddSpec bddSpec, Path outputFilePath, Path outputFolderPath) {
        // Sanity check. Model should contain only one automaton.
        Verify.verify(model.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");

        Automaton automa = (Automaton)model.getComponents().get(0);

        // Compute initial and marked locations.
        findInitialAndMarkedLocations(automa);

        // Sanity check: initial and marked locations must not be empty.
        Verify.verify(initialLocs != null && !initialLocs.isEmpty(), "Found empty initial set.");
        Verify.verify(markedLocs != null && !markedLocs.isEmpty(), "Found empty target set.");

        // Compute a map of forward and backward neighbors for each location.
        computeNeighbors(automa.getLocations());

        for (Location initialLoc: initialLocs) {
            // Compute shortest path(s) to marked locations. Get the marked location(s) and the corresponding distance
            // map(s).
            Map<Location, Map<Location, Integer>> markedLocsToDistanceMaps = findClosestMarkedLocations(initialLoc,
                    automa.getLocations());

            // Sanity check: there must exist a path from the initial location to (at least) a marked location.
            Verify.verify(!markedLocsToDistanceMaps.isEmpty());

            // Mark the shortest paths as essential.
            markEssentialLocationAndEdges(markedLocsToDistanceMaps);
        }

        // Remove every non-essential, redundant element.
        removeRedundantElements(automa);

        // Write the essential model.
        try {
            AppEnv.registerSimple();
            CifWriter.writeCifSpec(model, outputFilePath.toString(), outputFolderPath.toString());
        } finally {
            AppEnv.unregisterApplication();
        }
    }

    private void findInitialAndMarkedLocations(Automaton automaton) {
        // Find initial locations of the automaton.
        for (Location loc: automaton.getLocations()) {
            if (CifLocationHelper.isInitial(loc)) {
                initialLocs.add(loc);
            }
        }

        // Find marked locations of the automaton.
        for (Location loc: automaton.getLocations()) {
            if (CifLocationHelper.isMarked(loc)) {
                markedLocs.add(loc);
            }
        }
    }

    private void computeNeighbors(List<Location> locations) {
        // Computes the forward and backward neighbors for every location.
        for (Location loc: locations) {
            for (Edge edge: loc.getEdges()) {
                if (CifEdgeUtils.isSelfLoop(edge)) {
                    forwardNeighbors.computeIfAbsent(loc, v -> new LinkedHashSet<>()).add(loc);
                    backwardNeighbors.computeIfAbsent(loc, v -> new LinkedHashSet<>()).add(loc);
                    neighborsEdges.computeIfAbsent(Pair.of(loc, loc), v -> new LinkedHashSet<>()).add(edge);
                } else {
                    forwardNeighbors.computeIfAbsent(loc, v -> new LinkedHashSet<>()).add(edge.getTarget());
                    backwardNeighbors.computeIfAbsent(edge.getTarget(), v -> new LinkedHashSet<>()).add(loc);
                    neighborsEdges.computeIfAbsent(Pair.of(loc, edge.getTarget()), v -> new LinkedHashSet<>())
                            .add(edge);
                }
            }

            // If location is initial (marked), set backwards (forward) neighbors to the empty set.
            if (initialLocs.contains(loc) && backwardNeighbors.get(loc) == null) {
                backwardNeighbors.put(loc, new LinkedHashSet<>());
            }
            if (markedLocs.contains(loc) && forwardNeighbors.get(loc) == null) {
                forwardNeighbors.put(loc, new LinkedHashSet<>());
            }
        }
    }

    private Map<Location, Map<Location, Integer>> findClosestMarkedLocations(Location initialLoc,
            List<Location> allLocations)
    {
        Integer minDistanceInitialToMarked = Integer.MAX_VALUE;
        Map<Location, Map<Location, Integer>> markedLocsToDistanceMaps = new LinkedHashMap<>();

        for (Location markedLoc: markedLocs) {
            // Get the minimum distances from the marked location to every other location.
            Map<Location, Integer> minDistance = computeUncontrollableAwareMinDistance(markedLoc, allLocations);
            int currentMinDistance = minDistance.get(initialLoc);

            if (currentMinDistance == Integer.MAX_VALUE) {
                // If the current initial location cannot reach the current marked location (for instance, as part
                // of a disjoint graph) do not store any location distance map.
                continue;
            }

            if (currentMinDistance == 0) {
                // If the initial location is also marked, no need to process the distance map.
                markedLocsToDistanceMaps.put(markedLoc, minDistance);
            } else {
                // Update the distance of the initial location with the shortest path(s), and store the location
                // distance map.
                if (minDistanceInitialToMarked >= currentMinDistance) {
                    minDistanceInitialToMarked = currentMinDistance;
                    minDistance.put(initialLoc, minDistanceInitialToMarked);
                    markedLocsToDistanceMaps.put(markedLoc, minDistance);
                }
            }
        }
        return markedLocsToDistanceMaps;
    }

    /**
     * First, uses Dijkstra algorithm to compute the minimum distance from the start location to every location. Then,
     * uses a BFS to update the distances when an uncontrollable edge is found. Return the uncontrollable-event-aware
     * distance of all locations from the start location.
     *
     * @param startLoc The start location for the shortest path algorithms.
     * @param allLocations The list of all locations of the automaton.
     * @return The map from each location to its distance to the start location.
     */
    private Map<Location, Integer> computeUncontrollableAwareMinDistance(Location startLoc,
            List<Location> allLocations)
    {
        Map<Location, Integer> locDistance = dijkstra(startLoc, allLocations, backwardNeighbors);
        updateLocationDistance(startLoc, locDistance);
        return locDistance;
    }

    private static Map<Location, Integer> dijkstra(Location startLoc, List<Location> allLocations,
            Map<Location, Set<Location>> neighbors)
    {
        // Store the location minimum distance from the start location.
        Map<Location, Integer> minDistance = new LinkedHashMap<>();

        // PriorityQueue to store pairs (distance, location) to be processed.
        PriorityQueue<Location> pq = new PriorityQueue<>(
                Comparator.comparingInt(p -> minDistance.getOrDefault(p, Integer.MAX_VALUE)));

        // Initialization: set distance to maximum value, and start location to zero; add all locations to the queue.
        for (Location loc: allLocations) {
            if (loc.equals(startLoc)) {
                minDistance.put(loc, 0);
            } else {
                minDistance.put(loc, Integer.MAX_VALUE);
            }
            pq.offer(loc);
        }
        minDistance.put(startLoc, 0);

        while (!pq.isEmpty()) {
            System.out.println("Current pq size: " + pq.size());

            // Get the location with the minimum distance.
            Location currentLoc = pq.poll();
            int currentDist = minDistance.get(currentLoc);

            // Explore all the neighbors that are not in the queue.
            for (Location neighbor: neighbors.get(currentLoc)) {
                if (pq.contains(neighbor)) {
                    int neighborDist = minDistance.get(neighbor);
                    int currentDistPlusOne = (currentDist == Integer.MAX_VALUE) ? Integer.MAX_VALUE : currentDist + 1;

                    // If there is a shorter path to the neighbor through the current node, update
                    // the distance and add the pair to the queue.
                    if (currentDistPlusOne < neighborDist) {
                        neighborDist = currentDistPlusOne;
                        minDistance.put(neighbor, neighborDist);

                        // Update location distance in the priority queue.
                        pq.remove(neighbor);
                        pq.offer(neighbor);
                    }
                }
            }
        }

        return minDistance;
    }

    private void updateLocationDistance(Location startLoc, Map<Location, Integer> minDistance) {
        // Run a BFS and update the distance map if a location has any uncontrollable edges with a larger distance.
        Queue<Location> currentLocs = new LinkedList<>();
        currentLocs.add(startLoc);
        Set<Location> visited = new LinkedHashSet<>();
        while (!currentLocs.isEmpty()) {
            // Get the first element of the queue, and analyze its neighbors.
            Location currentLoc = currentLocs.poll();

            // If this node was already visited, skip it.
            if (visited.contains(currentLoc)) {
                continue;
            }

            // Update the location distance if one of the forward neighbors is connected through an uncontrollable edge
            // with a larger distance.
            int currentLocDistance = minDistance.get(currentLoc);
            for (Location neighbor: forwardNeighbors.get(currentLoc)) {
                for (Edge edge: neighborsEdges.get(Pair.of(currentLoc, neighbor))) {
                    List<Event> events = new ArrayList<>(CifEventUtils.getEvents(edge));

                    // If the forward neighbor is not in the direct path to the current marked location, the minimum
                    // distance map is set to max value of integers.
                    if (!events.get(0).getControllable() && minDistance.get(neighbor) >= currentLocDistance) {
                        currentLocDistance = (minDistance.get(neighbor) == Integer.MAX_VALUE) ? Integer.MAX_VALUE
                                : minDistance.get(neighbor) + 1;
                    }
                }
            }
            minDistance.put(currentLoc, currentLocDistance);

            // Add all backwards neighbors, if not already visited.
            for (Location neighbor: backwardNeighbors.get(currentLoc)) {
                if (visited.contains(neighbor)) {
                    currentLocs.add(neighbor);
                }
            }

            // Mark the current location as visited.
            visited.add(currentLoc);
        }
    }

    private void markEssentialLocationAndEdges(Map<Location, Map<Location, Integer>> markedLocsToDistanceMaps) {
        for (Entry<Location, Map<Location, Integer>> entry: markedLocsToDistanceMaps.entrySet()) {
            Location markedLoc = entry.getKey();
            Map<Location, Integer> locDistance = entry.getValue();
            markEssentialLocationAndEdges(markedLoc, locDistance);
        }
    }

    private void markEssentialLocationAndEdges(Location currentLoc, Map<Location, Integer> locDistance) {
        // Mark the current location as essential, and get its depth.
        essentialLocs.add(currentLoc);
        int currentDist = locDistance.get(currentLoc);

        if (forwardNeighbors.get(currentLoc).isEmpty()) {
            // Add empty set for marked location.
            essentialLocsToEssentialEdges.put(currentLoc, new LinkedHashSet<>());
        }

        for (Location neighbor: backwardNeighbors.get(currentLoc)) {
            // Only consider paths that improve the reachability.
            if (locDistance.get(neighbor) == currentDist + 1) {
                // Mark the edge as essential; add it to the neighbor, since we are using backwards reachability.
                for (Edge edge: neighborsEdges.get(Pair.of(neighbor, currentLoc))) {
                    Verify.verify(edge != null);
                    essentialLocsToEssentialEdges.computeIfAbsent(neighbor, k -> new LinkedHashSet<>()).add(edge);
                    markEssentialLocationAndEdges(neighbor, locDistance);
                }
            }
        }
    }

    private void removeRedundantElements(Automaton automa) {
        // Remove all redundant locations and redundant edges of essential locations.
        Set<Location> locsToRemove = new LinkedHashSet<>();
        for (Location loc: automa.getLocations()) {
            if (!essentialLocs.contains(loc)) {
                locsToRemove.add(loc);
            } else {
                // Remove redundant edges if location is essential.
                Set<Edge> locEssentialEdges = essentialLocsToEssentialEdges.get(loc);
                Set<Edge> edgesToRemove = new LinkedHashSet<>();
                for (Edge edge: loc.getEdges()) {
                    if (!locEssentialEdges.contains(edge)) {
                        edgesToRemove.add(edge);
                    }
                }
                loc.getEdges().removeAll(edgesToRemove);
            }
        }
        automa.getLocations().removeAll(locsToRemove);
    }
}
