
package com.github.tno.pokayoke.transform.app;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.AnnotationEqHashWrap;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.eventbased.automata.AutomatonHelper;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;

import com.github.tno.pokayoke.transform.activitysynthesis.CifLocationHelper;
import com.google.common.base.Verify;

/**
 * Weak-language equivalence checker of two CIF models that considers state annotations. The two models must contain a
 * single state space automaton, and have a compatible alphabet. Alphabets are compatible when they have the same number
 * of events, with possibly different names. Assumes the two models are generated by the CIF state space explorer.
 */
public class StateAwareWeakLanguageEquivalenceChecker {
    protected static final String ERROR_PREFIX = "Language equivalence check failed: ";

    /**
     * Checks whether two CIF state space automata are weak-language equivalent, considering state annotations.
     *
     * @param stateSpace1 The first CIF state space.
     * @param stateAnnotations1 The map from CIF states to their filtered state annotations, for the first model. The
     *     state annotations contain solely the relevant information used for comparison of the model states.
     * @param tauEvents1 The set containing events that represent a tau transition for the first model.
     * @param stateSpace2 The second CIF state space.
     * @param stateAnnotations2 The map from CIF states to their filtered state annotations, for the second model. The
     *     state annotations contain solely the relevant information used for comparison of the model states.
     * @param tauEvents2 The set containing events that represent a tau transition for the second model.
     * @param pairedEvents The set containing pairs of corresponding (lists of) events for the two state space automata.
     *     All events in the first list of events are equivalent to all the events in the second list of events.
     */
    @SuppressWarnings("null")
    public void check(Automaton stateSpace1, Map<Location, Annotation> stateAnnotations1, Set<Event> tauEvents1,
            Automaton stateSpace2, Map<Location, Annotation> stateAnnotations2, Set<Event> tauEvents2,
            Set<Pair<List<Event>, List<Event>>> pairedEvents)
    {
        // Sanity check: paired events should not be null.
        Verify.verify(pairedEvents != null, ERROR_PREFIX + "paired events cannot be null.");

        // Sanity check: tau events and non-tau events must be disjoint.
        checkDisjointEventSets(pairedEvents.stream().flatMap(p -> p.getLeft().stream()).collect(Collectors.toSet()),
                tauEvents1, stateSpace1);
        checkDisjointEventSets(pairedEvents.stream().flatMap(p -> p.getRight().stream()).collect(Collectors.toSet()),
                tauEvents2, stateSpace2);

        // Sanity check: marked states should not have outgoing transitions.
        Set<Location> markedStates1 = stateSpace1.getLocations().stream().filter(s -> CifLocationHelper.isMarked(s))
                .collect(Collectors.toSet());
        Set<Location> markedStates2 = stateSpace2.getLocations().stream().filter(s -> CifLocationHelper.isMarked(s))
                .collect(Collectors.toSet());
        List<String> markedWithOutgoing = markedStates1.stream().filter(s -> !s.getEdges().isEmpty())
                .map(m -> m.getName()).toList();
        if (!markedWithOutgoing.isEmpty()) {
            throw new RuntimeException(
                    ERROR_PREFIX + "state space 1 has outgoing transitions from the following marked states: "
                            + String.join(", ", markedWithOutgoing) + ".");
        }
        markedWithOutgoing = markedStates2.stream().filter(s -> !s.getEdges().isEmpty()).map(m -> m.getName()).toList();
        if (!markedWithOutgoing.isEmpty()) {
            throw new RuntimeException(
                    ERROR_PREFIX + "state space 2 has outgoing transitions from the following marked states: "
                            + String.join(", ", markedWithOutgoing) + ".");
        }

        // Sanity check: all states should be able to reach a marked state (be non-blocking).
        Map<Location, List<Edge>> stateToIncomingTrans1 = computeIncomingTransitionsPerState(stateSpace1);
        Map<Location, List<Edge>> stateToIncomingTrans2 = computeIncomingTransitionsPerState(stateSpace2);
        checkNoBlockingStates(stateSpace1, markedStates1, stateToIncomingTrans1);
        checkNoBlockingStates(stateSpace2, markedStates2, stateToIncomingTrans2);

        // Initialize queue.
        Queue<Pair<Set<Location>, Set<Location>>> queue = initializeQueue(stateSpace1, stateAnnotations1, stateSpace2,
                stateAnnotations2);

        Set<Pair<Set<Location>, Set<Location>>> visitedPairs = new LinkedHashSet<>();
        visitedPairs.addAll(queue);

        // Get absolute names of tau events.
        Set<String> absNamesTauEvents1 = tauEvents1.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesTauEvents2 = tauEvents2.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        while (!queue.isEmpty()) {
            // Pop first element of the queue.
            Pair<Set<Location>, Set<Location>> currentPair = queue.remove();

            // Compute tau-reachable states from the current pair.
            Set<Location> tauReachableStates1 = getTauReachableStates(currentPair.getLeft(), absNamesTauEvents1);
            Set<Location> tauReachableStates2 = getTauReachableStates(currentPair.getRight(), absNamesTauEvents2);

            // Sanity check: the states should represent the same external state, since tau transitions may only
            // change internal state.
            checkAllEquivalentStates(tauReachableStates1, stateAnnotations1, stateSpace1);
            checkAllEquivalentStates(tauReachableStates2, stateAnnotations2, stateSpace2);

            // Check if any tau reachable state is marked, for both state spaces.
            List<String> reachableMarked1 = tauReachableStates1.stream().filter(markedStates1::contains)
                    .map(Location::getName).toList();
            List<String> reachableMarked2 = tauReachableStates2.stream().filter(markedStates2::contains)
                    .map(Location::getName).toList();
            if (reachableMarked1.isEmpty() != reachableMarked2.isEmpty()) {
                if (reachableMarked1.isEmpty()) {
                    throw new RuntimeException(ERROR_PREFIX + "the state space " + stateSpace2.getName()
                            + " tau-reached marked state(s) " + String.join(", ", reachableMarked2)
                            + " from the tau-reachable set {"
                            + String.join(", ", tauReachableStates2.stream().map(l -> l.getName()).toList())
                            + "}, while the state space " + stateSpace1.getName()
                            + " has not reached any marked state within {"
                            + String.join(", ", tauReachableStates1.stream().map(l -> l.getName()).toList()) + "}.");
                } else {
                    throw new RuntimeException(ERROR_PREFIX + "the state space " + stateSpace1.getName()
                            + " tau-reached marked state(s) " + String.join(", ", reachableMarked1)
                            + " from the tau-reachable set {"
                            + String.join(", ", tauReachableStates1.stream().map(l -> l.getName()).toList())
                            + "}, while the state space " + stateSpace2.getName()
                            + " has not reached any marked state within {"
                            + String.join(", ", tauReachableStates2.stream().map(l -> l.getName()).toList()) + "}.");
                }
            }

            // Check that the pair of sets of tau reached states is equivalent.
            if (!areEquivalentStates(tauReachableStates1.iterator().next(), stateAnnotations1,
                    tauReachableStates2.iterator().next(), stateAnnotations2))
            {
                throw new RuntimeException(ERROR_PREFIX + "the two models can reach non-equivalent states: "
                        + String.format("state '%s' of the first model, and state '%s' of the second model.",
                                tauReachableStates1.iterator().next().getName(),
                                tauReachableStates2.iterator().next().getName()));
            }

            // The pair of states is equivalent. Check also all pairs of states reachable from this pair.
            for (Pair<List<Event>, List<Event>> events: pairedEvents) {
                Set<Location> targetStates1 = getNextStates(tauReachableStates1, events.getLeft());
                Set<Location> targetStates2 = getNextStates(tauReachableStates2, events.getRight());

                // If one set of states can reach some target with this event, but the other set cannot reach any,
                // the two models are different. Note that this is different from checking the sizes of the target
                // sets, which can be different. This works only if the size of one is zero while the size of the
                // other is not zero.
                if (targetStates1.isEmpty() != targetStates2.isEmpty()) {
                    throw new RuntimeException(ERROR_PREFIX + String.format(
                            "the event '%s' from states %s of the first model and "
                                    + "event '%s' from states %s of the second model reach different states.",
                            events.getLeft().get(0).getName(),
                            String.join(", ", tauReachableStates1.stream().map(s -> s.getName()).toList()),
                            events.getRight().get(0).getName(),
                            String.join(", ", tauReachableStates2.stream().map(s -> s.getName()).toList())));
                } else if (targetStates1.size() > 0) {
                    // Add the next pair to the queue, if not already visited.
                    Pair<Set<Location>, Set<Location>> nextPair = Pair.of(targetStates1, targetStates2);
                    if (!visitedPairs.contains(nextPair)) {
                        visitedPairs.add(nextPair);
                        queue.add(nextPair);
                    }
                }
            }
        }
    }

    private void checkDisjointEventSets(Set<Event> set1, Set<Event> set2, Automaton stateSpace) {
        Set<String> absNamesEventsSet1 = set1.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
        Set<String> absNamesEventsSet2 = set2.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());

        for (String name: absNamesEventsSet2) {
            if (absNamesEventsSet1.contains(name)) {
                throw new RuntimeException(ERROR_PREFIX + String.format(
                        "Event '%s' of state space '%s' is contained both in the internal event set and the external event set.",
                        name, stateSpace.getName()));
            }
        }
    }

    private Map<Location, List<Edge>> computeIncomingTransitionsPerState(Automaton stateSpace) {
        Map<Location, List<Edge>> stateToIncomingTrans = new LinkedHashMap<>();
        for (Location state: stateSpace.getLocations()) {
            stateToIncomingTrans.computeIfAbsent(state, k -> new ArrayList<>());
            for (Edge transition: state.getEdges()) {
                stateToIncomingTrans.computeIfAbsent(CifEdgeUtils.getTarget(transition), k -> new ArrayList<>())
                        .add(transition);
            }
        }
        return stateToIncomingTrans;
    }

    /**
     * Check that given state space has no blocking states. See also {@link AutomatonHelper#getNonCoreachableCount}.
     *
     * @param stateSpace State space to search.
     * @param markedStates The set of marked states of the state space.
     * @param stateToIncomingTrans The map from states to their incoming transitions.
     */
    public static void checkNoBlockingStates(Automaton stateSpace, Set<Location> markedStates,
            Map<Location, List<Edge>> stateToIncomingTrans)
    {
        Queue<Location> toExpand = new ArrayDeque<>(1000);
        Set<Location> nonblocking = new LinkedHashSet<>();

        // Add all marked states.
        int stateCount = stateSpace.getLocations().size();
        toExpand.addAll(markedStates);
        nonblocking.addAll(markedStates);

        // Expand the marked states to all non-blocking states.
        while (!toExpand.isEmpty()) {
            Location state = toExpand.remove();
            for (Edge incomingTrans: stateToIncomingTrans.get(state)) {
                Location transitionSource = CifEdgeUtils.getSource(incomingTrans);
                if (nonblocking.add(transitionSource)) {
                    toExpand.add(transitionSource);
                }
            }
        }

        if (stateCount - nonblocking.size() != 0) {
            throw new RuntimeException(ERROR_PREFIX + String.format("State space '%s' contains %s blocking state(s).",
                    stateSpace.getName(), String.valueOf(stateCount - nonblocking.size())));
        }
    }

    private Queue<Pair<Set<Location>, Set<Location>>> initializeQueue(Automaton stateSpace1,
            Map<Location, Annotation> annotations1, Automaton stateSpace2, Map<Location, Annotation> annotations2)
    {
        Queue<Pair<Set<Location>, Set<Location>>> queue = new LinkedList<>();

        // Find initial states of the first state space.
        Set<Location> initialStates1 = new LinkedHashSet<>();
        for (Location state: stateSpace1.getLocations()) {
            if (CifLocationHelper.isInitial(state)) {
                initialStates1.add(state);
            }
        }

        // Find initial states of the second state space.
        Set<Location> initialStates2 = new LinkedHashSet<>();
        for (Location state: stateSpace2.getLocations()) {
            if (CifLocationHelper.isInitial(state)) {
                initialStates2.add(state);
            }
        }

        // Loop over all initial states of the two state spaces, find the equivalent ones (i.e. have the same
        // annotations), and pair them together.
        Set<Location> visited = new LinkedHashSet<>();
        for (Location state1: initialStates1) {
            for (Location state2: initialStates2) {
                if (areEquivalentStates(state1, annotations1, state2, annotations2)) {
                    queue.add(Pair.of(Set.of(state1), Set.of(state2)));
                    visited.add(state1);
                    visited.add(state2);
                }
            }
        }

        // If any initial state is not contained in the visited set, throw an error.
        if (visited.size() != initialStates1.size() + initialStates2.size()) {
            List<String> errors = new ArrayList<>();

            // Find initial states in the first model that are not in any pair.
            initialStates1.removeAll(visited);
            if (!initialStates1.isEmpty()) {
                errors.add(String.format("The first model contains initial states that cannot be paired: %s.",
                        String.join(", ", initialStates1.stream().map(s -> s.getName()).toList())));
            }

            // Find initial states in the second model that are not in any pair.
            initialStates2.removeAll(visited);
            if (!initialStates2.isEmpty()) {
                errors.add(String.format("The second model contains initial states that cannot be paired: %s.",
                        String.join(", ", initialStates2.stream().map(s -> s.getName()).toList())));
            }

            if (!errors.isEmpty()) {
                throw new RuntimeException(ERROR_PREFIX + String.join(" ", errors));
            }
        }

        return queue;
    }

    private boolean areEquivalentStates(Location state1, Map<Location, Annotation> stateAnnotations1, Location state2,
            Map<Location, Annotation> stateAnnotations2)
    {
        // States are equivalent if their annotations are equivalent.
        return areEquivalentAnnotations(stateAnnotations1.get(state1), stateAnnotations2.get(state2));
    }

    private boolean areEquivalentAnnotations(Annotation ann1, Annotation ann2) {
        AnnotationEqHashWrap annotationWrapped1 = new AnnotationEqHashWrap(ann1);
        AnnotationEqHashWrap annotationWrapped2 = new AnnotationEqHashWrap(ann2);
        return annotationWrapped1.equals(annotationWrapped2);
    }

    private Set<Location> getTauReachableStates(Set<Location> states, Set<String> tauEvents) {
        Set<Location> visited = new LinkedHashSet<>(states);
        Queue<Location> queue = new LinkedList<>(states);

        while (!queue.isEmpty()) {
            Location currentState = queue.remove();

            for (Edge transition: currentState.getEdges()) {
                Set<Event> eventsOnTrans = CifEventUtils.getEvents(transition);
                for (Event eventOnTrans: eventsOnTrans) {
                    if (tauEvents.contains(CifTextUtils.getAbsName(eventOnTrans))) {
                        // Add target state if not yet visited.
                        Location target = CifEdgeUtils.getTarget(transition);
                        if (!visited.contains(target)) {
                            queue.add(target);
                            visited.add(target);
                        }
                    }
                }
            }
        }
        return visited;
    }

    private void checkAllEquivalentStates(Set<Location> states, Map<Location, Annotation> stateAnnotations,
            Automaton stateSpace)
    {
        // Find if the states of the set are all equivalent. Pick the first state, and compare it to all the others: if
        // there is one non-equivalent state, throws an error.
        Iterator<Location> statesIter = states.iterator();
        Location firstState = statesIter.next();
        Annotation firstStateAnnotation = stateAnnotations.get(firstState);

        while (statesIter.hasNext()) {
            Location currentState = statesIter.next();
            if (!areEquivalentAnnotations(firstStateAnnotation, stateAnnotations.get(currentState))) {
                throw new RuntimeException(ERROR_PREFIX + String.format(
                        "states '%s' and '%s' of state space '%s' can be reached with an internal action, but are not equivalent.",
                        firstState.getName(), currentState.getName(), stateSpace.getName()));
            }
        }
    }

    private Set<Location> getNextStates(Set<Location> sourceStates, List<Event> events) {
        Set<String> eventsAbsNames = events.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
        Set<Location> nextStates = new LinkedHashSet<>();

        for (Location state: sourceStates) {
            for (Edge transition: state.getEdges()) {
                Set<Event> eventsOnTransition = CifEventUtils.getEvents(transition);
                for (Event event: eventsOnTransition) {
                    // Comparison is by name, since the events might be different object.
                    if (eventsAbsNames.contains(CifTextUtils.getAbsName(event))) {
                        nextStates.add(CifEdgeUtils.getTarget(transition));
                    }
                }
            }
        }
        return nextStates;
    }
}
