/**
 *
 */

package com.github.tno.pokayoke.transform.activitysynthesis;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.bdd.spec.CifBddSpec;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.io.CifWriter;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.common.app.framework.AppEnv;

import com.google.common.base.Verify;

/**
 * Removes redundant paths from any initial CIF locations to any CIF marked location. Assumes the input is generated
 * from CIF state space exploration.
 */
public class RedundantPathsCleaner {
    /** The set of locations that belong to a shortest path; these are called essential or non-redundant. */
    private Set<Location> essentialLocs = new LinkedHashSet<>();

    /** The map from essential locations to their essential edges. */
    private Map<Location, Set<Edge>> essentialLocsToEssentialEdges = new LinkedHashMap<>();

    /** The set of all initial locations of the automaton. */
    private Set<Location> initialLocs = new LinkedHashSet<>();

    /** The set of all marked locations of the automaton. */
    private Set<Location> markedLocs = new LinkedHashSet<>();

    /** The map from any location to all one-step forward reachable locations. */
    private Map<Location, Set<Location>> forwardNeighbors = new LinkedHashMap<>();

    /** The map from any location to all one-step backward reachable locations. */
    private Map<Location, Set<Location>> backwardNeighbors = new LinkedHashMap<>();

    /** The map from a pair of locations to the set of edges connecting them. */
    private Map<Pair<Location, Location>, Set<Edge>> neighborsEdges = new LinkedHashMap<>();

    public RedundantPathsCleaner() {
        // Static class.
    }

    /**
     * Removes the redundant paths from a CIF model generated by the state space exploration. From each initial location
     * finds the shortest path to a marked location, accounting for paths emerging from uncontrollable edges.
     *
     * @param model The input CIF specification, generated from the state space exploration.
     * @param bddSpec The CIF-BDD specification.
     * @param outputFilePath The path to the output file to write the transformation result to.
     * @param outputFolderPath The path to the folder in which the transformation result is to be written.
     */
    public void clean(Specification model, CifBddSpec bddSpec, Path outputFilePath, Path outputFolderPath) {
        // Sanity check: the CIF model should contain only one automaton.
        Verify.verify(model.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");

        Automaton automa = (Automaton)model.getComponents().get(0);

        // Compute initial and marked locations.
        findInitialAndMarkedLocations(automa);

        // Sanity check: initial and marked locations must not be empty.
        Verify.verify(initialLocs != null && !initialLocs.isEmpty(), "Found empty initial set.");
        Verify.verify(markedLocs != null && !markedLocs.isEmpty(), "Found empty target set.");

        // Compute a map of forward and backward neighbors for each location.
        computeNeighbors(automa.getLocations());

        for (Location initialLoc: initialLocs) {
            // Compute shortest path(s) to marked locations. Get the marked location(s) and the corresponding distance
            // map(s).
            Map<Location, Integer> minDistance = computeUncontrollableAwareMinDistance(initialLoc,
                    automa.getLocations());

            // Mark the shortest paths as essential.
            markEssentialLocationAndEdges(initialLoc, minDistance);
        }

        // Remove every non-essential, redundant element.
        removeRedundantElements(automa);

        // Write the essential model.
        try {
            AppEnv.registerSimple();
            CifWriter.writeCifSpec(model, outputFilePath.toString(), outputFolderPath.toString());
        } finally {
            AppEnv.unregisterApplication();
        }
    }

    private void findInitialAndMarkedLocations(Automaton automaton) {
        // Find initial locations of the automaton.
        for (Location loc: automaton.getLocations()) {
            if (CifLocationHelper.isInitial(loc)) {
                initialLocs.add(loc);
            }
        }

        // Find marked locations of the automaton.
        for (Location loc: automaton.getLocations()) {
            if (CifLocationHelper.isMarked(loc)) {
                markedLocs.add(loc);
            }
        }
    }

    private void computeNeighbors(List<Location> locations) {
        // Computes the forward and backward neighbors for every location.
        for (Location loc: locations) {
            for (Edge edge: loc.getEdges()) {
                if (CifEdgeUtils.isSelfLoop(edge)) {
                    forwardNeighbors.computeIfAbsent(loc, v -> new LinkedHashSet<>()).add(loc);
                    backwardNeighbors.computeIfAbsent(loc, v -> new LinkedHashSet<>()).add(loc);
                    neighborsEdges.computeIfAbsent(Pair.of(loc, loc), v -> new LinkedHashSet<>()).add(edge);
                } else {
                    forwardNeighbors.computeIfAbsent(loc, v -> new LinkedHashSet<>()).add(CifEdgeUtils.getTarget(edge));
                    backwardNeighbors.computeIfAbsent(CifEdgeUtils.getTarget(edge), v -> new LinkedHashSet<>())
                            .add(loc);
                    neighborsEdges
                            .computeIfAbsent(Pair.of(loc, CifEdgeUtils.getTarget(edge)), v -> new LinkedHashSet<>())
                            .add(edge);
                }
            }

            // If location is initial (marked), set backwards (forward) neighbors to the empty set.
            if (initialLocs.contains(loc) && backwardNeighbors.get(loc) == null) {
                backwardNeighbors.put(loc, new LinkedHashSet<>());
            }
            if (markedLocs.contains(loc) && forwardNeighbors.get(loc) == null) {
                forwardNeighbors.put(loc, new LinkedHashSet<>());
            }
        }
    }

    private Map<Location, Integer> computeUncontrollableAwareMinDistance(Location initialLoc,
            List<Location> allLocations)
    {
        Map<Location, Integer> minDistance = allLocations.stream()
                .collect(Collectors.toMap(l -> l, l -> Integer.MAX_VALUE));

        for (Location markedLoc: markedLocs) {
            // Get the minimum distances from the marked location to every other location.
            Map<Location, Integer> currDistance = dijkstra(markedLoc, allLocations, backwardNeighbors);

            // Update minimum distance map.
            if (currDistance.get(initialLoc) < minDistance.get(initialLoc)) {
                // Replace map.
                minDistance = currDistance;
            } else if (currDistance.get(initialLoc) == minDistance.get(initialLoc)) {
                // Merge maps.
                for (Location loc: allLocations) {
                    if (currDistance.get(loc) < minDistance.get(loc)) {
                        minDistance.put(loc, currDistance.get(loc));
                    }
                }
            }
        }

        // Sanity check: there exists at least one path to a marked location.
        Verify.verify(minDistance.get(initialLoc) < Integer.MAX_VALUE);

        // Use a BFS to update the distances when an uncontrollable edge is found. Return the uncontrollable-event-aware
        // distance of all locations from the start location.
        for (Location markedLoc: markedLocs) {
            updateLocationDistance(markedLoc, minDistance);
        }

        return minDistance;
    }

    private static Map<Location, Integer> dijkstra(Location startLoc, List<Location> allLocations,
            Map<Location, Set<Location>> neighbors)
    {
        // Store the location minimum distance from the start location.
        Map<Location, Integer> minDistance = new LinkedHashMap<>();

        // PriorityQueue to store pairs (distance, location) to be processed.
        PriorityQueue<Location> pq = new PriorityQueue<>(
                Comparator.comparingInt(p -> minDistance.getOrDefault(p, Integer.MAX_VALUE)));

        // Initialization: set the distance of the start location to zero and of every other location to the maximum
        // value; add all locations to the queue.
        for (Location loc: allLocations) {
            if (loc.equals(startLoc)) {
                minDistance.put(loc, 0);
            } else {
                minDistance.put(loc, Integer.MAX_VALUE);
            }
            pq.offer(loc);
        }
        minDistance.put(startLoc, 0);

        while (!pq.isEmpty()) {
            // Get the location with the minimum distance.
            Location currentLoc = pq.poll();
            int currentDist = minDistance.get(currentLoc);

            // Explore all the neighbors that are not in the queue.
            for (Location neighbor: neighbors.get(currentLoc)) {
                if (pq.contains(neighbor)) {
                    int neighborDist = minDistance.get(neighbor);
                    int currentDistPlusOne = (currentDist == Integer.MAX_VALUE) ? Integer.MAX_VALUE : currentDist + 1;

                    // If there is a shorter path to the neighbor through the current node, update
                    // the distance and add the pair to the queue.
                    if (currentDistPlusOne < neighborDist) {
                        neighborDist = currentDistPlusOne;
                        minDistance.put(neighbor, neighborDist);

                        // Update location distance in the priority queue.
                        pq.remove(neighbor);
                        pq.offer(neighbor);
                    }
                }
            }
        }

        return minDistance;
    }

    private void updateLocationDistance(Location startLoc, Map<Location, Integer> minDistance) {
        // Run a BFS and update the distance map if a location has any uncontrollable edges with a larger distance.
        Queue<Location> queue = new LinkedList<>();
        queue.add(startLoc);
        Set<Location> visited = new LinkedHashSet<>();
        while (!queue.isEmpty()) {
            // Get the first element of the queue, and analyze its neighbors.
            Location currentLoc = queue.poll();

            // If this node was already visited, skip it.
            if (visited.contains(currentLoc)) {
                continue;
            }

            // Update the location distance if one of the forward neighbors is connected through an uncontrollable edge
            // with a larger distance.
            int currentLocDistance = minDistance.get(currentLoc);
            int minDistForwardNeighbors = Integer.MAX_VALUE;
            for (Location neighbor: forwardNeighbors.get(currentLoc)) {
                for (Edge edge: neighborsEdges.get(Pair.of(currentLoc, neighbor))) {
                    List<Event> events = new ArrayList<>(CifEventUtils.getEvents(edge));

                    // If the forward neighbor is not in the direct path to the current marked location, the minimum
                    // distance map is set to max value of integers.
                    if (!events.get(0).getControllable() && minDistance.get(neighbor) >= currentLocDistance) {
                        currentLocDistance = (minDistance.get(neighbor) == Integer.MAX_VALUE) ? Integer.MAX_VALUE
                                : minDistance.get(neighbor) + 1;
                    }

                    // Keep track of the minimum distance of any next-step neighbor.
                    if (minDistForwardNeighbors > minDistance.get(neighbor)) {
                        minDistForwardNeighbors = minDistance.get(neighbor);
                    }
                }
            }

            // If there is no neighbor, the minimum distance of the neighbors is the maximum integer value, which will
            // overflow when adding +1. In this way, the distance remains the same. If there are neighbors and have a
            // distance greater than the current+1, the distance of the current location is updated. If all the
            // neighbors have distance equal to the maximum value, and the current location's distance is smaller than
            // the maximum value, the distance remains unchanged. This can only happen if the neighbors have an epsilon
            // loop or cycle: this situation is taken care in the method
            // TODO:
            minDistance.put(currentLoc, Math.max(currentLocDistance, minDistForwardNeighbors + 1));

            // Add all backwards neighbors, if not already visited.
            for (Location neighbor: backwardNeighbors.get(currentLoc)) {
                if (!visited.contains(neighbor)) {
                    queue.add(neighbor);
                }
            }

            // Mark the current location as visited.
            visited.add(currentLoc);
        }
    }

    private void markEssentialLocationAndEdges(Location currentLoc, Map<Location, Integer> minDistance) {
        // Mark the current location as essential, and get its depth.
        essentialLocs.add(currentLoc);

        if (forwardNeighbors.get(currentLoc).isEmpty()) {
            // Add empty set for marked location.
            essentialLocsToEssentialEdges.put(currentLoc, new LinkedHashSet<>());
        }

        // Find forward neighbors with minimum distance.
        int minDistNeighbors = Integer.MAX_VALUE;
        Set<Location> nextStepNeighbors = new LinkedHashSet<>();
        for (Location loc: forwardNeighbors.get(currentLoc)) {
            if (minDistance.get(loc) < minDistNeighbors) {
                minDistNeighbors = minDistance.get(loc);
                nextStepNeighbors = new LinkedHashSet<>();
                nextStepNeighbors.add(loc);
            } else if (minDistance.get(loc) == minDistNeighbors) {
                nextStepNeighbors.add(loc);
            }
        }

        for (Edge edge: currentLoc.getEdges()) {
            // If uncontrollable or the target is the next step in the shortest path, mark the edge as essential.
            List<Event> events = new ArrayList<>(CifEventUtils.getEvents(edge));
            if (!events.get(0).getControllable() || minDistance.get(CifEdgeUtils.getTarget(edge)) == minDistNeighbors) {
                essentialLocsToEssentialEdges.computeIfAbsent(currentLoc, k -> new LinkedHashSet<>()).add(edge);
                if (!essentialLocs.contains(CifEdgeUtils.getTarget(edge))) {
                    markEssentialLocationAndEdges(CifEdgeUtils.getTarget(edge), minDistance);
                }
            }
        }
    }

    private void removeRedundantElements(Automaton automa) {
        // Remove all redundant locations and redundant edges of essential locations.
        Set<Location> locsToRemove = new LinkedHashSet<>();
        for (Location loc: automa.getLocations()) {
            if (!essentialLocs.contains(loc)) {
                locsToRemove.add(loc);
            } else {
                // Remove redundant edges if location is essential.
                Set<Edge> locEssentialEdges = essentialLocsToEssentialEdges.get(loc);
                Set<Edge> edgesToRemove = new LinkedHashSet<>();
                for (Edge edge: loc.getEdges()) {
                    if (!locEssentialEdges.contains(edge)) {
                        edgesToRemove.add(edge);
                    }
                }
                loc.getEdges().removeAll(edgesToRemove);
            }
        }
        automa.getLocations().removeAll(locsToRemove);
    }
}
