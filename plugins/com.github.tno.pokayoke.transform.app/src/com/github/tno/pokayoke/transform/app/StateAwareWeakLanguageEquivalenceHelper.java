
package com.github.tno.pokayoke.transform.app;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.annotations.AnnotationArgument;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.cif.metamodel.java.CifConstructors;

import com.github.tno.pokayoke.transform.activitysynthesis.StateAnnotationHelper;
import com.google.common.base.Verify;

/**
 * Helper for the language equivalence check. Assumes that the CIF models are generated by the CIF state space explorer.
 */
public class StateAwareWeakLanguageEquivalenceHelper {
    private StateAwareWeakLanguageEquivalenceHelper() {
    }

    /**
     * Prepares two CIF models for the language equivalence check. Performs sanity checks, removes internal variables
     * from state annotations, and maps the events of one state space to the events of the other. Returns a record
     * containing the mapped events, and the filtered state annotations.
     *
     * @param model1 The first CIF model.
     * @param namesToEvents1 The map from names of UML elements to CIF events, for the first state space.
     * @param tauEvents1 The set of events that represent tau transitions, for the first state space.
     * @param model2 The second CIF model.
     * @param namesToEvents2 The map from names of UML elements to CIF events, for the second state space.
     * @param tauEvents2 The set of events that represent tau transitions, for the second state space.
     * @param externalVariableNames The set containing external variables names.
     * @return The model preparation result.
     */
    public static ModelPreparationResult prepareModels(Specification model1, Map<String, List<Event>> namesToEvents1,
            Set<Event> tauEvents1, Specification model2, Map<String, List<Event>> namesToEvents2, Set<Event> tauEvents2,
            Set<String> externalVariableNames)
    {
        // Sanity checks. The models should only have one component, an automaton.
        Verify.verify(model1.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model2.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model1.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");
        Verify.verify(model2.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");

        Automaton stateSpace1 = (Automaton)model1.getComponents().get(0);
        Automaton stateSpace2 = (Automaton)model2.getComponents().get(0);

        // Filter internal variables from state annotations.
        Map<Location, Annotation> filteredStateAnn1 = filterStateAnnotations(model1, externalVariableNames);
        Map<Location, Annotation> filteredStateAnn2 = filterStateAnnotations(model2, externalVariableNames);

        // Sanity check: check that the tau and non-tau events represent the entire state space alphabet.
        Verify.verify(checkAlphabetCoverage(stateSpace1, namesToEvents1, tauEvents1));
        Verify.verify(checkAlphabetCoverage(stateSpace2, namesToEvents2, tauEvents2));

        // Filter unused events from the state space alphabet.
        Set<String> unusedEvents1 = removeUnusedEvents(stateSpace1);
        Set<String> unusedEvents2 = removeUnusedEvents(stateSpace2);

        // Check that the two alphabets are compatible, and create a set of pairs with the corresponding list of events.
        Set<Pair<List<Event>, List<Event>>> pairedEvents = getPairedEvents(namesToEvents1, unusedEvents1,
                namesToEvents2, unusedEvents2);

        return new ModelPreparationResult(pairedEvents, filteredStateAnn1, filteredStateAnn2);
    }

    private static Map<Location, Annotation> filterStateAnnotations(Specification model,
            Set<String> externalVariableNames)
    {
        // Get state annotations for the CIF model.
        Map<Location, List<Annotation>> locToAnnotations = StateAnnotationHelper.getStateAnnotations(model);

        // Verify that each location has only one annotation. This is always the case with CIF model generated with the
        // state space exploration.
        locToAnnotations.values().stream().forEach(
                a -> Verify.verify(a.size() == 1, "Found state that doesn't have exactly one state annotation."));

        // Filter the state annotations from internal variables.
        Map<Location, Annotation> locToFilteredAnnotations = new LinkedHashMap<>();

        for (Entry<Location, List<Annotation>> locToAnnotation: locToAnnotations.entrySet()) {
            Location loc = locToAnnotation.getKey();
            List<Annotation> annotations = locToAnnotation.getValue();
            Annotation annotation = annotations.get(0);

            // Filter and create new annotation.
            List<AnnotationArgument> filteredArgs = annotation.getArguments().stream()
                    .filter(arg -> externalVariableNames.contains(arg.getName())).toList();
            Annotation filteredAnnotation = CifConstructors.newAnnotation(filteredArgs, annotation.getName(),
                    annotation.getPosition());
            locToFilteredAnnotations.put(loc, filteredAnnotation);
        }

        return locToFilteredAnnotations;
    }

    private static Set<String> removeUnusedEvents(Automaton automa) {
        // Removes the unused events from the alphabet, and returns the unused events names.
        Set<Event> preFilterAlphabet = CifEventUtils.getAlphabet(automa);
        automa.setAlphabet(null);
        Set<Event> postFilterAlphabet = CifEventUtils.getAlphabet(automa);
        preFilterAlphabet.removeAll(postFilterAlphabet);
        return preFilterAlphabet.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
    }

    private static boolean checkAlphabetCoverage(Automaton automa, Map<String, List<Event>> namesToEvents,
            Set<Event> tauEvents)
    {
        // Check that the alphabet of the state space is equal to the union of non-tau and the tau events. This check is
        // performed by absolute names, since they are different objects.
        Set<Event> eventsMerged = new LinkedHashSet<>();
        namesToEvents.values().forEach(e -> eventsMerged.addAll(e));
        eventsMerged.addAll(tauEvents);

        Set<Event> automaAlphabet = CifEventUtils.getAlphabet(automa);
        Set<String> absNamesAutoma = automaAlphabet.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesEventsMerged = eventsMerged.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        return absNamesAutoma.equals(absNamesEventsMerged);
    }

    /**
     * Compute the events from two state spaces that represent the same UML element, and pair them together. If the
     * events in one state space are not related to any event in the other state space, return 'null' to indicate that
     * the two state spaces are not compatible.
     *
     * @param namesToEvents1 The map from the name of the UML element to the list of events related to it.
     * @param unusedEvents1 Names of events that are not used in the first state space.
     * @param namesToEvents2 The map from the name of the UML element to the list of events related to it.
     * @param unusedEvents2 Names of events that are not used in the second state space.
     * @return A set of paired (lists of) events.
     */
    private static Set<Pair<List<Event>, List<Event>>> getPairedEvents(Map<String, List<Event>> namesToEvents1,
            Set<String> unusedEvents1, Map<String, List<Event>> namesToEvents2, Set<String> unusedEvents2)
    {
        Set<Pair<List<Event>, List<Event>>> pairedEvents = new LinkedHashSet<>();
        for (Entry<String, List<Event>> entry: namesToEvents1.entrySet()) {
            String umlElementName = entry.getKey();
            List<Event> events1 = entry.getValue();
            List<Event> events2 = namesToEvents2.getOrDefault(umlElementName, new ArrayList<>());

            // Remove events that are not used.
            List<Event> usedEvents1 = events1.stream().filter(e -> !unusedEvents1.contains(CifTextUtils.getAbsName(e)))
                    .toList();
            List<Event> usedEvents2 = events2.stream().filter(e -> !unusedEvents2.contains(CifTextUtils.getAbsName(e)))
                    .toList();

            // Remove the item from the second map, to later check that all items from the second map have been looped
            // through.
            namesToEvents2.remove(umlElementName);

            if (!usedEvents1.isEmpty() && !usedEvents2.isEmpty()) {
                // Pair the two lists of equivalent events.
                pairedEvents.add(Pair.of(usedEvents1, usedEvents2));
            } else if (usedEvents1.isEmpty() != usedEvents2.isEmpty()) {
                // If one set of events is empty and the other is not, one model can have a transition while the other
                // model cannot; this means that the two models are not compatible. Return 'null' to signal that the two
                // event sets are not compatible.
                return null;
            }
        }

        // If second map is not empty, the two state spaces are not compatible.
        return namesToEvents2.isEmpty() ? pairedEvents : null;
    }

    /**
     * The result of the manipulation of the two CIF models.
     *
     * @param pairedEvents The set containing the corresponding events from the two state spaces, stored in pairs.
     * @param stateAnnotations1 The filtered state annotations for the first state space.
     * @param stateAnnotations2 The filtered state annotations for the second state space.
     */
    record ModelPreparationResult(Set<Pair<List<Event>, List<Event>>> pairedEvents,
            Map<Location, Annotation> stateAnnotations1, Map<Location, Annotation> stateAnnotations2)
    {
    }
}
