/**
 *
 */

package com.github.tno.pokayoke.transform.app;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.AnnotationEqHashWrap;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.cif.metamodel.cif.expressions.BoolExpression;
import org.eclipse.escet.cif.metamodel.cif.expressions.EventExpression;

import com.google.common.base.Verify;

/**
 * Weak trace equivalence checker of two CIF models that considers state annotations. The two models must contain a
 * unique automaton, and have a compatible alphabet. Alphabets are compatible when they have the same number of events,
 * with possibly different names. Assumes the two models are generated by the CIF state space exploration, and that they
 * are deterministic.
 */
public class StateAwareWeakTraceEquivalenceChecker {
    public StateAwareWeakTraceEquivalenceChecker() {
    }

    /**
     * Checks whether two CIF automata are language equivalent.
     *
     * @param automaton1 The first CIF automaton.
     * @param stateAnnotations1 The map from CIF locations to their state annotations, for the first model.
     * @param epsilonEvents1 The set containing events that represent an epsilon transition for the first model.
     * @param automaton2 The second CIF automaton.
     * @param stateAnnotations2 The map from CIF locations to their state annotations, for the second model.
     * @param epsilonEvents2 The set containing events that represent an epsilon transition for the second model.
     * @param pairedEvents The set containing pairs of corresponding lists of events for the two automata.
     * @return {@code true} if the two automata are language equivalent, {@code false} otherwise.
     */
    public boolean check(Automaton automaton1, Map<Location, Annotation> stateAnnotations1, Set<Event> epsilonEvents1,
            Automaton automaton2, Map<Location, Annotation> stateAnnotations2, Set<Event> epsilonEvents2,
            Set<Pair<List<Event>, List<Event>>> pairedEvents)
    {
        // Initialize queue.
        Queue<Pair<Set<Location>, Set<Location>>> queue = initializeQueue(automaton1, stateAnnotations1, automaton2,
                stateAnnotations2);
        Set<Pair<Set<Location>, Set<Location>>> visitedPairs = new LinkedHashSet<>();
        visitedPairs.addAll(queue);

        // Get absolute names of epsilon events.
        Set<String> absNamesEpsEvents1 = epsilonEvents1.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesEpsEvents2 = epsilonEvents2.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        while (!queue.isEmpty()) {
            // Pop first element of the queue.
            Pair<Set<Location>, Set<Location>> currentPair = queue.remove();

            // Compute epsilon-reachable states and their projections.
            Set<Location> epsilonReachableLocations1 = getEpsilonReachableLocations(currentPair.getLeft(),
                    absNamesEpsEvents1);
            Set<Location> epsilonReachableLocations2 = getEpsilonReachableLocations(currentPair.getRight(),
                    absNamesEpsEvents2);
            List<Location> projectedLocations1 = projectLocations(epsilonReachableLocations1, stateAnnotations1);
            List<Location> projectedLocations2 = projectLocations(epsilonReachableLocations2, stateAnnotations2);

            // Sanity check: all events must be deterministic.
            Verify.verify(projectedLocations1.size() == 1, "Epsilon reachability found extra locations.");
            Verify.verify(projectedLocations2.size() == 1, "Epsilon reachability found extra locations.");

            // If projections are not equal, the two models are not equivalent.
            if (!areEquivalentLocations(projectedLocations1.get(0), stateAnnotations1, projectedLocations2.get(0),
                    stateAnnotations2))
            {
                return false;
            } else {
                // Find next states for each event in the compatible event set.
                for (Pair<List<Event>, List<Event>> events: pairedEvents) {
                    Set<Location> targetStates1 = getNextLocations(epsilonReachableLocations1, events.getKey());
                    Set<Location> targetStates2 = getNextLocations(epsilonReachableLocations2, events.getValue());

                    // If one location can reach some target with this action, but the other location cannot reach any,
                    // the two models are different. Note that this is different from checking the sizes of the target
                    // sets, which can be different. This works only if the size of one is zero while the size of the
                    // other is not zero.
                    if (targetStates1.size() > 0 != targetStates2.size() > 0) {
                        return false;
                    } else if (targetStates1.size() > 0) {
                        // Add the next pair to the queue, if not already visited.
                        Pair<Set<Location>, Set<Location>> nextPair = Pair.of(targetStates1, targetStates2);
                        if (!visitedPairs.contains(nextPair)) {
                            visitedPairs.add(nextPair);
                            queue.add(nextPair);
                        }
                    }
                }
            }
        }

        return true;
    }

    private Queue<Pair<Set<Location>, Set<Location>>> initializeQueue(Automaton automaton1,
            Map<Location, Annotation> annotations1, Automaton automaton2, Map<Location, Annotation> annotations2)
    {
        Queue<Pair<Set<Location>, Set<Location>>> queue = new LinkedList<>();

        // Find initial locations of the first automaton. The check whether the location is initial assumes that the
        // automaton is generated by the state space exploration.
        Set<Location> initialLoc1 = new LinkedHashSet<>();
        for (Location loc: automaton1.getLocations()) {
            if (!loc.getInitials().isEmpty() && ((BoolExpression)loc.getInitials().get(0)).isValue()) {
                initialLoc1.add(loc);
            }
        }

        // Find initial locations of the second automaton. The check whether the location is initial assumes that the
        // automaton is generated by the state space exploration.
        Set<Location> initialLoc2 = new LinkedHashSet<>();
        for (Location loc: automaton2.getLocations()) {
            if (!loc.getInitials().isEmpty() && ((BoolExpression)loc.getInitials().get(0)).isValue()) {
                initialLoc2.add(loc);
            }
        }

        // Loop over all initial states of the two automata, find the equivalent ones (i.e. have the same annotations),
        // and pair them together.
        for (Location loc1: initialLoc1) {
            for (Location loc2: initialLoc2) {
                if (areEquivalentLocations(loc1, annotations1, loc2, annotations2)) {
                    LinkedHashSet<Location> p1 = new LinkedHashSet<>(Arrays.asList(loc1));
                    LinkedHashSet<Location> p2 = new LinkedHashSet<>(Arrays.asList(loc2));
                    queue.add(Pair.of(p1, p2));
                }
            }
        }

        return queue;
    }

    private boolean areEquivalentLocations(Location loc1, Map<Location, Annotation> stateAnnotations1, Location loc2,
            Map<Location, Annotation> stateAnnotations2)
    {
        // Locations are equivalent if their annotations are equivalent.
        return areEquivalentAnnotations(stateAnnotations1.get(loc1), stateAnnotations2.get(loc2));
    }

    private boolean areEquivalentAnnotations(Annotation ann1, Annotation ann2) {
        AnnotationEqHashWrap annotationWrapped1 = new AnnotationEqHashWrap(ann1);
        AnnotationEqHashWrap annotationWrapped2 = new AnnotationEqHashWrap(ann2);
        return annotationWrapped1.equals(annotationWrapped2);
    }

    private Set<Location> getEpsilonReachableLocations(Set<Location> locations, Set<String> epsilonEvents) {
        // Perform epsilon reachability computation for all locations, for all epsilon events.
        LinkedHashSet<Location> epsilonReachableLocs = new LinkedHashSet<>();
        for (Location state: locations) {
            Set<Location> epsilonReachedLocs = epsilonReach(state, epsilonEvents,
                    new LinkedHashSet<>(Arrays.asList(state)));
            epsilonReachableLocs.addAll(epsilonReachedLocs);
        }
        return epsilonReachableLocs;
    }

    private Set<Location> epsilonReach(Location loc, Set<String> epsilonEvents, Set<Location> epsilonReachedLocations) {
        // Perform epsilon reachability computation for the current location, for all epsilon events.
        for (Edge edge: loc.getEdges()) {
            Set<Event> edgeEvents = CifEventUtils.getEvents(edge);
            for (Event edgeEvent: edgeEvents) {
                if (epsilonEvents.contains(CifTextUtils.getAbsName(edgeEvent))) {
                    // Add target location and perform a recursive call.
                    Location target = edge.getTarget();
                    epsilonReachedLocations.add(target);
                    epsilonReach(edge.getTarget(), epsilonEvents, epsilonReachedLocations);
                }
            }
        }
        return epsilonReachedLocations;
    }

    private List<Location> projectLocations(Set<Location> locations, Map<Location, Annotation> locToAnnotations) {
        // Find the projection for all locations, and store them in a list.
        List<Annotation> projectedAnnotationsAllLocations = new LinkedList<>();
        List<Location> projectedLocations = new LinkedList<>();

        for (Location loc: locations) {
            if (projectedAnnotationsAllLocations.isEmpty()) {
                // Add the first annotation and the first state into the lists.
                projectedAnnotationsAllLocations.add(locToAnnotations.get(loc));
                projectedLocations.add(loc);
            } else {
                // If there is one element in the projected annotations list which is equivalent to the current one, do
                // not add to the list.
                if (!projectedAnnotationsAllLocations.stream()
                        .anyMatch(s -> areEquivalentAnnotations(s, locToAnnotations.get(loc))))
                {
                    projectedAnnotationsAllLocations.add(locToAnnotations.get(loc));
                    projectedLocations.add(loc);
                }
            }
        }
        return projectedLocations;
    }

    private Set<Location> getNextLocations(Set<Location> sourceLocations, List<Event> events) {
        // Get next location for all source locations, for all events.
        LinkedHashSet<Location> targetStates = new LinkedHashSet<>();
        for (Location loc: sourceLocations) {
            for (Event event: events) {
                Set<Location> targets = getNext(loc, event);
                targetStates.addAll(targets);
            }
        }
        return targetStates;
    }

    private Set<Location> getNext(Location loc, Event event) {
        // Get next locations starting from the current location, using the current event.
        Set<Location> nextLocations = new LinkedHashSet<>();
        for (Edge edge: loc.getEdges()) {
            Event locEvent = ((EventExpression)edge.getEvents().get(0).getEvent()).getEvent();
            // Comparison is by name, since the events might be different object.
            if (CifTextUtils.getAbsName(event).equals(CifTextUtils.getAbsName(locEvent))) {
                nextLocations.add(edge.getTarget());
            }
        }

        return nextLocations;
    }
}
