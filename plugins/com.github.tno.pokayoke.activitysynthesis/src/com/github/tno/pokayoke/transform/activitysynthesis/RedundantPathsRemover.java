/**
 *
 */

package com.github.tno.pokayoke.transform.activitysynthesis;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.escet.cif.bdd.spec.CifBddSpec;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.io.CifWriter;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.common.app.framework.AppEnv;
import org.eclipse.escet.common.position.metamodel.position.PositionObject;

import com.google.common.base.Verify;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;

/**
 * Removes redundant paths from any initial CIF states to any CIF marked state. Assumes the input is generated from the
 * CIF state space explorer.
 */
public class RedundantPathsRemover {
    /** The set of states that belong to a shortest path; these are called essential or non-redundant. */
    private Set<Location> essentialStates = new LinkedHashSet<>();

    /** The map from essential states to their essential edges. */
    private Map<Location, Set<Edge>> essentialStatesToEssentialEdges = new LinkedHashMap<>();

    /** The set of all initial states of the state space. */
    private Set<Location> initialStates = new LinkedHashSet<>();

    /** The set of all marked states of the state space. */
    private Set<Location> markedStates = new LinkedHashSet<>();

    /** The map from states to their children and the connecting edges. */
    Map<Location, Map<Location, Edge>> childrenToEdges = new LinkedHashMap<>();

    /** The one-to-one mapping from states to the corresponding NodeInfo object. */
    BiMap<Location, NodeInfo> stateNodeInfoMap = HashBiMap.create();

    /** The one-to-one mapping from states and edges to their index. */
    private BiMap<PositionObject, Integer> statesAndEdgesToIndex = HashBiMap.create();

    public RedundantPathsRemover() {
        // Static class.
    }

    /**
     * Removes the redundant paths from a CIF model generated by the state space exploration. From each initial state
     * finds the shortest path to a marked state, accounting for paths emerging from uncontrollable edges.
     *
     * @param model The input CIF specification, generated from the state space exploration.
     * @param bddSpec The CIF-BDD specification.
     * @param outputFilePath The path to the output file to write the transformation result to.
     * @param outputFolderPath The path to the folder in which the transformation result is to be written.
     */
    public void simplify(Specification model, CifBddSpec bddSpec, Path outputFilePath, Path outputFolderPath) {
        // Sanity check: the CIF model should contain only one automaton.
        Verify.verify(model.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");

        Automaton stateSpace = (Automaton)model.getComponents().get(0);

        // Compute initial and marked states.
        findInitialAndMarkedStates(stateSpace);

        // Sanity check: initial and marked states must not be empty.
        Verify.verify(initialStates != null && !initialStates.isEmpty(), "Found empty initial set.");
        Verify.verify(markedStates != null && !markedStates.isEmpty(), "Found empty target set.");

        // Create map from states and edges to indexes for the bitsets.
        enumerateElements(stateSpace);

        // Create NodeInfo objects for all states.
        createNodeInfos(stateSpace.getLocations());

        // Call the minimum sub-graph algorithm.
        Set<NodeInfo> markedNodeInfo = markedStates.stream().map(m -> stateNodeInfoMap.get(m))
                .collect(Collectors.toSet());
        computeMinSubGraph(markedNodeInfo);

        // Mark the minimum sub-graphs as essential.
        for (Location initialState: initialStates) {
            markEssentialStatesAndEdges(initialState);
        }

        // Remove every non-essential, redundant element.
        removeRedundantElements(stateSpace);

        // Write the essential model.
        try {
            AppEnv.registerSimple();
            CifWriter.writeCifSpec(model, outputFilePath.toString(), outputFolderPath.toString());
        } finally {
            AppEnv.unregisterApplication();
        }
    }

    private void findInitialAndMarkedStates(Automaton stateSpace) {
        // Find initial and marked states of the state space.
        for (Location state: stateSpace.getLocations()) {
            if (CifLocationHelper.isInitial(state)) {
                initialStates.add(state);
            }
            if (CifLocationHelper.isMarked(state)) {
                markedStates.add(state);
            }
        }
    }

    private void enumerateElements(Automaton stateSpace) {
        int counter = 0;
        Set<PositionObject> visited = new LinkedHashSet<>();
        for (Location state: stateSpace.getLocations()) {
            if (!visited.contains(state)) {
                statesAndEdgesToIndex.put(state, counter);
                counter++;
                visited.add(state);
                for (Edge edge: state.getEdges()) {
                    if (!visited.contains(edge)) {
                        statesAndEdgesToIndex.put(edge, counter);
                        counter++;
                        visited.add(edge);
                    }
                }
            }
        }
    }

    private void createNodeInfos(List<Location> states) {
        // For all states, create a NodeInfo object, and fills its fields with empty values. Store it in a map for later
        // handling.
        int graphSize = statesAndEdgesToIndex.size();
        for (Location state: states) {
            NodeInfo emptyNodeInfo = new NodeInfo(state, new LinkedHashSet<>(), new LinkedHashSet<>(),
                    new LinkedHashMap<>(), new ArrayList<>());
            emptyNodeInfo.getMinSubGraphs().add(new BitSet(graphSize));
            stateNodeInfoMap.put(state, emptyNodeInfo);
        }

        for (Location state: states) {
            // Computes the forward and backward neighbors for every state.
            NodeInfo currentNodeInfo = stateNodeInfoMap.get(state);

            for (Edge edge: state.getEdges()) {
                // Update current NodeInfo fields.
                if (CifEdgeUtils.isSelfLoop(edge)) {
                    currentNodeInfo.getChildren().add(currentNodeInfo);
                    currentNodeInfo.getParents().add(currentNodeInfo);
                    currentNodeInfo.getChildrenToEdges().computeIfAbsent(currentNodeInfo, v -> new LinkedHashSet<>())
                            .add(edge);
                } else {
                    NodeInfo targetNodeInfo = stateNodeInfoMap.get(CifEdgeUtils.getTarget(edge));
                    currentNodeInfo.getChildren().add(targetNodeInfo);
                    targetNodeInfo.getParents().add(currentNodeInfo);
                    currentNodeInfo.getChildrenToEdges().computeIfAbsent(targetNodeInfo, v -> new LinkedHashSet<>())
                            .add(edge);
                }
            }
        }
    }

    /**
     * Computes the minimum sub-graph for the backward reachable states starting from a set of (marked) states.
     *
     * @param markedNodeInfo The set containing the NodeInfo objects corresponding to marked states.
     */
    private void computeMinSubGraph(Set<NodeInfo> markedNodeInfo) {
        // Run a BFS-like algorithm and update the minimum sub-graph of each NodeInfo object.
        Queue<NodeInfo> queue = new LinkedList<>();
        queue.addAll(markedNodeInfo);

        while (!queue.isEmpty()) {
            // Get the first element of the queue, and analyze its neighbors.
            NodeInfo currentNodeInfo = queue.poll();

            Set<NodeInfo> children = currentNodeInfo.getChildren();
            int minChildSubGraphSize = Integer.MAX_VALUE;
            Set<NodeInfo> chosenChildren = new LinkedHashSet<>();

            // All minimum sub-graphs have the same size: get the size of the first one (could be zero if empty set).
            int sizePreUnion = currentNodeInfo.getMinSubGraphs().get(0).cardinality();

            // For each child, get its minimum sub-graph and compare it with the current NodeInfo sub-graph.
            // A) If the edge connecting the two states is uncontrollable, store the largest sub-graph, since we must
            // consider the maximum length (worst-case) path stemming from an uncontrollable edge for all states.
            // Otherwise,
            // B) If the edge is controllable, compare the size of the sub-graph and choose the children with the
            // minimum sub-graph; update the current NodeInfo considering the smallest sub-graph of its children.
            for (NodeInfo child: children) {
                List<BitSet> childMinSubGraphs = child.getMinSubGraphs();
                int currentChildMinSubGraphSize = childMinSubGraphs.get(0).cardinality();

                for (Edge childEdge: currentNodeInfo.getChildrenToEdges().get(child)) {
                    List<Event> events = new ArrayList<>(CifEventUtils.getEvents(childEdge));

                    if (!events.get(0).getControllable()) {
                        // Choose the child with the largest sub-graph.
                        // TODO
                    } else {
                        // Choose the child with smallest sub-graph.
                        if (minChildSubGraphSize > currentChildMinSubGraphSize) {
                            chosenChildren = new LinkedHashSet<>();
                            chosenChildren.add(child);
                        } else if (minChildSubGraphSize == currentChildMinSubGraphSize) {
                            chosenChildren.add(child);
                        }
                    }
                }
            }

            // Add sub-graph of the chosen controllable children to the current node info.
            List<BitSet> allUpdatedMinSubGraphsList = new ArrayList<>();
            for (BitSet currentMinSubGraph: currentNodeInfo.getMinSubGraphs()) {
                for (NodeInfo child: chosenChildren) {
                    for (BitSet childMinSubGraph: child.getMinSubGraphs()) {
                        BitSet updatedMinSubGraph = new BitSet(statesAndEdgesToIndex.size());
                        updatedMinSubGraph.or(currentMinSubGraph); // Copy current min sub-graph.
                        updatedMinSubGraph.set(statesAndEdgesToIndex.get(child.getLocation())); // Add child.
                        for (Edge edge: currentNodeInfo.getChildrenToEdges().get(child)) {
                            // Add the edges connecting the current node to the child.
                            updatedMinSubGraph.set(statesAndEdgesToIndex.get(edge));
                        }
                        updatedMinSubGraph.or(childMinSubGraph); // Add the children bitset to the current bitset.
                        allUpdatedMinSubGraphsList.add(updatedMinSubGraph);
                    }
                }
            }

            if (!allUpdatedMinSubGraphsList.isEmpty()) {
                currentNodeInfo.setMinSubGraphs(allUpdatedMinSubGraphsList);
            }

            // If current NodeInfo sub-graph has been updated, or if the current NodeInfo corresponds to a marked
            // state, add the current NodeInfo parents to the queue.
            if (sizePreUnion == 0 || sizePreUnion != currentNodeInfo.getMinSubGraphs().get(0).cardinality()) {
                queue.addAll(currentNodeInfo.getParents());
            }
        }
    }

    private void markEssentialStatesAndEdges(Location currentState) {
        // Mark the current state as essential.
        essentialStates.add(currentState);

        if (stateNodeInfoMap.get(currentState).getMinSubGraphs().isEmpty()) {
            // Add empty set for marked state.
            essentialStatesToEssentialEdges.put(currentState, new LinkedHashSet<>());
        }

        for (BitSet minSubGraph: stateNodeInfoMap.get(currentState).getMinSubGraphs()) {
            for (int i = minSubGraph.nextSetBit(0); i >= 0; i = minSubGraph.nextSetBit(i + 1)) {
                // Get the next element indexed in the bitset.
                PositionObject stateOrEdge = statesAndEdgesToIndex.inverse().get(i);

                // If the current element is an edge, add it to the map from essential state to essential edges; if
                // it is a state, call recursively the method.
                if (stateOrEdge instanceof Edge edge) {
                    essentialStatesToEssentialEdges.computeIfAbsent(currentState, k -> new LinkedHashSet<>()).add(edge);
                } else if (stateOrEdge instanceof Location nextState) {
                    if (!essentialStates.contains(nextState)) {
                        markEssentialStatesAndEdges(nextState);
                    }
                } else {
                    throw new RuntimeException("Found unsupported element in sub-graph.");
                }

                if (i == Integer.MAX_VALUE) {
                    break; // or (i+1) would overflow
                }
            }
        }
    }

    private void removeRedundantElements(Automaton stateSpace) {
        // Remove all redundant states and redundant edges of essential states.
        Set<Location> statesToRemove = new LinkedHashSet<>();
        for (Location state: stateSpace.getLocations()) {
            if (!essentialStates.contains(state)) {
                statesToRemove.add(state);
            } else {
                // Remove redundant edges if state is essential.
                Set<Edge> stateEssentialEdges = essentialStatesToEssentialEdges.get(state);
                Set<Edge> edgesToRemove = new LinkedHashSet<>();
                for (Edge edge: state.getEdges()) {
                    if (!stateEssentialEdges.contains(edge)) {
                        edgesToRemove.add(edge);
                    }
                }
                state.getEdges().removeAll(edgesToRemove);
            }
        }
        stateSpace.getLocations().removeAll(statesToRemove);
    }
}
