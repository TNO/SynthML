/**
 *
 */

package com.github.tno.pokayoke.transform.activitysynthesis;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.escet.cif.bdd.spec.CifBddSpec;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.io.CifWriter;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.common.app.framework.AppEnv;

import com.google.common.base.Verify;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;

/**
 * Removes redundant paths from any initial CIF locations to any CIF marked location. Assumes the input is generated
 * from the CIF state space explorer.
 */
public class RedundantPathsCleaner {
    /** The set of locations that belong to a shortest path; these are called essential or non-redundant. */
    private Set<Location> essentialLocs = new LinkedHashSet<>();

    /** The map from essential locations to their essential edges. */
    private Map<Location, Set<Edge>> essentialLocsToEssentialEdges = new LinkedHashMap<>();

    /** The set of all initial locations of the automaton. */
    private Set<Location> initialLocs = new LinkedHashSet<>();

    /** The set of all marked locations of the automaton. */
    private Set<Location> markedLocs = new LinkedHashSet<>();

    /** The map from locations to their children and the connecting edges. */
    Map<Location, Map<Location, Edge>> childrenToEdges = new LinkedHashMap<>();

    /** The one-to-one mapping from locations to the corresponding NodeInfo object. */
    BiMap<Location, NodeInfo> locationNodeInfoMap = HashBiMap.create();

    public RedundantPathsCleaner() {
        // Static class.
    }

    /**
     * Removes the redundant paths from a CIF model generated by the state space exploration. From each initial location
     * finds the shortest path to a marked location, accounting for paths emerging from uncontrollable edges.
     *
     * @param model The input CIF specification, generated from the state space exploration.
     * @param bddSpec The CIF-BDD specification.
     * @param outputFilePath The path to the output file to write the transformation result to.
     * @param outputFolderPath The path to the folder in which the transformation result is to be written.
     */
    public void clean(Specification model, CifBddSpec bddSpec, Path outputFilePath, Path outputFolderPath) {
        // Sanity check: the CIF model should contain only one automaton.
        Verify.verify(model.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");

        Automaton automa = (Automaton)model.getComponents().get(0);

        // Compute initial and marked locations.
        findInitialAndMarkedLocations(automa);

        // Sanity check: initial and marked locations must not be empty.
        Verify.verify(initialLocs != null && !initialLocs.isEmpty(), "Found empty initial set.");
        Verify.verify(markedLocs != null && !markedLocs.isEmpty(), "Found empty target set.");

        // Create NodeInfo objects for all locations.
        createNodeInfos(automa.getLocations());

        // Call the minimum sub-graph algorithm.
        Set<NodeInfo> markedNodeInfo = markedLocs.stream().map(m -> locationNodeInfoMap.get(m))
                .collect(Collectors.toSet());
        computeMinSubGraph(markedNodeInfo);

        // Mark the minimum sub-graphs as essential.
        for (Location initialLoc: initialLocs) {
            markEssentialLocationAndEdges(initialLoc);
        }

        // Remove every non-essential, redundant element.
        removeRedundantElements(automa);

        // Write the essential model.
        try {
            AppEnv.registerSimple();
            CifWriter.writeCifSpec(model, outputFilePath.toString(), outputFolderPath.toString());
        } finally {
            AppEnv.unregisterApplication();
        }
    }

    private void findInitialAndMarkedLocations(Automaton automaton) {
        // Find initial locations of the automaton.
        for (Location loc: automaton.getLocations()) {
            if (CifLocationHelper.isInitial(loc)) {
                initialLocs.add(loc);
            }
        }

        // Find marked locations of the automaton.
        for (Location loc: automaton.getLocations()) {
            if (CifLocationHelper.isMarked(loc)) {
                markedLocs.add(loc);
            }
        }
    }

    private void createNodeInfos(List<Location> locations) {
        // For all locations, create a NodeInfo object, and fills its fields with empty values. Store it in a map
        // for later handling.
        for (Location loc: locations) {
            NodeInfo emptyNodeInfo = new NodeInfo(loc, new LinkedHashSet<>(), new LinkedHashSet<>(),
                    new LinkedHashMap<>(), new ArrayList<>());
            emptyNodeInfo.getMinSubGraphs().add(new LinkedHashSet<>());
            locationNodeInfoMap.put(loc, emptyNodeInfo);
        }

        for (Location loc: locations) {
            // Computes the forward and backward neighbors for every location.
            NodeInfo currentNodeInfo = locationNodeInfoMap.get(loc);

            for (Edge edge: loc.getEdges()) {
                // Update current NodeInfo fields.
                if (CifEdgeUtils.isSelfLoop(edge)) {
                    currentNodeInfo.getChildren().add(currentNodeInfo);
                    currentNodeInfo.getParents().add(currentNodeInfo);
                    currentNodeInfo.getChildrenToEdges().computeIfAbsent(currentNodeInfo, v -> new LinkedHashSet<>())
                            .add(edge);
                } else {
                    NodeInfo targetNodeInfo = locationNodeInfoMap.get(CifEdgeUtils.getTarget(edge));
                    currentNodeInfo.getChildren().add(targetNodeInfo);
                    targetNodeInfo.getParents().add(currentNodeInfo);
                    currentNodeInfo.getChildrenToEdges().computeIfAbsent(targetNodeInfo, v -> new LinkedHashSet<>())
                            .add(edge);
                }
            }
        }
    }

    /**
     * Description. TODO
     *
     * @param markedNodeInfo The set containing the NodeInfo objects corresponding to marked locations.
     */
    private void computeMinSubGraph(Set<NodeInfo> markedNodeInfo) {
        // Run a BFS-like algorithm and update the minimum sub-graph of each NodeInfo object.
        Queue<NodeInfo> queue = new LinkedList<>();
        queue.addAll(markedNodeInfo);

        while (!queue.isEmpty()) {
            // Get the first element of the queue, and analyze its neighbors.
            NodeInfo currentNodeInfo = queue.poll();

            Set<NodeInfo> children = currentNodeInfo.getChildren();
            int minChildSubGraphSize = Integer.MAX_VALUE;
            Set<NodeInfo> chosenChildren = new LinkedHashSet<>();

            // All sub-graphs have the same size: get the size of the first one (could be zero if empty set).
            int sizePreUnion = currentNodeInfo.getMinSubGraphs().get(0).size();

            // For each child, get its minimum sub-graph and compare it with the current NodeInfo sub-graph. If the edge
            // connecting the two locations is uncontrollable, perform the union of the sub-graphs, since we must
            // consider each uncontrollable edge for all locations. If the edge is controllable, compare the size of the
            // sub-graph and choose the children with the minimum sub-graph; update the current NodeInfo considering the
            // smallest sub-graph of its children.
            for (NodeInfo child: children) {
                List<Set<Object>> childMinSubGraphs = child.getMinSubGraphs();
                int childMinSubGraphSize = childMinSubGraphs.isEmpty() ? 0 : childMinSubGraphs.get(0).size();

                for (Edge childEdge: currentNodeInfo.getChildrenToEdges().get(child)) {
                    List<Event> events = new ArrayList<>(CifEventUtils.getEvents(childEdge));

                    if (!events.get(0).getControllable()) {
                        // Union of the current node sub-graphs and the child's sub-graphs.
                        for (Set<Object> currentMinSubGraph: currentNodeInfo.getMinSubGraphs()) {
                            for (Set<Object> childMinSubGraph: childMinSubGraphs) {
                                currentMinSubGraph.add(child);
                                currentMinSubGraph.add(childEdge);
                                currentMinSubGraph.addAll(childMinSubGraph);
                            }
                        }
                    } else {
                        // Choose the child with smallest sub-graph.
                        if (minChildSubGraphSize > childMinSubGraphSize) {
                            chosenChildren = new LinkedHashSet<>();
                            chosenChildren.add(child);
                        } else if (minChildSubGraphSize == childMinSubGraphSize) {
                            chosenChildren.add(child);
                        }
                    }
                }
            }

            // TODO: update description. Add sub-graph of the chosen controllable children.
            List<Set<Object>> allUpdatedMinSubGraphsList = new ArrayList<>();
            for (Set<Object> currentMinSubGraph: currentNodeInfo.getMinSubGraphs()) {
                for (NodeInfo child: chosenChildren) {
                    for (Set<Object> childMinSubGraph: child.getMinSubGraphs()) {
                        Set<Object> updatedMinSubGraph = new LinkedHashSet<>(currentMinSubGraph);
                        updatedMinSubGraph.add(child);
                        updatedMinSubGraph.addAll(currentNodeInfo.getChildrenToEdges().get(child));
                        updatedMinSubGraph.addAll(childMinSubGraph);
                        allUpdatedMinSubGraphsList.add(updatedMinSubGraph);
                    }
                }
            }

            if (!allUpdatedMinSubGraphsList.isEmpty()) {
                currentNodeInfo.setMinSubGraphs(allUpdatedMinSubGraphsList);
            }

            // If current NodeInfo sub-graph has been updated, or if the current NodeInfo corresponds to a marked
            // location, add the current NodeInfo parents to the queue.
            if (sizePreUnion == 0 || sizePreUnion != currentNodeInfo.getMinSubGraphs().get(0).size()) {
                queue.addAll(currentNodeInfo.getParents());
            }
        }
    }

    private void markEssentialLocationAndEdges(Location currentLoc) {
        essentialLocs.add(currentLoc);

        if (locationNodeInfoMap.get(currentLoc).getMinSubGraphs().isEmpty()) {
            // Add empty set for marked location.
            essentialLocsToEssentialEdges.put(currentLoc, new LinkedHashSet<>());
        }

        for (Set<Object> minSubGraph: locationNodeInfoMap.get(currentLoc).getMinSubGraphs()) {
            for (Object element: minSubGraph) {
                // If the current element is an edge, add it to the map from essential location to essential edges; if
                // it is a location, call recursively the method.
                if (element instanceof Edge edge) {
                    essentialLocsToEssentialEdges.computeIfAbsent(currentLoc, k -> new LinkedHashSet<>()).add(edge);
                } else if (element instanceof NodeInfo nodeInfo) {
                    Location nextLoc = locationNodeInfoMap.inverse().get(nodeInfo);
                    if (!essentialLocs.contains(nextLoc)) {
                        markEssentialLocationAndEdges(nextLoc);
                    }
                } else {
                    throw new RuntimeException("Found unsupported element in sub-graph.");
                }
            }
        }
    }

    private void removeRedundantElements(Automaton automa) {
        // Remove all redundant locations and redundant edges of essential locations.
        Set<Location> locsToRemove = new LinkedHashSet<>();
        for (Location loc: automa.getLocations()) {
            if (!essentialLocs.contains(loc)) {
                locsToRemove.add(loc);
            } else {
                // Remove redundant edges if location is essential.
                Set<Edge> locEssentialEdges = essentialLocsToEssentialEdges.get(loc);
                Set<Edge> edgesToRemove = new LinkedHashSet<>();
                for (Edge edge: loc.getEdges()) {
                    if (!locEssentialEdges.contains(edge)) {
                        edgesToRemove.add(edge);
                    }
                }
                loc.getEdges().removeAll(edgesToRemove);
            }
        }
        automa.getLocations().removeAll(locsToRemove);
    }
}
