\documentclass{article}

% Packages.
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[english]{babel}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{mathpar}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{cif_listing}

% Color of comments in algorithms.
\newcommand{\commfont}[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{commfont}

% Keywords in algorithms.
\SetKwFunction{synthAll}{synthesize-all}
\SetKwFunction{synthSingle}{synthesize-single}
\SetKwProg{procedure}{procedure}{}{}
\SetKw{KwEveryActivity}{every activity}
\SetKw{KwReplace}{replace}
\SetKw{KwBy}{by}
\SetKw{KwIn}{in}

% Redefine reference names for \autoref.
\addto\extrasenglish{\renewcommand{\algorithmautorefname}{Algorithm}}
\addto\extrasenglish{\renewcommand{\sectionautorefname}{Section}}
\addto\extrasenglish{\renewcommand{\subsectionautorefname}{Section}}
\addto\extrasenglish{\renewcommand{\subsubsectionautorefname}{Section}}

% Convenient auxiliary commands.
\newcommand{\keyw}[1]{\texttt{#1}}
\newcommand{\var}[1]{\ensuremath{\mathit{#1}}}

% Activity synthesis steps.
\newcommand{\getOrderedAbstrActivitiesLabel}[0]{\keyw{get-ordered-abstr-activities}}
\newcommand{\transformUmlToCifLabel}[0]{\keyw{transform-uml-to-cif}}
\newcommand{\dataBasedSynthesisLabel}[0]{\keyw{data-based-synthesis}}
\newcommand{\generateStatespaceLabel}[0]{\keyw{generate-statespace}}
\newcommand{\ensureSingleSourceAndSinkLabel}[0]{\keyw{ensure-single-source-and-sink}}
\newcommand{\eventBasedProjectionLabel}[0]{\keyw{event-based-projection}}
\newcommand{\dfaMinimizationLabel}[0]{\keyw{dfa-minimization}}
\newcommand{\petrinetSynthesisLabel}[0]{\keyw{petrinet-synthesis}}
\newcommand{\transformToActivityLabel}[0]{\keyw{transform-to-activity}}
\newcommand{\rewriteNonAtomicPatternsLabel}[0]{\keyw{rewrite-nonatomic-patterns}}
\newcommand{\computeGuardsLabel}[0]{\keyw{compute-guards}}

\newcommand{\getOrderedAbstrActivities}[1]{\getOrderedAbstrActivitiesLabel(\ensuremath{#1})}
\newcommand{\transformUmlToCif}[1]{\transformUmlToCifLabel(\ensuremath{#1})}
\newcommand{\dataBasedSynthesis}[1]{\dataBasedSynthesisLabel(\ensuremath{#1})}
\newcommand{\generateStatespace}[1]{\generateStatespaceLabel(\ensuremath{#1})}
\newcommand{\ensureSingleSourceAndSink}[1]{\ensureSingleSourceAndSinkLabel(\ensuremath{#1})}
\newcommand{\eventBasedProjection}[1]{\eventBasedProjectionLabel(\ensuremath{#1})}
\newcommand{\dfaMinimization}[1]{\dfaMinimizationLabel(\ensuremath{#1})}
\newcommand{\petrinetSynthesis}[1]{\petrinetSynthesisLabel(\ensuremath{#1})}
\newcommand{\transformToActivity}[1]{\transformToActivityLabel(\ensuremath{#1})}
\newcommand{\reduceNonAtomicPatterns}[1]{\rewriteNonAtomicPatternsLabel(\ensuremath{#1})}
\newcommand{\computeGuards}[1]{\computeGuardsLabel(\ensuremath{#1})}

\newcommand{\doneLabel}[0]{\texttt{\_\_done}}
\newcommand{\initLabel}[0]{\texttt{\_\_init}}
\newcommand{\loopLabel}[0]{\texttt{\_\_loop}}
\newcommand{\startLabel}[0]{\texttt{\_\_start}}
\newcommand{\stopLabel}[0]{\texttt{\_\_end}} % Note: the command name \endLabel cannot be used since \end seems reserved.
\newcommand{\toLabel}[0]{\texttt{\_\_to\_\_}}
\newcommand{\tauLabel}[0]{\texttt{\_\_tau}}

% New example environment
\theoremstyle{definition}
\newtheorem{example}{Example}[section]
\newtheorem*{example*}{Running Example}

\title{Synthesis of SynthML Activity Diagrams}

\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

This document describes the SynthML activity synthesis algorithm and discusses its internal steps.
This document does not explain what the code implementation of the algorithm is doing exactly in full detail.
Instead, it explains more abstractly what the different steps are conceptually, why they are needed, and what they require and ensure.
Therefore, the explanation may sometimes deviate slightly from how the code implementation is organized, and may sometimes be more abstract.
This document is intended to be a living document, to be extended continuously while further developing the synthesis algorithm.

The remainder of this document is organized as follows.
\autoref{sec:prelims} gives preliminaries for understanding the activity synthesis algorithm, in particular the formalisms and tools that are involved.
\autoref{sec:algorithm} discusses the activity synthesis algorithm.
First a high-level overview of the algorithm is given, and then its steps are discussed in more detail.

\section{Preliminaries}
\label{sec:prelims}

\subsection{Formalisms}
\label{sec:prelims:formalisms}

The activity synthesis algorithm deals with various different formalisms that each have their own terminology.
A high-level overview is presented below.

\begin{description}
	\item[Finite automata.]
	Finite automata are finite directed graphs consisting of \emph{locations}, and \emph{edges} that are labeled with an \emph{event}.
	Locations can be \emph{initial} when they are `starting' locations.
	Locations can also be \emph{marked} when they are accepting locations, with the standard meaning of acceptance from automata theory.

	A deterministic finite automaton (DFA) is a finite automaton that is deterministic.
	Any finite automaton that is nondeterministic is a nondeterministic finite automaton (NFA).

	Rather than a single DFA or NFA, we typically consider multiple automata that interact, by means of synchronizing events.
	We will not give a full introduction of all these concepts here.

	\item[Extended finite automata (EFA).]
	EFAs are finite automata that are used in the presence of \emph{data (properties)}, i.e., variables that have a value.
	The \emph{(execution) state} of an EFA typically refers to the current valuation of all data properties, plus the locations that are currently active.

	The edges of EFAs have \emph{guards} which are state predicates, as well as \emph{updates} which are state transformers.
	Semantically, an edge can be taken when its guard holds with respect to the state of the EFA at the current execution point, and this state is then updated (transformed) according to the edge update.

	\item[UML models and activities.]
	For our purposes we use a subset of the UML2 metamodel\footnote{See \url{https://www.omg.org/spec/UML/2.5.1} (Accessed 2025-08-21) for the full UML2 specification.}.
	In our restricted scope, UML models consist of any number of UML enum declarations, and exactly one UML class.
	A UML class contains:
	\begin{itemize}
		\item Any number of UML properties.
		UML properties have a type and optionally a default value.
		There are three supported types: Booleans, bounded integers, and enums.
		In addition to these three data types, \emph{composite} data types are also supported.
		Composite data types serve as structured containers for the three primitive types, allowing a user to group related properties together in a meaningful way, reflecting the logical structure of these properties.
		Default property values are then expressions of the appropriate type.
		\item Any number of UML opaque behaviors that have exactly one \emph{guard} and zero or more \emph{effects}.
		These opaque behaviors model \emph{actions} to be performed in synthesized UML activities.
		Likewise to EFAs, action guards are state predicates, and action updates are state transformers, both of which are expressed over the UML properties as defined in the UML model.
		Moreover:
		\begin{itemize}
			\item Any action is either deterministic or nondeterministic.
			An action is defined to be \emph{deterministic} if the action has at most one effect.
			An action that is not deterministic is defined to be \emph{nondeterministic}.
			The execution semantics of nondeterministic actions is that by executing the action, one of its effects is nondeterministically chosen and executed.
			\item Any action is either atomic or nonatomic.
			The atomicity of an action can be indicated in SynthML via a checkbox in the Properties view.
			If an action is indicated to be \emph{atomic}, then no other actions can be performed during the execution of the atomic action.
			If an action is indicated to be \emph{nonatomic}, then other actions may be performed in-between the start and end of the nonatomic action.
			A nonatomic action can only be started when its guard holds, and the effects of a nonatomic action are applied when the action ends.
		\end{itemize}
		\item Any number of UML constraints that model the requirements for synthesis.
		A UML constraint can be a state invariant that is expressed over the UML properties in the UML model.
		A UML constraint can also be an action exclusion invariant, which indicates that starting the execution of some action requires the system to be in a certain state as expressed by the state invariant.
		\item Any number of UML activities, which can either be \emph{abstract} or \emph{concrete}.
		\begin{itemize}
			\item Abstract UML activities are `empty' in the sense that they contain no nodes nor control flows.
			An abstract UML activity consists of preconditions, postconditions, and occurrence constraints.
			The preconditions and postconditions are state invariants that are expressed over the specified UML properties.
			Occurrence constraints are roughly of the form `$A$ must happen at least $M$ times and at most $N$ times' where $A$ can be either an opaque behavior or an activity.
			Occurrence constraints thus limit the number of times some opaque behavior can be started, or the number of times some activity can be called, in a to-be-synthesized activity.
			Note that occurrence constraints are temporary constructs and are intended to be removed later, which is future work.
			\item A concrete UML activity is a finite directed graph consisting of \emph{nodes} and \emph{control flows}\footnote{The UML2 metamodel uses \textsf{ActivityNode} and \textsf{ActivityEdge}, but here it may be better to talk about control flows rather than edges due to the possible ambiguity with automata edges.}.
			A node can be a:
			\begin{itemize}
				\item \emph{Control node}, i.e., an initial node, final node, fork node, join node, decision node, or merge node.
				\item \emph{Opaque action node}, which is essentially an `inlined' action consisting of a guard and zero or more effects.
				So likewise to opaque behaviors, also opaque action nodes are either deterministic or nondeterministic, and either atomic or nonatomic.
				\item \emph{Call behavior action node}, which either executes an action by calling an opaque behavior, or calls an activity. 
				Only when the called behavior is an activity, the call behavior action node may have a guard and effects. 
				In such cases, the activity execution is bypassed, and the node behaves like an opaque action node: its guard and effects determine the node execution. 
				This is referred to as a \emph{shadowed} call behavior action node. 
				If the no guard and effects are defined, the called activity is executed.
			\end{itemize}
			Control flows support incoming and outgoing guards, which are conditions that restrict the token-based execution of an activity. 
			An incoming guard specifies when a token can be placed on that control flow, whereas an outgoing guard specifies a condition for the removal of the token from the control flow. 
			Both guards are state predicates over the properties in the UML model, similarly to opaque action guards.
			Likewise to abstract activities, also concrete activities may contain preconditions, postconditions, and occurrence constraints.
			In the case of abstract activities, these constraints are used as input for synthesizing a concrete activity that adheres to these constraints.
			If an abstract activity is allowed to call a concrete activity by its occurrence constraints, then the preconditions and postconditions of that concrete activity are used by the synthesis algorithm to determine when the concrete activity can be called by the to-be-synthesized activity, and once called, when the concrete activity has finished its execution.
			(Moreover, in principle it would also be possible to later use the preconditions and postconditions of concrete activities for verification, e.g., property checking.)
		\end{itemize}
	\end{itemize}

	The activity synthesis algorithm takes UML models as input, containing any number of (concrete and abstract) UML activities.
	The goal of activity synthesis is then to synthesize a concrete UML activity for every abstract UML activity, and update the UML model by replacing all abstract UML activities by the concrete synthesized ones.

	We will only consider UML models that are \emph{valid} with respect to the SynthML validator.
	For example, UML models should not contain abstract UML activities that have nodes or control flows, and should not use double underscores `\_\_' in any names of UML elements.

	\item[Petri nets.]
	A Petri net is a finite directed graph consisting of \emph{places}, \emph{transitions}, and \emph{arcs}.
	We consider \emph{elementary Petri nets}, where (by definition) any place holds at most one \emph{token}.
	Transitions in a Petri net can be \emph{fired} to move tokens around between adjacent places.
	If some transition can fire, we say that it is \emph{enabled}.
	Any arc in a Petri net must be connected to one place and one transition.
	That is, there cannot be an arc from a place to some other place, or from a transition to some other transition.
	Further details on Petri nets and their semantics can be found in standard literature.

	The activity synthesis algorithm uses a particular category of Petri nets where possible, namely \emph{free-choice Petri nets}.
	This is because we have observed that free-choice Petri nets can be translated to concrete UML activities that are more intuitive for users to understand than general Petri nets.
	Intuitively, free-choice means that all choices (i.e., places with multiple outgoing arcs) can be made without additional constraints (i.e., the target transitions of these outgoing arcs do not have additional token requirements).
	Free-choice Petri nets thus have simpler choice patterns compared to general Petri nets, which may translate to more intuitive UML activities.
\end{description}

\subsection{Standard and tooling}
\label{sec:prelims:standards}

The activity synthesis algorithm deals with various different standards and tools.
A brief overview is given below.

\begin{description}
	\item[CIF.]
	CIF is a specification language for discrete event systems, among other systems, as well as a toolset that supports the development process of supervisory controllers.
	CIF is part of the Eclipse ESCET toolkit, see \url{https://eclipse.dev/escet} (accessed 2025-08-21) for further details.
	We use the CIF data-based synthesis tool to do supervisory controller synthesis, and the CIF explorer tool for state space generation.
	\item[Petrify.]
	Petrify is a tool for Petri net synthesis.
	Given some state machine (or finite automaton), the goal of Petri net synthesis is to synthesize a (minimal) Petri net that is trace-equivalent to the input state machine.
	Petrify has its own input and output specification language.
	We use Petrify to synthesize a Petri net from a state machine, as a stepping stone for synthesizing UML activities.
	This is because Petri nets can more compactly represent concurrency, by forking/joining from a Petri net transition.
	In contrast, in state machines, concurrency is represented by explicit interleaving, i.e., as diamond patterns.
	Petri net synthesis can automatically turn such diamond patterns in the input state machine to more compact fork/join patterns in the resulting Petri net.
	Further information on Petrify can be found here: \url{https://www.cs.upc.edu/~jordicf/petrify} (accessed 2025-08-21).
	\item[PNML.]
	PNML stands for Petri net Markup Language, and is an XML-based syntax for representing Petri nets.
	We use the PNML metamodel to represent Petri nets internally in the code implementation.
	Further information can be found here: \url{https://pnml.lip6.fr} (accessed 2025-08-21).
	\item[UML.]
	We use the UML2 metamodel to represent UML models and UML activities in the code implementation.
	Further information can be found here: \url{https://wiki.eclipse.org/MDT-UML2} (accessed 2025-08-21).
\end{description}

\subsection{Algorithms for synthesis}
\label{sec:prelims:synthesis}

The activity synthesis procedure internally uses two types of synthesis algorithms, namely supervisory controller synthesis (currently using CIF), and Petri net synthesis (currently using Petrify).

Supervisory controller synthesis is used to compute a minimally restrictive supervisor, which is essentially a state machine that describes all safe system behavior.
After that, Petri net synthesis is used to synthesize a (free-choice, if possible) Petri net from this state machine, which is then transformed to a concrete UML activity.
The intermediate step of synthesizing a Petri net is performed since Petri nets are structurally much closer to UML activities than state machines, and thus easier to translate.

The field of Petri net synthesis is developed around the \emph{theory of regions}.
Intuitively, the idea is to find groups of locations in the input state machine that can be turned into single places in the output Petri net.
These groups are then called regions.
Depending on the type of Petri net you aim to synthesize (e.g., elementary or free-choice ones), there are slightly different requirements for what exactly constitutes a region.
Petrify is essentially an implementation of the theory of regions, and is able to synthesize both general and free-choice Petri nets, among other kinds.

We will not explain supervisory controller synthesis and Petri net synthesis in this document.
More information on these types of syntheses can be found on the webpages of Eclipse ESCET and Petrify linked above.

\section{Activity Synthesis}
\label{sec:algorithm}

\autoref{alg:activity-synthesis} shows the high-level activity synthesis algorithm.
The entry point is \synthAll, which iterates over all abstract UML activities in the given input UML model, synthesizes a concrete UML activity for them, and replaces the abstract activity by the concrete synthesized one.
The operation \getOrderedAbstrActivitiesLabel{} gives the list of all abstract activities in the input UML model, in the order in which they are to be synthesized.
Such an ordering is needed to enable synthesizing activities that can call other activities, i.e., to support synthesis of hierarchical specifications.
If some activity depends on some other activity with respect to the hierarchy, we should synthesize the other activity first.
An abstract activity depends on all abstract and concrete activities in scope, unless expressed otherwise via occurrence constraints.
In particular, if there is an occurrence constraint expressing that some activity may not be called (i.e., called at most zero times), then the abstract activity will not depend on that activity.
In case any cycles are detected in these dependencies, then the synthesis algorithm will terminate and an error will be reported.

\begin{algorithm}[t!]
	\tcp{Synthesizes a concrete activity for every abstract one in the model.}
	\procedure{\synthAll{\var{umlModel}}}{
		\var{umlActivities_{abstr}} := \getOrderedAbstrActivities{\var{umlModel}}\;
		\For{\KwEveryActivity \var{umlActivity_{abstr}} \KwIn \var{umlActivities_{abstr}}}{
			\var{umlActivity_{concr}} := \synthSingle{\var{umlActivity_{abstr}}}\;
			\KwReplace \var{umlActivity_{abstr}} \KwBy \var{umlActivity_{concr}} \KwIn \var{umlModel}\;
		}
	}

	\BlankLine
	\BlankLine

	\tcp{Synthesizes a concrete activity for the given abstract activity.}
	\procedure{\synthSingle{\var{umlActivity_{abstr}}}}{
		\tcp{Synthesize a CIF supervisor using CIF data-based synthesis.}
		\var{cifSpec} := \transformUmlToCif{\var{umlActivity_{abstr}}}\;
		\var{cifSupervisor} := \dataBasedSynthesis{\var{cifSpec}}\;
		\tcp{Generate the CIF state space as a minimal DFA.}
		\var{cifStatespace} := \generateStatespace{\var{cifSupervisor}}\;
		\var{cifStatespace} := \ensureSingleSourceAndSink{\var{cifStatespace}}\;
		\var{cifStatespace_{proj}} := \eventBasedProjection{\var{cifStatespace}}\;
		\var{cifStatespace_{min}} := \dfaMinimization{\var{cifStatespace_{proj}}}\;
		\tcp{Synthesize a minimal Petri net.}
		\var{petriNet} := \petrinetSynthesis{\var{cifStatespace_{min}}}\;
		\var{petriNet_{red}} := \reduceNonAtomicPatterns{\var{petriNet}}\;
		\tcp{Transform the Petri net to an activity without control flow guards.}
		\var{umlActivity_{concr}} := \transformToActivity{\var{petriNet_{red}}}\;
		\tcp{Compute the control flow guards for the synthesized activity.}
		\var{umlActivity_{guards}} := \computeGuards{\var{umlActivity_{concr}}}\;
		\Return \var{umlActivity_{guards}}\;
	}

	\caption{Synthesis of SynthML activity diagrams}
	\label{alg:activity-synthesis}
\end{algorithm}

The algorithm for synthesizing a single UML activity, \synthSingle, is a sequence of operations performed on the input UML abstract activity.
The remainder of this section explains all operations in \synthSingle.
A short explanation is given for every operation, followed by the motivation for having that operation, followed by its preconditions and postconditions.

\begin{example*}
Let us consider a simple UML model, named \texttt{BitFlipper}, where we aim at synthesizing an activity that flips a single nondeterministically initialized Boolean value.
The UML model is composed of a single class \texttt{ActiveClass}, which contains two properties: a Boolean named \texttt{init}, initialized as \texttt{false}, denoting whether the system is initialized, and a Boolean named \texttt{bit}, not initialized.
The class also contains an abstract activity called \texttt{ActivityMain}, and two atomic opaque behaviors named \texttt{flip} and \texttt{initialize}.
The activity has precondition \texttt{not init}, and postcondition \texttt{bit and init}.
The \texttt{flip} opaque behavior's effect is to flip the Boolean \texttt{bit} after it is initialized: its guard is \texttt{init}, whilst its effects consist of a single assignment \texttt{bit := not bit}.
The opaque behavior \texttt{initialize} turns \texttt{init} from \texttt{false} to \texttt{true}, and sets \texttt{bit} either to \texttt{true} or \texttt{false} in a nondeterministic fashion.
The model outline in the SynthML environment is depicted in \autoref{fig:bitflipper-uml-designer}.
\end{example*}

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.75\linewidth]{images/bitflipper_uml.png}
    \caption{The \texttt{BitFlipper} model visualized within the SynthML environment.}
    \label{fig:bitflipper-uml-designer}
\end{figure}

\subsection{Transforming the abstract UML activity to CIF}
\label{sec:transform-uml-to-cif}

The \transformUmlToCif{\var{umlActivity_{abstr}}} operation translates a given abstract UML activity, \var{umlActivity_{abstr}}, together with all relevant context from the UML model (e.g., UML class properties, constraints, opaque behaviors, concrete activities that may be called, etc.) to a CIF specification to be used for supervisory controller synthesis.

\paragraph{Motivation.}
With respect to supervisory controller synthesis, the UML model of the abstract input activity \var{umlActivity_{abstr}} specifies the plant and requirements, i.e., the UML opaque behaviors, concrete UML activities, and UML constraints.
Moreover, the abstract activity itself contains the name of the to-be-synthesized activity as well as its preconditions, postconditions, and occurrence constraints.

\paragraph{Approach.}
These plant and requirement constructs are translated one-to-one to CIF, to enable running the CIF data-based synthesis tool.
In case the to-be-synthesized abstract activity may be able to call other concrete activities, then all nodes and control flows of these concrete activities are translated as well.
These concrete activities are then considered part of the plant specification for data-based synthesis.

\paragraph{Preconditions.}
This operation requires the UML model of the abstract input activity to be valid.
Moreover, every occurrence constraint of \var{umlActivity_{abstr}} must be expressed over opaque behaviors and/or activities in that UML model.
If the to-be-synthesized activity is able to call other activities by its occurrence constraints, then all these activities must be concrete and must not call other activities (i.e., they must be flattened).

\paragraph{Postconditions.}
This operation produces a CIF specification that:
\begin{itemize}
	\item For every UML enum declaration in the UML model, contains a corresponding CIF enum declaration.
	\item Contains a CIF plant for the single UML class.
	This plant is a flower automaton, containing one location that is initial and marked, and only self-loops.
	\item Contains a discrete variable for every UML class property.
	Composite data types are flattened, meaning that their internal structure is broken down so that all nested properties are extracted and translated into a discrete variable as stand-alone properties.
	If a UML class property has a default value, then this value is translated as the default value of the CIF variable.
	If not, then the corresponding CIF variable is specified to have any value initially, with the `in any' CIF construct.
	\item Contains CIF event declarations corresponding to all defined UML opaque behaviors.
	All opaque behaviors that model actions that are both atomic and deterministic are translated as single controllable events.
	All other opaque behaviors, that model nonatomic and/or nondeterministic actions, are translated to multiple CIF events, namely a controllable one for starting the action, and uncontrollable ones for each of their effects to end the action.
	In that case, at least one uncontrollable end event will be created, even if the opaque behavior has no user-defined effects.
	Such separate uncontrollable `end' events must be defined since:
	\begin{itemize}
		\item In case of a nonatomic action, we must allow other actions to be performed while executing the nonatomic action.
		Thus, we create separate start and end events, to allow other CIF events to be performed in between.
		Moreover, the end events are defined to be uncontrollable so that data-based synthesis cannot influence when a nonatomic action ends.
		An example of a nonatomic action could be a robot movement.
		A synthesized controller cannot influence when such a robot movement finishes.
		\item In case of a nondeterministic action, separate `end' events are needed since data-based synthesis in CIF requires controllable events to be deterministic.
		So, for data-based synthesis, we need a controllable event to (controllably) start some nondeterministic action, and uncontrollable events to nondeterministically perform one of its effects.
	\end{itemize}
	Moreover, in case the UML model contains nonatomic and/or atomic nondeterministic actions, extra internal CIF variables are created to ensure that the actions are properly executed:
	\begin{itemize}
		\item For every nonatomic action in the UML model, an \emph{active variable} is declared and maintained in the CIF specification.
		The active variable of a nonatomic action is a Boolean that indicates whether the action is currently being executed (\texttt{true}) or not (\texttt{false}).
		The start event of a nonatomic action can only be performed when the active variable of that action is \texttt{false}, and performing it will set the active variable to \texttt{true}.
		Any end event of a nonatomic action can only be performed when the active variable of the action is \texttt{true}, and performing it will set the active variable to \texttt{false}.
		\item In case the UML model contains atomic nondeterministic actions, a single \emph{atomicity variable} is declared and maintained in the CIF specification, to ensure that no event may occur between the start and end event of the atomic nondeterministic action.
		This atomicity variable is defined to be an integer between $0$ and $n$, with $n$ the total number of atomic nondeterministic actions.
		If the atomicity variable is $0$, then no atomic nondeterministic action is being executed.
		The start event of any atomic nondeterministic action will set the atomicity variable to be the index of that action.
		If the atomicity variable is greater than $0$, then only an end event of the corresponding (indexed) action can be performed, and performing such an end event will reset the atomicity variable to $0$.
		We add necessary guards to all created CIF edges to ensure that indeed no other CIF event can be performed when the atomicity variable is not $0$.
	\end{itemize}
	\item For every concrete UML activity that can be called by the to-be-synthesized activity:
	\begin{itemize}
		\item The translated CIF specification contains a Boolean-typed CIF discrete variable for every control flow of the concrete UML activity.
		This variable then indicates whether the corresponding control flow contains a token (\texttt{true}) or not (\texttt{false}).
		\item The translated CIF specification contains CIF event declarations corresponding to all nodes of the concrete UML activity.
		We translate concrete activity nodes in the same way as we translate actions (i.e., opaque behaviors), as explained above.
		Control nodes (i.e., fork, join, decision, merge, initial, and final nodes) are always translated as atomic deterministic actions since their execution should be instant.
		Action nodes (i.e., opaque actions, call behavior nodes that call an opaque behavior, and shadowed call behavior nodes that call an activity) are translated likewise to opaque behaviors: as actions with user-specified guards and effects, that can be atomic or nonatomic, and deterministic or nondeterministic.
		During this translation, we define extra guards and effects to ensure proper token handling: an activity node can only be executed (as an action) if its incoming control flows have the required tokens for that, and after executing the node, the outgoing control flows receive the proper tokens.
		In case an outgoing control flow has a guard, then this guard is translated as an extra condition for putting a token on that control flow, i.e., for making the corresponding CIF variable \texttt{true}.

		Unlike the translation of opaque behaviors, every CIF event that is created for an activity node is uncontrollable, with the exception of initial nodes.
		This is because calling an activity intuitively amounts to `executing its initial node', and this is a controllable event (that is, the synthesis algorithm has control over when some concrete activity is being called).
		However, once a concrete activity has been called, its execution proceeds uncontrollably, which is why all other CIF events are made uncontrollable.

		A concrete activity can only be called in a state where its precondition is satisfied.
		Hence, we translate their preconditions as extra guards for executing the initial nodes.
		Likewise, we translate their postconditions as extra guards for executing the final nodes.
	\end{itemize}
	
	\item Contains Boolean-typed algebraic variables for every translated precondition of the abstract activity.
	Activities may have multiple preconditions.
	Each of these preconditions are translated as algebraic variables in CIF, for better traceability.
	The conjunction of all these algebraic variables then forms the overall activity precondition, for which an algebraic variable is created as well, named \texttt{\_\_precondition}.
	\item Contains Boolean-typed algebraic variables for every translated postcondition of the abstract activity.
	Activities may have multiple postconditions.
	Each of these postconditions are translated as algebraic variables in CIF, for better traceability.
	Apart from these, extra postconditions are generated as Boolean-typed algebraic variables in the following situations:
	\begin{itemize}
		\item In case any internal active variables or atomicity variable were declared as described earlier, extra postconditions are generated which express that no nonatomic and/or nondeterministic actions can be active.
		\item In case the abstract activity has occurrence constraints, extra postconditions are generated which express that occurrence constraints must be satisfied, i.e., the opaque behaviors and activities that are subject to occurrence constraints must have happened the specified number of times.
		\item In case concrete activities were translated, extra postconditions are generated expressing that none of their control flows must have a token.
	\end{itemize}
	The conjunction of all these algebraic variables then forms the overall activity postcondition, for which an algebraic variable is created as well, named \texttt{\_\_postcondition}.
	\item Contains an `initial' predicate which is defined as \texttt{\_\_precondition}, i.e., the conjunction of all translated preconditions of the abstract activity.
	This predicate then limits the number of initial states to only the ones satisfying the overall activity precondition.
	\item Contains a `marked' predicate which is defined as \texttt{\_\_postcondition}, i.e., the conjunction of all translated (user-defined and extra) postconditions of the abstract activity.
	This predicate then limits the number of marked states to only the ones satisfying the overall activity postcondition.
	\item Contains a requirement invariant for every created CIF event, which disables the CIF event in every state in which \texttt{\_\_postcondition} is satisfied.
	In other words, if you would reach a system state where the overall activity postcondition holds, then no further actions would have to be taken as they will not contribute to coming closer to a postcondition state.
	These requirements can be seen as an optimization for synthesis and later state space generation, to avoid considering unnecessary steps.
	And they ensure that the synthesized UML activity will have no further actions after having reached a final node.
	\item Contains an edge in the flower automaton plant for every defined CIF event declaration.
	An edge is defined for every declared CIF event, both controllable and uncontrollable ones.
	Every CIF event, and thereby also every CIF edge, corresponds to a translated action, i.e., a UML opaque behavior or a UML activity node.
	The action guards are then translated to guards that are put on the edges of the corresponding `start' events of the action, and action effects are translated to edge updates for the `end' events (thereby taking into account that the `start' events of atomic deterministic actions also `end' the action).
	Thus, we do not put user-written action guards on any edges corresponding to `end' events, since we don't want conditions on any `end' events, and by making them uncontrollable, any synthesized constraints are pushed back to the controllable events.
	However, we do put extra guards and effects on the events to correctly handle and maintain the atomicity variable and the active variables.

	\item Contains requirement automata for the occurrence constraints defined for the abstract activity.
	Occurrence constraints are roughly of the form `$A$ must happen at least $M$ times and at most $N$ times' where $A$ refers either to an opaque behavior or an activity.
	Such constraints are translated as requirement automata, containing a discrete variable that maintains how often the action has already occurred, or how often the activity has already been called, respectively.
	In case $A$ is an opaque behavior, this variable is incremented every time that behavior is called.
	In case $A$ is an activity, this variable is incremented every time the initial node of the activity has been executed.
	The occurrence constraint can then be expressed in this requirement automaton (using edge guards and marked predicates).
\end{itemize}

\begin{example*}
The translation of the UML \texttt{BitFlipper} model to CIF is shown in \autoref{lst:bitflipper-cif}.
In the CIF model, first the events are defined, either controllable (denoting the start of an action) or uncontrollable (usually describing a nondeterministic or external event).
The \texttt{BitFlipper} CIF model provides two controllable events, \texttt{flip} and \texttt{initialize} that relate to starting the opaque behaviors defined in the UML model.
Two uncontrollable events denote the two nondeterministic results of the \texttt{bit} initialization.
The Boolean property \texttt{bit} is transformed into a discrete Boolean (\texttt{disc bool}) variable, which is nondeterministically initialized (denoted \texttt{in any}), whereas \texttt{init} is initialized as \texttt{false}.
The activity precondition and postcondition are translated into algebraic Boolean variables.
Then we define the initial state predicate to be the algebraic \texttt{\_\_precondition} variable, to indicate the initial states for performing synthesis.
Moreover, we define the marked state predicate to be the algebraic \texttt{\_\_postcondition} variable, to indicate that a postcondition state must always be reachable in the controlled system.
The auxiliary variable \texttt{\_\_activeAction} is used to connect the start and end events of atomic nondeterministic actions, in this case \texttt{initialize}.
The atomic deterministic opaque behavior \texttt{flip} is translated into an edge with guards \texttt{init} and \texttt{\_\_activeAction = 0}, and a single update \texttt{bit := not bit}.
The atomic nondeterministic opaque behavior \texttt{initialize} is translated into three edges.
First, an edge \texttt{initialize} is defined, with guard \texttt{not init and \_\_activeAction = 0}, whose effect is \texttt{\_\_activeAction := 1} (representing the atomic nondeterministic action starting).
Next, two edges denote the two possible results of the nondeterministic action: \texttt{initialize\_\_result\_1} and \texttt{initialize\_\_result\_2} assign \texttt{true} and \texttt{false} to \texttt{bit}, respectively.
At the same time, both edges assign \texttt{true} to \texttt{init} and \texttt{0} to \texttt{\_\_activeAction}, representing respectively the initialization of the system, and the end of the atomic nondeterministic action.
Finally, four requirement invariants state that the overall postcondition disables all CIF events.
In practice, these four requirements ensure that once the system reaches a state where the postcondition holds, no additional actions can be taken.
\end{example*}

\ciffile{images/bitflipper_cif.cif}{CIF translation of the \texttt{BitFlipper} UML model.}{lst:bitflipper-cif}

\subsection{Data-based synthesis with CIF}
\label{sec:data-based-synthesis}

The operation \dataBasedSynthesis{\var{cifSpec}} executes the CIF data-based synthesis tool.
Data-based synthesis is thereby configured to do forward reachability (\texttt{--forward-reach=true}), and to start with forward reachability in the fixed-point order (\texttt{--fixed-point-order=reach-nonblock-ctrl}).
Enabling forward reachability may lead to more readable results, in particular UML control flow guards.
We start the fixed-point order with a forward reachability search, since in earlier activity synthesis examples, we experienced that this is computationally cheaper than starting with a backward reachability search.
To see why, consider a to-be-synthesized abstract activity that is able to call various concrete activities.
In that case, a backward reachability search may consider many behaviors that can never actually occur, like (combinations of) intermediate execution states of concrete activities that might hypothetically be executing.
A forward reachability search may find out early that many of these behaviors can never occur, for example since concrete activities can only be called in certain situations---when their preconditions hold.
We have seen concrete synthesis examples where this helps significantly.
However, by now we have also seen cases where activity synthesis is significantly faster when starting with a backward search.
We still need to properly investigate the best reachability strategy, which is probably dependent on the input specification.

\paragraph{Motivation.}
Our goal of performing data-based synthesis is to compute all extra restrictions on the execution of actions and the calls to activities that must be considered by the to-be-synthesized activity to never violate specified requirements.

\paragraph{Approach.}
Data-based synthesis computes a minimally restrictive supervisor for going from a state that satisfies the activity preconditions, to a state that satisfies the postconditions, without violating requirements, running into blocking situations, etc.
We will later make the behavior of this supervisor explicit (\autoref{sec:state-space-generation}), to be able to synthesize a compact Petri net for it (\autoref{sec:petrinet-synthesis}) that is then transformed to a concrete activity (\autoref{sec:transform-petrinet-to-activity}).
After this transformation, we need to separately compute the incoming and outgoing guards of the control flows (\autoref{sec:compute-control-flow-guards}).

\paragraph{Preconditions.}
All preconditions of the CIF data-based synthesis tool apply.

\paragraph{Postconditions.}
All guarantees of the CIF data-based synthesis tool apply.

\subsection{State space generation}
\label{sec:state-space-generation}

The operation \generateStatespace{\var{cifSupervisor}} executes the CIF explorer tool, which unfolds the state space of the given CIF specification, \var{cifSupervisor}.

\paragraph{Motivation.}
We need to explicitly unfold the (safe) state space of the synthesized supervisor \var{cifSupervisor} to be able to construct input for Petri net synthesis, in order to later synthesize a concrete UML activity.
With `explicitly unfold' we mean that all data (e.g., discrete variables) is eliminated, leading to a state space that is a DFA/NFA.
The reason is that Petrify does not have symbolic Petri net synthesis algorithms, i.e., it cannot handle data.
Therefore, as input Petrify requires a DFA or NFA (i.e., a traditional supervisor in the form of a single DFA/NFA), rather than an EFA.
Petrify does not support variables.

\paragraph{Approach.}
The state space that is generated by $\generateStatespaceLabel$ from the synthesized supervisor expresses all possible orderings of events, taking into account the extra synthesized guards and the original action guards as specified in the original input UML model.
The goal of Petri net synthesis is then to find a compact Petri net representation of all these possible orderings, whose structure can then be translated to a concrete UML activity.

As a side remark; state space generation could later become a performance bottleneck, e.g., in case there are many initial states or large diamond patterns.
If this problem materializes, we could consider symbolic state space generation instead of explicit state space generation, and possibly adapting the Petri net synthesis algorithms to directly use these symbolic specifications.

\paragraph{Preconditions.}
All preconditions of the CIF explorer tool apply.

\paragraph{Postconditions.}
All guarantees of the CIF explorer tool apply.
The CIF explorer produces a CIF specification that contains exactly one automaton---the CIF state space.
Due to the way our UML/CIF input for synthesis is constructed (as result of \autoref{sec:transform-uml-to-cif}), the resulting state space has the following properties:
\begin{itemize}
	\item All initial locations in the state space correspond to states that satisfy the precondition of the to-be-synthesized activity.
	\item All marked locations in the state space correspond to states that satisfy the postcondition of the to-be-synthesized activity.
	This includes all implicit postconditions: no nonatomic and/or nondeterministic actions are active in those states, no translated UML control flows have a token, and every occurrence constraint is satisfied.
	\item Marked locations do not have outgoing edges.
	This is because it does not make sense to perform further actions after the activity postcondition has been satisfied.
	\item The state space is non-blocking.
	That is, any path from any location in the state space will either end up in a marked location (if it's not a marked location itself), or will loop.
	In other words, the only locations from which no further edges can be taken are the marked locations.
	\item Unless the supervisor was empty (in which case the activity synthesis chain will have terminated already before having generated the state space), there is at least one initial location and at least one marked location.
	\item Any edge with an atomic nondeterministic start event will end up in a location where only the uncontrollable end events of that nondeterministic action are possible.
	This property is a consequence of the execution semantics of atomic actions.
	If an atomic nondeterministic action is being executed in some location in the CIF state space, then by the atomicity constraint that we generated earlier, the only thing that could happen is an uncontrollable event to finish the atomic action.
\end{itemize}

\subsection{Ensuring a single source and sink location}
\label{sec:single-source-and-sink}

The operation \ensureSingleSourceAndSink{\var{cifStatespace}} transforms the single automaton in the given CIF specification, \var{cifStatespace}, to ensure it has exactly one initial (source) location and exactly one marked (sink) location.

\paragraph{Motivation.}
Having exactly one initial location is required for event-based projection and DFA minimization, described in \autoref{sec:event-based-projection} and \autoref{sec:dfa-minimization}, respectively.

Moreover, having exactly one initial location makes it easier to synthesize activities that must handle multiple initial states.
To elaborate on that: we would like to synthesize activities that have exactly one initial node and exactly one final node in order to keep the activities themselves, as well as their execution semantics, understandable.
However, it may happen that \var{cifStatespace} has multiple initial locations, for example when the activity precondition allows having more than one initial state.
In such cases, we want the synthesized activity to have one initial node, and from there have a decision node that has outgoing edges for the multiple things that can happen.
Thus, the single CIF initial location that is guaranteed by \ensureSingleSourceAndSinkLabel{} will then directly correspond to the single initial node in the to-be-synthesized activity.

The situation is likewise for marked locations.
The single CIF marked location that is guaranteed by \ensureSingleSourceAndSinkLabel{} will directly correspond to the single final node in the to-be-synthesized activity.
In case the to-be-synthesized activity has multiple different ways to satisfy the activity postcondition, then this single final node will be preceded by a merge node at which these different ways are merged.
So \ensureSingleSourceAndSinkLabel{} ensures that the CIF specification already has the right structure with respect to that.

\paragraph{Preconditions.}
The input CIF specification is required to:
\begin{itemize}
	\item Not contain any (non-trivial) CIF initialization predicates nor any CIF marker predicates in components.
	(This is ensured if \var{cifStatespace} is generated by the CIF explorer.)
	\item Contain exactly one automaton with an explicit alphabet.
	(Which is already guaranteed by the CIF explorer.)
	\item Not contain declarations/identifiers with the names \initLabel{}, \doneLabel{}, \startLabel{}, or \stopLabel{}.
	These will be the names of the new initial (source) location, the new marked (sink) location, and the auxiliary events that connect these locations to the original initial/marked locations.
\end{itemize}

\paragraph{Postconditions.}
This operation guarantees that:
\begin{itemize}
	\item The resulting CIF specification has two new declared controllable events, \startLabel{} and \stopLabel{}, which have been added to the automaton alphabet.
	\item The resulting CIF specification has a single new initial location named \initLabel{}, even when it already had a single initial location.
	Auxiliary edges with event \startLabel{} have been added that go from \initLabel{} to all original initial locations.
	The new single initial location has all state annotations of every original initial location.
	The original initial locations are now no longer initial.
	\item The resulting CIF specification has a single new marked location named \doneLabel{}, even when it already had a single marked location.
	Auxiliary edges with event \stopLabel{} have been added that go from all original marked locations to \doneLabel{}.
	The new single marked location has all state annotations of every original marked location.
	The original marked locations are no longer marked.
	\item Apart from initial/marked locations, the CIF specification is unchanged.
\end{itemize}

\subsection{Event-based projection}
\label{sec:event-based-projection}

The operation \eventBasedProjection{\var{cifStatespace}} projects the single automaton in the given CIF specification for all controllable events and all uncontrollable end events of nonatomic actions.
This means that all uncontrollable end events of atomic nondeterministic actions are projected away, i.e., \var{cifStatespace} is transformed to a DFA without keeping any uncontrollable events related to atomic nondeterministic actions.

\paragraph{Motivation.}
Recall that uncontrollable CIF events were created for atomic nondeterministic actions (in \autoref{sec:transform-uml-to-cif}), to model the nondeterministic yet atomic execution of their effects.
However, these uncontrollable events and their corresponding edges are an internal, intermediate step that should not be visible in the synthesized UML activity.
So at some point, these uncontrollable events have to be eliminated.
This elimination should be done before Petri net synthesis due to the atomicity constraint.
To clarify this further, recall that the goal of Petri net synthesis is to find a minimal Petri net whose behavior is trace-equivalent to the CIF state space that was given as input to Petri net synthesis.
While doing so, Petri net synthesis aims to reduce diamond patterns in the state space to fork/join constructs in Petri nets as much as possible.
However, due to the atomicity constraint, the uncontrollable events of atomic nondeterministic actions do not give perfect diamond patterns, since whenever some atomic nondeterministic action is being executed, the atomicity constraint enforces that no other action can be performed, thus impacting interleaving.
Therefore, we perform event-based projection on the CIF state space, to restore the diamond patterns that got disrupted by the atomicity constraint, before performing Petri net synthesis.
We do not eliminate the uncontrollable end events of nonatomic actions since no atomicity constraints are imposed on such actions, i.e., their diamond patterns are still intact.

Note that Petrify, which is the tool we use for Petri net synthesis, also has a built-in option \texttt{--hide} to hide a list of given events.
We used this option in earlier versions of our SynthML implementation instead of doing event-based projection on the level of CIF.
However, Petrify's hiding option seems broken, in the sense that we observed that Petrify does not always hide all events in the specified list.
This further motivates doing hiding/projection on the level of CIF instead.

\paragraph{Preconditions.}
Since \eventBasedProjectionLabel{} uses the automaton projection tool that comes with CIF\footnote{See \url{https://eclipse.dev/escet/cif/tools/eventbased/projection.html} (accessed 2025-09-24).}, all preconditions from that tool apply.
Notably, the input should be a valid CIF specification, e.g., it does not accept automata where some locations have state annotations and some do not.
The input CIF specification must contain a single automaton, which in our case is the CIF state space, which in turn must have exactly one initial location.

\paragraph{Postconditions.}
All guarantees of the automaton projection tool from CIF apply.
Notably, event-based projection guarantees that the resulting automaton after projection is a DFA that contains only the projected events, and that is trace-equivalent to the input specification with respect to these events.
In our case, this means that the resulting CIF specification no longer contains the uncontrollable end events of atomic nondeterministic actions, and is trace-equivalent to the input modulo these events.
The resulting DFA is not guaranteed to be minimal.
We will minimize it in the next step.

\subsection{DFA minimization}
\label{sec:dfa-minimization}

The \dfaMinimization{\var{cifStatespace_{proj}}} operation minimizes the single deterministic automaton in the given CIF specification, \var{cifStatespace_{proj}}.

\paragraph{Motivation.}
We use DFA minimization to minimize the input for Petri net synthesis.
Minimizing the DFA is not strictly required to be able to apply Petrify, but might help the Petri net synthesis algorithm so that it does not have to reason about nondistinguishable DFA states.
Note that Petrify also has a built-in option \texttt{--mints} to minimize the input graph modulo trace equivalence, as a pre-processing step.
From the documentation of Petrify\footnote{Which is included in the distribution that can be downloaded from the Petrify webpage.} this option seems to have some interaction with the \texttt{--hide} option.
However, as explained in \autoref{sec:event-based-projection}, \texttt{--hide} does not seem to always work.
Therefore, in addition to event-based projection, we also do the DFA minimization on the level of CIF.

\paragraph{Preconditions.}
Since \dfaMinimizationLabel{} uses the event-based DFA minimization tool that comes with CIF\footnote{See \url{https://eclipse.dev/escet/cif/tools/eventbased/dfa-minimize.html} (accessed 2025-09-24).}, all preconditions from that tool apply.

Notably, the input should be a CIF specification containing exactly one deterministic automaton with exactly one initial location.
In our case this is the projected CIF state space.
Note that the previous event-based projection step ensures that the input we give to \dfaMinimizationLabel{} is indeed deterministic and has exactly one initial location, thus allowing DFA minimization.

\paragraph{Postconditions.}
All guarantees of the DFA minimization tool from CIF apply.
Notably, the result is a CIF specification containing a single minimal DFA that is trace-equivalent to the DFA in the input CIF specification.

The resulting automaton is a DFA with exactly one initial location.
Moreover, this operation preserves the property from \autoref{sec:single-source-and-sink} that there is exactly one marked (sink) location.
To see why, suppose that event-based projection and/or DFA minimization would somehow have split-up the single marked location into multiple ones.
Let us take two of them and refer to these locations as $m_1$ and $m_2$.
Neither $m_1$ nor $m_2$ can have outgoing edges.
But then there can be no word in the automaton language that would distinguish $m_1$ and $m_2$.
Hence they must be the same location since the automaton is minimal.

\begin{example*}
The minimized \texttt{BitFlipper} CIF model is shown in \autoref{lst:bitflipper-minimized-cif}.
The CIF model has a \texttt{\_\_start} and an \texttt{\_\_end} event, denoting the start and end of the activity to be synthesized.
The CIF automaton is composed of five locations:
\begin{itemize}
    \item location \texttt{s1} is the initial location, with one outgoing edge towards \texttt{s2} after event \texttt{\_\_start};
    \item location \texttt{s2} has one outgoing edge towards \texttt{s4}, after event \texttt{initialize};
    \item location \texttt{s3} is marked, namely is a final location, hence without outgoing edges;
    \item location \texttt{s4} has two outgoing edges towards \texttt{s3}, after event \texttt{\_\_end} (in case \texttt{bit} is initialized as \texttt{true}), and towards \texttt{s5} after event \texttt{flip} (otherwise);
    \item location \texttt{s5} has one outgoing edge towards \texttt{s3}, after event \texttt{\_\_end}.
\end{itemize}
This state space is the input to Petrify, that synthesizes a Petri net from it.
\end{example*}

\ciffile{images/bitflipper_synthesized_minimized.cif}{Minimized \texttt{BitFlipper} CIF model.}{lst:bitflipper-minimized-cif}

\subsection{Petri net synthesis}
\label{sec:petrinet-synthesis}

The operation \petrinetSynthesis{\var{cifStatespace_{min}}} performs Petri net synthesis to compute a minimal Petri net whose behavior is trace-equivalent to the single automaton in the given CIF specification, \var{cifStatespace_{min}}.
This operation attempts to synthesize a free-choice Petri net, and if that fails, it synthesizes an ordinary Petri net instead.

We use the Petrify tool for performing Petri net synthesis.
We thereby use the following options of Petrify: \texttt{-opt} to try to find the best possible result; \texttt{-fc} to synthesize a free-choice Petri net;
\texttt{-ip} to produce a Petri net with intermediate places (otherwise certain places could be omitted to make the result a bit smaller for visualization purposes); and \texttt{-log} to generate a log file.
If synthesis fails with the \texttt{-fc} option, Petrify will be invoked again without \texttt{-fc}.

In our activity synthesis algorithm, we use PNML as the intermediate format for representing Petri nets.
Therefore, part of the \petrinetSynthesisLabel{} operation is to translate \var{cifStatespace_{min}} to the input language of Petrify, and transforming the output of Petrify to PNML.

\paragraph{Motivation.}
By having computed a (projected and minimal) CIF state space, \var{cifStatespace_{min}}, we are still quite distant from a concrete UML activity.
The main reason is that concurrency can more concisely be represented in UML activities, via their fork and join nodes, compared to state machines and automata.
In contrast, \var{cifStatespace_{min}} has all concurrent interleaving explicitly unfolded as diamond patterns.

\paragraph{Approach.}
We now somehow have to detect all diamond patterns of concurrent interleaving in \var{cifStatespace_{min}} and translate those to fork/join patterns in the to-be-synthesized UML activity.
This is done by means of Petri net synthesis, which is a field of research aiming to do exactly that, but then on Petri nets rather than UML activities.
Nevertheless, Petri nets and activities are quite closely related, in the sense that the semantics of activities is usually defined as a token-based semantics.
Our main strategy is therefore to synthesize a minimal Petri net from \var{cifStatespace_{min}} (in this section), and translate that to a UML activity (in \autoref{sec:transform-petrinet-to-activity}).
We thus use Petri nets as an intermediate formalism in our activity synthesis algorithm.

Moreover, there are particular classes of Petri nets, like \emph{free-choice} Petri nets, that are likely to lead to more intuitive UML activities.
(This is based on our observations from earlier experiments.
We haven't yet done an extensive study or comparison to see whether this is always the case.)
Therefore we attempt to synthesize a free-choice Petri net whenever possible.

However, just translating a Petri net to a UML activity structure is not yet sufficient: we then still need to account for the data which had been eliminated in the CIF state space generation step (\autoref{sec:state-space-generation}).
In particular, (incoming and outgoing) control flow guards are needed, for example for the decision nodes of the synthesized UML activity, since without such guards, any control flow could freely be taken, leading to executions that would not be allowed by the synthesized CIF supervisor.
This step is done separately (in \autoref{sec:compute-control-flow-guards}) since to the best of our knowledge, Petri net synthesis with data/state is an open research field for which tooling is not available.

\paragraph{Preconditions.}
Since Petrify is used for Petri net synthesis, all preconditions from that tool apply.
However, these preconditions do not seem to be well-documented.
In any case the input CIF specification should not contain identifiers which are reserved keywords in the input formalism of Petrify.
But since all Petrify reserved keywords seem to start with a dot, e.g., \texttt{.inputs} and \texttt{.graph}, this is (probably) already ensured as valid UML models do not contain identifiers containing a dot.

Moreover, the input CIF specification must contain exactly one automaton, i.e., the minimized CIF state space computed in the previous steps.
This automaton must have an explicit alphabet that contains no duplicate events.

Furthermore, the event name \loopLabel{} must not be in the automaton alphabet.
This is because \petrinetSynthesisLabel{} will create an auxiliary self-loop edge named \loopLabel{} before Petrify is invoked, which is removed later from the output of Petrify.
This auxiliary self-loop is added to make Petrify work.
This is because Petrify seems unable to do Petri net synthesis in case the input automaton has deadlock locations, i.e., locations without outgoing edges.
And recall that \var{cifStatespace_{min}} has a single marked location which is a sink location, and thus when you get into this location during some execution, the execution deadlocks.
Hence, to resolve this, we add an extra self-loop edge that connects the single marked location to itself, to still allow `progress' from this sink location.
After having invoked Petrify, the synthesized Petri net will contain exactly one transition for \loopLabel{} (since the input automaton has exactly one marked location and we added exactly one \loopLabel{} edge), so it's easy to remove it again.

Finally, the string \toLabel{} must not occur in any event name in the input automaton.
This is later needed for transforming Petrify output to PNML, where \toLabel{} will be used as part of PNML arc identifiers.

\paragraph{Postconditions.}
All guarantees from Petrify apply.
In particular, the output is an optimal (possibly free-choice) Petri net that is trace-equivalent to the input automaton.
The synthesized Petri net is returned in PNML format.

As explained above, the \loopLabel{} event has been removed from this Petri net.
The synthesized Petri net contains exactly one place that initially holds a token.
This place has no incoming arcs and exactly one outgoing arc to a transition named \startLabel{}.
The returned Petri net also contains exactly one sink place with no outgoing arcs and at least one incoming arc from a transition named \stopLabel{} (there could be multiple such arcs, in contrast to the initial place).
These two places will later become the initial and final node of the synthesized activity.

Petrify may have performed \emph{label splitting}.
This means that Petrify may have chosen to split up certain events $e$ in \var{cifStatespace_{min}} into events that are named $e/1$, $e/2$, etc.
This is done by Petrify for technical reasons that are not explained further here, but which are needed to enable Petri net synthesis.
The consequence of label splitting is that the synthesized Petri net may have multiple transitions for some CIF events $e$ that are then labeled incrementally, as $e/1$, $e/2$, etc.
We can later easily detect such duplication and remove these `duplication markers'.

Moreover, as an internal step, the synthesized Petri net has been normalized (i.e., all its places have been relabeled).
This is needed since Petrify seems able to produce nondeterministic results in the sense that running Petrify multiple times on the same input model may give different results.
But these different results are the same modulo names of places.
We therefore normalize synthesized Petri nets, for example to allow proper regression testing.

\begin{example*}
The Petrify output is depicted in \autoref{fig:petrify-out}.
Notice that the end event \texttt{\_\_end} has been split into two separate transitions due to label splitting.
These two transitions will be merged together in the conversion step to a UML activity, and be turned into a UML merge node.
Further, the `final' place \texttt{p4} is equipped with a self-loop, which will be removed when converting this Petri net to PNML format.
\end{example*}

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.5\linewidth]{images/bitflipper_petrify.png}
	\caption{The Petrify output model.}
	\label{fig:petrify-out}
\end{figure}

\subsection{Reducing nonatomic patterns}
\label{sec:reducing-non-atomic-patterns}

\begin{figure}[t!]
	\begin{subfigure}[t]{0.475\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/nonatomic-pattern/nonatomic-pattern-find.pdf}
		\caption{A nonatomic pattern for a nonatomic nondeterministic action \textsf{A} with two nondeterministic effects.}
		\label{fig:nonatomic-pattern-left}
	\end{subfigure}
	\hspace{0.01\textwidth}
	\begin{subfigure}[t]{0.475\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/nonatomic-pattern/nonatomic-pattern-replace.pdf}
		\caption{The rewritten nonatomic pattern shown on the left. The `end' places and transitions have been merged into the `intermediate' place.}
		\label{fig:nonatomic-pattern-right}
	\end{subfigure}
	\caption{A nonatomic pattern (left) and a rewritten pattern (right).}
	\label{fig:nonatomic-pattern}
\end{figure}

The \rewriteNonAtomicPatternsLabel{} operation rewrites any nonatomic patterns in the Petri net that can be merged.
A \emph{nonatomic pattern} in a Petri net is defined as shown in \autoref{fig:nonatomic-pattern-left}, consisting of:
\begin{itemize}
	\item A `start' transition, corresponding to a start event of an nonatomic (possibly nondeterministic) action.
	In the figure, the \textsf{A} transition is the start transition.
	\item One or more `end' transitions, corresponding to the end events of the nonatomic action that got started by the start transition.
	There are multiple such end transitions if and only if the action is nondeterministic.
	The figure shows two end transitions: \textsf{A\_\_na\_result1} and \textsf{A\_\_na\_result2}.
	\item An `intermediate' place that connects the start and end transitions.
	In the figure, \textsf{p0} is the intermediate place.
	\item An `end' place for every end transition.
	In the figure, \textsf{p1} and \textsf{p2} are the end places.
\end{itemize}

This pattern definition is strict, in the sense that no other places, transitions, and arcs can be part of the pattern.
That is, the start transition cannot have other outgoing arcs, the intermediate place cannot have other incoming/outgoing arcs other than the ones from/to the start and end transitions as shown in \autoref{fig:nonatomic-pattern-left}, the end transitions cannot have other incoming and outgoing arcs, and the end places cannot have other incoming arcs.

Every such nonatomic pattern in the Petri net is rewritten, by replacing the start and end transitions in the pattern by a single transition for executing the nonatomic action.
\autoref{fig:nonatomic-pattern-right} shows the rewritten pattern shown in \autoref{fig:nonatomic-pattern-left}.

\paragraph{Motivation.}
Recall that in the UML-to-CIF transformation (\autoref{sec:transform-uml-to-cif}) we created separate controllable start events and uncontrollable end events for nonatomic and atomic nondeterministic actions.
Then, in the earlier event-based projection step (\autoref{sec:event-based-projection}) we got rid of the end events of the atomic nondeterministic actions, by projecting those out.
However, the end events of nonatomic actions are still in the CIF specifications, and thus also in the Petri net specifications.

\paragraph{Approach.}
The \rewriteNonAtomicPatternsLabel{} operation will attempt to merge the starts and ends of nonatomic actions into single transitions, on the intermediate Petri net representation.
By doing so, these merged transitions will be turned into single UML action nodes in later steps of the synthesis chain.

Note that, instead of rewriting nonatomic patterns on Petri net level, it would also be possible to rewrite them on UML activity level.
Rewriting at the Petri net level offers an advantage because Petri nets have a simpler structure compared to UML activity diagrams. Unlike UML diagrams, they lack fork, join, decision, and merge nodes, which makes identifying and replacing structural patterns much easier.

Finally, merging nonatomic starts and ends is not always possible since the nonatomic pattern may not always apply.
This may, e.g., happen in case of imperfect concurrent interleaving.
For example, consider a nonatomic action \textsf{A} and an action \textsf{B} such that, after data-based synthesis, the resulting supervisor permits \textsf{B} to occur before \textsf{A} and even during \textsf{A} (i.e., between its start and end events), but not after \textsf{A}. 
In this scenario, there is no complete diamond pattern in the interleavings of \textsf{A} and \textsf{B} that can be reduced by the introduction of a fork node through Petri net synthesis. 
Consequently, the intermediate place in \autoref{fig:nonatomic-pattern-left} will include an additional outgoing arc to \textsf{B}, disrupting the nonatomic pattern. Therefore, the start and end transitions of \textsf{A} cannot be not merged.
These transitions are later translated to separate UML action nodes, to be further handled during activity post-processing.

\paragraph{Preconditions.}
This operation requires a Petri net resulting from the previous step.
Moreover, this operation needs to know what Petri net transitions start a nonatomic action, and what the corresponding end transitions are for ending these actions.

\paragraph{Postconditions.}
This operation returns the input Petri net, where all nonatomic patterns have been rewritten as shown by \autoref{fig:nonatomic-pattern}.
Any starts and ends of nonatomic actions whose occurrences do not fit the nonatomic pattern will not have been rewritten, and are later handled on the UML activity level, during activity post-processing.

\subsection{Transforming the Petri net to an activity}
\label{sec:transform-petrinet-to-activity}

The operation \transformToActivity{\var{petriNet}} transforms the given Petri net \var{petriNet} in PNML format to a concrete UML activity.
This operation takes care of unmerged nonatomic patterns, i.e., ones that were not rewritten by \rewriteNonAtomicPatternsLabel{}, by translating their start and end transitions to UML opaque actions with the proper guards and effects.
Furthermore, this operation performs some post-processing: (1) it removes any internal actions, notably \startLabel{} and \stopLabel{}, (2) it further simplifies the synthesized activity, and (3) it removes some names from UML control nodes and control flows, for better readability. 

\paragraph{Motivation.}
The overall aim of the activity synthesis chain is to synthesize concrete UML activities.
Since activities are reasonably close to Petri nets, we do this by first synthesizing a Petri net using known techniques, and transforming this Petri net to a concrete UML activity using \transformToActivityLabel{}.
This activity is then post-processed to improve its readability.

\paragraph{Approach.}
Internal actions are removed since they were only needed to be able to synthesize the activity.
Then the activity is further simplified.
This is done for two reasons: (1) we know that translating a minimal Petri net to a UML activity does not imply that the translated activity is minimal, and (2) the removal of internal actions may lead to patterns in the activity that may further be reduced.
This simplification step searches for several predefined patterns in the UML activity, and rewrites any found instances of these patterns.
Finally, activity post-processing gives the opportunity to do some other minor improvements, e.g., to improve readability a bit by removing some names.

\paragraph{Preconditions.}
The input \var{petriNet} must be in PNML format.
This Petri net may be, but does not have to be, free-choice.
It must have exactly one place that has an initial token, which must additionally have no incoming arcs and exactly one outgoing arc to a transition named \startLabel{}.
It must have exactly one (sink) place that does not have any outgoing arcs, which must additionally have at least one incoming arc from a transition named \stopLabel{}.
Finally, the Petri net must not contain transitions corresponding to control nodes of any concrete activities that are called by the to-be-synthesized activity.
Adding support for synthesizing hierarhical activities is planned as future work.

\paragraph{Postconditions.}
The output is a concrete UML activity which has been translated from \var{petriNet}.
The returned concrete UML activity contains:
\begin{itemize}
	\item Exactly one UML initial node and exactly one UML final node, which have been translated from the two places described above in the preconditions paragraph.
	\item For every transition in \var{petriNet} that performs either an atomic action or a nonatomic action for which the nonatomic pattern has been merged, a UML call behavior node that calls the UML opaque behavior of the action to perform.
	Any duplication that was introduced by label splitting (recall from \autoref{sec:petrinet-synthesis}) has been removed during the process of finding the right UML opaque behavior to call.
	\item For every start transition of an unmerged nonatomic pattern in \var{petriNet}, a UML opaque action node is created to start the nonatomic action.
	This UML opaque action node is atomic, takes over the guard of the nonatomic action, and has no effects.
	The name of this opaque action node will be the nonatomic action name, followed by ``\texttt{\_start}''.
	For example, \texttt{A\_start}.
	\item For every end transition of an unmerged nonatomic pattern in \var{petriNet}, a UML opaque action node is created to end the nonatomic action.
	This UML opaque action node is atomic, has guard \texttt{true}, and takes over the effect of the nonatomic action.
	In case the nonatomic action was also nondeterministic, the right effect is taken over.
	The name of this opaque action node will be the nonatomic action name, followed by ``\texttt{\_end}'', followed by the effect index.
	For example, \texttt{A\_end\_1} and \texttt{A\_end\_2}.
	\item Fork/join/decision/merge control nodes, as translated from similar patterns in \var{petriNet}.
	For example, a Petri net place with multiple incoming arcs and one outgoing arc is translated to a UML merge node.
	The only UML control nodes that can have multiple incoming control flows are join and merge nodes.
	The only UML control nodes that can have multiple outgoing control flows are fork and decision nodes.
	\item No guards on any control flows.
	Control flow guards are computed later, in \autoref{sec:compute-control-flow-guards}.
\end{itemize}

Furthermore, \transformToActivityLabel{} ensures that every control flow that goes out of a decision node will end in either some action node, or in the final node (in which case there was also an action, but it was the auxiliary internal $\stopLabel$ action).
This is a consequence of the structure of the Petri nets that are synthesized by Petrify, and the patterns that they could have.
To give another example of a pattern that cannot occur: it is not possible for the concrete UML activity to have a control flow that goes from some decision node to some other decision node, because in the Petri net there cannot be an arc from a place to another place.

Finally, \transformToActivityLabel{} ensures that the translated UML activity no longer contains internal actions and is simplified.
Moreover, all names of control nodes (initial/final/fork/join/decision/merge nodes) and control flow have been removed for better readability.

\subsection{Computing control flow guards in the activity}
\label{sec:compute-control-flow-guards}

The \computeGuards{\var{umlActivity_{concr}}} operation computes incoming and outgoing guards for the control flows of the given concrete activity \var{umlActivity_{concr}}.
These guards are computed by first translating \var{umlActivity_{concr}} to a CIF specification, and then using CIF data-based synthesis to compute extra guards for the controllable events of that specification, which are the start events for executing the nodes of \var{umlActivity_{concr}}.
By doing so, for every activity node, we compute the extra guard that must hold to be able to safely execute that node. 
These extra guards are then translated to incoming and/or outgoing guards of the incoming and/or outgoing control flows of the activity nodes.
The computation of a guard, as well as whether it is applied to an incoming or outgoing control flow of an activity node, depends on the node's type.
This is further elaborated upon below.

\paragraph{Motivation.}
At this point in the activity synthesis algorithm we managed to synthesize the structure of the concrete UML activity.
However, this activity does not contain any data (other than the guards and effects of actions), since Petri net synthesis is unable to deal with data.
As a result, the (incoming and outgoing) guards that determine which control flow should be followed are missing at this point.
Without control flow guards, the synthesized activity may have more behavior than allowed by the requirements, including potentially wrong or deadlocking behavior.
Hence, we must compute the control flow guards and add them to the activity, which is what \computeGuardsLabel{} does. 

\paragraph{Approach.}
The \computeGuardsLabel{} operation starts by translating \var{umlActivity_{concr}} to a CIF specification in a similar way as described in \autoref{sec:transform-uml-to-cif}.
In fact, the same transformation \transformUmlToCifLabel{} is used for this, with some minor differences:
\begin{itemize}
	\item We now give a concrete UML activity as input, rather than an abstract one.
	So instead of translating the UML opaque behaviors in the input model, we now translate the nodes and control flows of \var{umlActivity_{concr}} (as described already in \autoref{sec:transform-uml-to-cif} for activities that are being called).
	However, we do not translate the initial node and final node, since execution of these nodes only has meaning when \var{umlActivity_{concr}} is being called from some other activity, which is not the case here as \var{umlActivity_{concr}} is considered in isolation.
	The UML-to-CIF translation ensures that there is a token on the single initial control flow---the one that goes out of the initial node of \var{umlActivity_{concr}}---by letting the corresponding CIF variable have \texttt{true} as the default value.
	Moreover, we do not translate any other concrete activities present in the input model, because \var{umlActivity_{concr}} is flattened and therefore does not invoke any other activities.
	\item The activity postconditions are split and translated to CIF as two separate variants: \emph{without structure} and \emph{with structure}. 
	The without structure translation follows the approach described in \autoref{sec:transform-uml-to-cif}. 
	The with structure translation adds an extra condition: only the final control flow, the one leading to the last UML node of \var{umlActivity_{concr}}, holds a token.
	Both postcondition variants are translated to Boolean-typed algebraic variables in CIF.
	The algebraic variable for the ``with structure'' variant is used to indicate the marked states of the CIF specification.
	\item Extra CIF requirements are generated expressing that, whenever the activity postcondition holds, no further action nodes can be executed.
	Similar requirements were already generated before, as explained in \autoref{sec:transform-uml-to-cif}.
	Here we slightly change them for the purpose of guard computation, since we must still allow the execution of control nodes whenever the activity postcondition holds, e.g., to execute join/merge/final nodes of \var{umlActivity_{concr}} to finalize the execution.
	To achieve that, we require that the start events of all action nodes are disabled whenever the ``without structure'' variant of the activity postcondition holds, and that the start events of all control nodes are disabled whenever the stronger ``with structure'' variant of the postcondition holds.
	\item Every CIF event for starting the execution of some node in \var{umlActivity_{concr}} is translated as a controllable event.
	This is different from before: \autoref{sec:transform-uml-to-cif} describes that, when calling a concrete activity from a to-be-synthesized activity, only the start events of initial nodes are controllable, and the others are all uncontrollable.
	Note that, differently from the previous translation, \var{umlActivity_{concr}} does not call other activities, as all concrete activities are flattened.
	Our goal now is to determine the extra conditions required for the safe execution of the nodes in \var{umlActivity_{concr}}. 
	To this end, we make all their start events controllable.
	This allows computing control flow guards as locally as possible.
	\item The translation of occurrence constraints is slightly different, to be able to correctly handle unmerged nonatomic patterns.
	In particular, for every nonatomic action that is subject to an occurrence constraint, the translated CIF requirement automaton for the constraint should consider: (1) the CIF events created for the call behavior nodes in \var{umlActivity_{concr}} that call the UML opaque behavior of that action, as well as (2) the CIF start events of the unmerged nonatomic patterns involving that action.
\end{itemize}

After translating \var{umlActivity_{concr}} to a CIF specification, extra guards are computed for the CIF start events for the activity nodes, using CIF data-based synthesis.
Data-based synthesis is configured to do forward reachability (\texttt{--forward-reach=true}) and to start with forward reachability in the fixed-point order (\texttt{--fixed-point-order=reach-nonblock-ctrl}).
So far, this configuration seems to perform best in practice.
However, we have not yet properly validated this, so we are unsure whether this is the best fixpoint order strategy in general.
We also configure data-based synthesis to not free certain Binary Decision Diagrams (BDDs) that we need for guard computation, which are otherwise freed by the synthesis procedure.
BDDs are used by data-based synthesis, but also by guard computation, to symbolically represent and conveniently manupulate sets of system states.
Since guards are predicates over the system state, they can be represented as BDDs.
We will therefore compute control flow guards on BDD level, after which we will convert them to CIF expressions.

At this point, we have used CIF data-based synthesis to compute the controlled-behavior predicate as a BDD, as well as extra guards for the controllable CIF events, also as BDDs.
The next step is using these BDDs to compute the extra guards needed for executing the activity nodes, after which we turn these extra guards into incoming and/or outgoing control flow guards.
The extra guards for activity nodes are computed in the following way.
Let $\mathit{edge}$ be the CIF/BDD edge for starting the execution of some activity node.
Then $\mathit{edge}$ must have a controllable event.
The extra guard $\texttt{extra}(\mathit{edge})$ for $\mathit{edge}$, i.e., the extra guard for executing the activity node, is essentially\footnote{This definition is slightly simplified.
The actual definition additionally eliminates internal variables using existential quantification.
We come back to that later.} defined as:
\begin{equation*}
	\texttt{extra}(\mathit{edge}) = \texttt{simplify}(\texttt{and}(\texttt{guard}(\mathit{edge}), \mathit{ctrlBeh}), \texttt{and}(\texttt{origGuard}(\mathit{edge}), \mathit{ctrlBeh}))
\end{equation*}
where:
\begin{itemize}
	\item $\texttt{origGuard}(\mathit{edge})$ is the original guard for $\mathit{edge}$ that was used as input for CIF data-based synthesis, as a BDD.
	\item $\texttt{guard}(\mathit{edge})$ is the strengthened guard for $\mathit{edge}$ that was produced as output of CIF data-based synthesis, as a BDD.
	\item $\mathit{ctrlBeh}$ is the controlled-behavior predicate computed by CIF data-based synthesis, as a BDD.
	\item $\texttt{and}$ is a binary BDD operation that computes the conjunction of the two given BDDs.
	\item $\texttt{simplify}$ is a binary BDD operation that attempts to simplify the structure of the first given BDD by assuming the second BDD.
	This simplification is done to produce more readable control flow guards.
\end{itemize}

To understand this computation, let $S$ be the set of all controlled system states in which the uncontrolled system guard of $\mathit{edge}$ holds.
This set $S$ is captured exactly by the BDD $\texttt{and}(\texttt{origGuard}(\mathit{edge}), \mathit{ctrlBeh})$.
Now we must find the subset $S' \subseteq S$ of these system states from which the application of $\mathit{edge}$ always ends up in a controlled system state.
Finding this subset $S'$ is important since the activity node corresponding to $\mathit{edge}$ must not be executed in any system state $S \setminus S'$, and $\texttt{extra}(\mathit{edge})$ should capture exactly that.
To compute $S'$ as a BDD, we have to reason about applications of $\mathit{edge}$.
Luckily, CIF data-based synthesis has already done this for us, as it computed $\texttt{guard}(\mathit{edge})$, which ensures that any application of $\mathit{edge}$ ends up in a controlled system state.
Thus, the set $S'$ is captured exactly by the BDD $\texttt{and}(\texttt{guard}(\mathit{edge}), \mathit{ctrlBeh})$.
Note that the construction of this BDD still requires a conjunction with $\mathit{ctrlBeh}$.
This is to ensure that the subset relation $S' \subseteq S$ indeed holds, which is needed for ensuring that \texttt{simplify} produces a correct extra guard\footnote{CIF data-based synthesis guarantees that any execution of $\mathit{edge}$ from a controlled system state in which $\texttt{guard}(\mathit{edge})$ holds end up in a controlled system state.
However, the predicate $\texttt{guard}(\mathit{edge})$ may itself describe more system states than just the controlled ones.
In other words, the set of states described by $\texttt{guard}(\mathit{edge})$ is not necessarily a subset of $\mathit{ctrlBeh}$.
The extra $\texttt{and}$ computation is to ensure this subset relation.
Without it, the $\texttt{simplify}$ operation may assume too many states, which has shown to lead to incorrectly computed extra guards.}.
Now that we have BDDs representing the sets $S$ and $S'$, we can compute $\texttt{extra}(\mathit{edge})$ by means of BDD simplication: assuming we are in a system state from $S$, what is the extra condition needed to ensure that we are also in a system state from $S'$?
This extra condition is thus defined as the `simplication' of the BDD representation of $S'$ with respect to the BDD representation of $S$.

Note that, due to the way $\texttt{extra}(\mathit{edge})$ is defined, we assume that $\mathit{edge}$ is only taken from controlled system states, i.e., states from $\mathit{ctrlBeh}$.
The correctness argument of $\texttt{extra}(\mathit{edge})$ is inductive: assuming we execute the activity in a controlled manner up to the execution of the activity node represented by $\mathit{edge}$, we now have to compute the extra guard that ensures that the execution of $\mathit{edge}$ ends up in a controlled system state again.
If we do this consistently, then every activity execution will be safe (under the control flow guards that we compute for the activity, via $\texttt{extra}$) by induction on the length of the execution trace.
We thus stay within the controlled system behavior.
As an alternative, we could have defined $\texttt{extra}(\mathit{edge})$ in a way that does not rely on this assumption.
Then $\texttt{extra}(\mathit{edge})$ would have been defined as $\texttt{simplify}(\texttt{guard}(\mathit{edge}), \texttt{origGuard}(\mathit{edge}))$.
This definition would be correct in theory, but in practice it would lead to much duplication in computed control flow guards.
In particular, we have seen that, if some control flow in the synthesized activity would get some non-trivial guard, then all subsequently reachable control flows would also get that guard.
We now prevent this duplication.

Moreover, the definition of $\texttt{extra}(\mathit{edge})$ as given earlier is slightly simplified.
The actual definition also ensures that the computed extra guard does not depend on any internal CIF variables that were introduced by the UML-to-CIF transformation, like the atomicity variable.
Such a thing can be ensured because there might be multiple valid ways to \texttt{simplify} a BDD, leading to different results which are all correct.
In other words, a correct simplification result is not necessarily unique.
In practice it might happen that multiple extra guards exist for $\mathit{edge}$ that are all correct, some of which are expressed over internal CIF variables and some of which are not.
And as a result of the $\texttt{simplify}$ operation, it might happen that $\texttt{extra}(\mathit{edge})$ becomes a predicate that does depend in internal state.
This could have been avoided by removing all internal CIF variables from the BDD representations of $S$ and $S'$ through existential quantification. 
Doing so ensures that $\texttt{extra}(\mathit{edge})$ does not depend on internal state. 
However, the drawback is that extra guards may not always be computable, as in some cases the only way to express the extra guard for $\mathit{edge}$ relies on internal state.
The code implementation checks for such internal state dependencies.
The activity synthesis algorithm terminates exceptionally when such a case is detected, resulting in an error message for the user.
With the addition of existential quantification, the full definition of $\texttt{extra}(\mathit{edge})$ now becomes:
\begin{equation*}
	\begin{split}
		\texttt{extra}(\mathit{edge}) &= \texttt{simplify}( \\
			&\texttt{exists}(\texttt{and}(\texttt{guard}(\mathit{edge}), \mathit{ctrlBeh}), \mathit{internalVars}), \\
			&\texttt{exists}(\texttt{and}(\texttt{origGuard}(\mathit{edge}), \mathit{ctrlBeh}), \mathit{internalVars}))
	\end{split}
\end{equation*}
where $\mathit{internalVars}$ is a BDD representing the set of internal variables to eliminate, and $\texttt{exists}$ is the BDD operation that computes the existential quantification of a given BDD over a set of variables also given as a BDD.

Finally, now that we have computed extra guards $\texttt{extra}(\mathit{edge})$ for every CIF/BDD edge $\mathit{edge}$ with a controllable event, we must now translate these extra guards to incoming and/or outgoing control flow guards in the activity.
Recall that $\mathit{edge}$ that been created by the UML-to-CIF translator to start the execution of some activity node.
Let $\mathit{umlNode}$ be the UML activity node for which the CIF/BDD edge $\mathit{edge}$ has been created.
Then we can translate $\texttt{extra}(\mathit{edge})$ to incoming/outgoing guards of the incoming/outgoing control flows of $\mathit{umlNode}$.
This translation is done by case distinction on the activity node type:
\begin{itemize}
	\item If $\mathit{umlNode}$ is a fork node, then $\texttt{extra}(\mathit{edge})$ will become the outgoing guard of the single incoming control flow of $\mathit{umlNode}$.
	Note that an execution of $\mathit{umlNode}$ is atomic and has no guards nor effects.
	Therefore, $\mathit{umlNode}$ can only be executed if it can take a token from its single incoming control flow, to which we have added the extra guard.
	\item If $\mathit{umlNode}$ is a join node, then $\texttt{extra}(\mathit{edge})$ will become the incoming guard of the single outgoing control flow of $\mathit{umlNode}$.
	Note that an execution of $\mathit{umlNode}$ is atomic and has no guards nor effects.
	Therefore, $\mathit{umlNode}$ can only be executed if it can put a token on its single outgoing control flow, to which we have added the extra guard.
	\item If $\mathit{umlNode}$ is a decision node, we may have multiple extra guards, since the UML-to-CIF translator created a controlled CIF event for every decision branch, i.e., for every outgoing control flow.
	Then $\texttt{extra}(\mathit{edge})$ will become the incoming guard of the outgoing control flow of $\mathit{umlNode}$ for which $\mathit{edge}$ was created.
	Note that an execution of $\mathit{umlNode}$ is atomic and has no guards nor effects.
	Therefore, the execution of $\mathit{umlNode}$ can only follow a certain decision branch if a token can be put on that outgoing control flow, to which we have added the extra guard.
	\item If $\mathit{umlNode}$ is a merge node, we may have multiple extra guards, since the UML-to-CIF translator created a controlled CIF event for every merge branch, i.e., for every incoming control flow.
	Then $\texttt{extra}(\mathit{edge})$ will become the outgoing guard of the incoming control flow of $\mathit{umlNode}$ for which $\mathit{edge}$ was created.
	Note that an execution of $\mathit{umlNode}$ is atomic and has no guards nor effects.
	Therefore, the execution of $\mathit{umlNode}$ can only follow a certain merge branch if a token can be taken from that incoming control flow, to which we have added the extra guard.
	\item If $\mathit{umlNode}$ is the initial node, then the situation is slightly different, since we have not created a controllable CIF event for its execution\footnote{This is because the execution of an initial node also involves another activity that calls it, to transfer the token to the called activity.}.
	Instead, in the CIF translation, we made sure via the initials predicate that initially there is a token on its outgoing control flow.
	So guard computation works slightly different here, but still follows the same principles.
	Revisiting our earlier explanation of $\texttt{extra}$; we now let $S$ be the set of all (controlled or uncontrolled) system states in which the the activity precondition holds and in which there is a token on the single outgoing control flow of the initial node.
	And we let $S'$ be the set of all controlled system states that are in $S$.
	Then clearly $S' \subseteq S$, thus we can compute an extra guard, which expresses the extra condition needed on top of the activity precondition for calling the activity, i.e., for putting a token on the single outgoing control flow of the initial node.
	The extra guard thus becomes an incoming guard of that control flow.
	Note that $S$ may contain uncontrolled system states.
	This has to do with the inductive correctness argument: the extra incoming guard should ensure that we start activity execution in a controlled system state, so that the inductive correctness argument applies.
	\item If $\mathit{umlNode}$ is the final node, then the situation is slightly different as well, since we have not created a controllable CIF event for its execution\footnote{This is because the execution of a final node also involves another activity that called it, to transfer the token back to the calling activity.}.
	Instead, in the CIF translation, we made sure via the marked predicate that activity execution is truly finished when (1) there is a token on the incoming control flow of $\mathit{umlNode}$, (2) the activity postcondition holds, and (3) no other control flow holds a token.
	So guard computation works slightly different here, but still follows the same principles.
	Revisiting our earlier explanation of $\texttt{extra}$; we now let $S$ be the set of all controlled system states in which the single incoming control flow of $\mathit{umlNode}$ has a token.
	And we let $S'$ be the set of all system states in $S$ in which the activity postcondition holds.
	Note that $S$ now contains only controlled system states, which is unlike the explanation for initial nodes above.
	This is because of the inductive correctness argument: every execution step ends in a controlled system state, including the step to finalize the execution of this activity.
	Yet we may only `safely' finalize the activity in a system state where the activity postcondition holds, which is captured by $S'$.
	Thus $S' \subseteq S$.
	So we can compute an extra guard, which expresses the extra condition needed to be able to safely finalize activity execution.
	However, due the extra state/event exclusion invariants that we generated to prevent the activity to perform any more actions when its postcondition holds, this extra guard will always be trivially \texttt{true}.
	This expectation is also checked in the code implementation with an assertion.
	So the incoming control flow of $\mathit{umlNode}$ will never get a non-trivial extra guard.
\end{itemize}

As a last step, to prevent BDD memory leaks, we free all BDDs that have not been freed by data-based synthesis, due to our configuration.
Moreover, a final check is done over the synthesized activity to see whether it has nondeterministic choices.
An activity has nondeterministic choices when it has decision nodes where multiple decision branches can become enabled in the same system state.
We aim to synthesize deterministic controllers, i.e., UML activities with deterministic behavior.
So a user warning will be given for every found nondeterministic choice.

\paragraph{Preconditions.}
The input UML activity \var{umlActivity_{concr}} should be a synthesized concrete UML activity, with its nonatomic patterns reduced wherever possible as result of \autoref{sec:reducing-non-atomic-patterns}.
The input activity must not call other activities, i.e., it must be flattened, which is ensured already by the previous steps.

Moreover, tracing information must be available indicating how this concrete activity relates to the input UML model, as well as to all the intermediate steps/representations that were needed to synthesize this concrete activity.
This tracing information is needed, e.g., for finding all CIF events that have been created for the nodes of \var{umlActivity_{concr}}.

\paragraph{Postconditions.}

The output is a UML activity that is equal to \var{umlActivity_{concr}}, but with proper incoming and outgoing control flow guards added to it.
These control flow guards ensure correctness: any execution of \var{umlActivity_{concr}} is guaranteed to not deadlock nor to reach a system state that violates the requirements.
The added incoming and outgoing control flow guards are Boolean conditions that express extra conditions for placing a token on a control flow, or for taking a token from a control flow, respectively.
These conditions are extra in the sense that they are not yet captured by the guards of any actions performed by \var{umlActivity_{concr}}.

Moreover, the added control flow guards are guaranteed not use internal variables that were used for synthesizing \var{umlActivity_{concr}}, like the atomicity variable or occurrence constraint variables.
However, it might happen that \var{umlActivity_{concr}} requires control flow guards that cannot be expressed in a way that is independent of internal state.
In that case, the synthesis algorithm will terminate exceptionally.
We have shown that this can happen with some rather artificial synthesis examples.
So far we have not experienced such problems with more realistic synthesis examples.

User warnings are given for any nondeterministic choices in the synthesized activities with control flow guards.

\begin{example*}
Finally, the synthesized activity is shown in \autoref{fig:synthesized-bitflipper}.
The initial node is marked in blue, the place \texttt{p3} has been turned into a decision node, and the two outgoing control flows represent the nondeterministic initialization of \texttt{bit}.
If \texttt{bit} is \texttt{true}, the flow can go directly to the final node (shown with a blue border); otherwise, the flow goes through the \texttt{flip} action.
The two \texttt{\_\_end} transitions have been translated into a merge node, and finally place \texttt{p5} is transformed into the final node.
\end{example*}

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.5\linewidth]{images/bitflipper_activitysynthesised.png}
    \caption{The synthesized activity.}
    \label{fig:synthesized-bitflipper}
\end{figure}

\end{document}
