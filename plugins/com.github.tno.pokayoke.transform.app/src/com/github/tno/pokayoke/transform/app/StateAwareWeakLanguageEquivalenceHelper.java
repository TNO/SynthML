////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023-2026 TNO and Contributors to the GitHub community
//
// This program and the accompanying materials are made available under the terms of the
// Eclipse Public License v2.0 which accompanies this distribution, and is available at
// https://spdx.org/licenses/EPL-2.0.html
//
// SPDX-License-Identifier: EPL-2.0
////////////////////////////////////////////////////////////////////////////////////////

package com.github.tno.pokayoke.transform.app;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.annotations.AnnotationArgument;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.cif.metamodel.java.CifConstructors;

import com.google.common.base.Verify;
import com.google.common.collect.Sets;

/**
 * Helper for the language equivalence check. Assumes that the CIF models are generated by the CIF state space explorer.
 */
public class StateAwareWeakLanguageEquivalenceHelper {
    private StateAwareWeakLanguageEquivalenceHelper() {
    }

    /**
     * Prepares two CIF models for the language equivalence check. Performs sanity checks, removes internal variables
     * from state annotations. Returns a record containing the filtered state annotations.
     *
     * @param model1 The first CIF model.
     * @param externalEvents1 The set of external events of the first model.
     * @param internalEvents1 The set of internal events of the first model.
     * @param model2 The second CIF model.
     * @param externalEvents2 The set of external events of the second model.
     * @param internalEvents2 The set of internal events of the second model.
     * @param externalVariableNames The set containing non-escaped external variable names.
     * @return The model preparation result.
     */
    public static ModelPreparationResult prepareModels(Specification model1, Set<Event> externalEvents1,
            Set<Event> internalEvents1, Specification model2, Set<Event> externalEvents2, Set<Event> internalEvents2,
            Set<String> externalVariableNames)
    {
        // Sanity checks. The models should only have one component, an automaton.
        Verify.verify(model1.getComponents().size() == 1, StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                + "the first model contains more than one component.");
        Verify.verify(model2.getComponents().size() == 1, StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                + "the second model contains more than one component.");
        Verify.verify(model1.getComponents().get(0) instanceof Automaton,
                StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + "the first model's component is not an automaton.");
        Verify.verify(model2.getComponents().get(0) instanceof Automaton,
                StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + "the second model's component is not an automaton.");

        // Filter internal variables from state annotations.
        Map<Location, Annotation> filteredStateAnn1 = filterStateAnnotations(model1, externalVariableNames);
        Map<Location, Annotation> filteredStateAnn2 = filterStateAnnotations(model2, externalVariableNames);

        // Sanity check: check that the external and internal events represent the entire state space alphabet, and that
        // they do not overlap.
        Automaton stateSpace1 = (Automaton)model1.getComponents().get(0);
        Automaton stateSpace2 = (Automaton)model2.getComponents().get(0);

        checkAlphabetCoverage(stateSpace1, externalEvents1, internalEvents1);
        checkAlphabetCoverage(stateSpace2, externalEvents2, internalEvents2);

        return new ModelPreparationResult(filteredStateAnn1, filteredStateAnn2);
    }

    private static Map<Location, Annotation> filterStateAnnotations(Specification model,
            Set<String> externalVariableNames)
    {
        // Get state annotations for the CIF model.
        Map<Location, List<Annotation>> locToAnnotations = StateAnnotationHelper.getStateAnnotations(model);

        // Verify that each location has only one annotation. This is always the case with CIF model generated with the
        // state space exploration.
        List<String> locsWithErrors = locToAnnotations.entrySet().stream().filter(e -> e.getValue().size() != 1)
                .map(a -> a.getKey().getName()).toList();
        if (!locsWithErrors.isEmpty()) {
            throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX + String.format(
                    "state space '%s' contains state(s) %s that don't have exactly one state annotation.",
                    model.getComponents().get(0).getName(), String.join(", ", locsWithErrors)));
        }

        // Filter the state annotations, by removing the internal variables from them.
        Map<Location, Annotation> locToFilteredAnnotations = new LinkedHashMap<>();

        for (Entry<Location, List<Annotation>> locToAnnotation: locToAnnotations.entrySet()) {
            Location loc = locToAnnotation.getKey();
            List<Annotation> annotations = locToAnnotation.getValue();
            Annotation annotation = annotations.get(0);

            // Filter and create new annotation. External variable names are not escaped.
            List<AnnotationArgument> filteredArgs = annotation.getArguments().stream()
                    .filter(arg -> externalVariableNames.contains(arg.getName())).toList();
            Annotation filteredAnnotation = CifConstructors.newAnnotation(filteredArgs, annotation.getName(),
                    annotation.getPosition());
            locToFilteredAnnotations.put(loc, filteredAnnotation);
        }

        return locToFilteredAnnotations;
    }

    private static void checkAlphabetCoverage(Automaton stateSpace, Set<Event> externalEvents,
            Set<Event> internalEvents)
    {
        // Check that internal and external events do not overlap.
        Set<Event> intersection = Sets.intersection(externalEvents, internalEvents);
        Verify.verify(intersection.isEmpty(),
                String.format("External and internal event sets contain overlapping events: ",
                        String.join(", ", intersection.stream().map(e -> e.getName()).toList())));

        // Check that the alphabet of the state space is equal to the union of external and internal events. This check
        // is performed by absolute names, since they are different objects.
        Set<Event> eventsMerged = new LinkedHashSet<>();
        eventsMerged.addAll(externalEvents);
        eventsMerged.addAll(internalEvents);

        Set<Event> stateSpaceAlphabet = CifEventUtils.getAlphabet(stateSpace);
        Set<String> absNamesStateSpace = stateSpaceAlphabet.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toCollection(LinkedHashSet::new));
        Set<String> absNamesEventsMerged = eventsMerged.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toCollection(LinkedHashSet::new));

        if (!absNamesStateSpace.equals(absNamesEventsMerged)) {
            Set<String> onlyInMerged = Sets.difference(absNamesEventsMerged, absNamesStateSpace);
            Set<String> onlyInStateSpace = Sets.difference(absNamesStateSpace, absNamesEventsMerged);

            if (!onlyInStateSpace.isEmpty()) {
                throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + String.format("state space '%s' contains events that are neither internal nor external: %s.",
                                stateSpace.getName(), String.join(", ", onlyInStateSpace)));
            } else {
                absNamesEventsMerged.removeAll(absNamesStateSpace);
                throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX + String.format(
                        "There are internal/external events that do not belong to the state space '%s' alphabet: %s.",
                        stateSpace.getName(), String.join(", ", onlyInMerged)));
            }
        }
    }

    /**
     * The result of the preparation of the two CIF state spaces.
     *
     * @param stateAnnotations1 The filtered state annotations for the first state space.
     * @param stateAnnotations2 The filtered state annotations for the second state space.
     */
    record ModelPreparationResult(Map<Location, Annotation> stateAnnotations1,
            Map<Location, Annotation> stateAnnotations2)
    {
    }
}
