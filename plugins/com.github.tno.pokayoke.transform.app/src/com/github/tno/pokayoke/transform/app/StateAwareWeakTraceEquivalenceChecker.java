
package com.github.tno.pokayoke.transform.app;

import java.util.ArrayDeque;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.AnnotationEqHashWrap;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;

import com.github.tno.pokayoke.transform.activitysynthesis.CifLocationHelper;
import com.google.common.base.Verify;

/**
 * Weak trace equivalence checker of two CIF models that considers state annotations. The two models must contain a
 * single automaton, and have a compatible alphabet. Alphabets are compatible when they have the same number of events,
 * with possibly different names. Assumes the two models are generated by the CIF state space exploration.
 */
public class StateAwareWeakTraceEquivalenceChecker {
    /**
     * Checks whether two CIF state space automata are weak-trace equivalent, considering state annotations.
     *
     * @param automaton1 The first CIF automaton.
     * @param stateAnnotations1 The map from CIF locations to their projected state annotations, for the first model.
     *     The state annotations contain solely the relevant information used for comparison of the model states.
     * @param epsilonEvents1 The set containing events that represent an epsilon transition for the first model.
     * @param automaton2 The second CIF automaton.
     * @param stateAnnotations2 The map from CIF locations to their projected state annotations, for the second model.
     *     The state annotations contain solely the relevant information used for comparison of the model states.
     * @param epsilonEvents2 The set containing events that represent an epsilon transition for the second model.
     * @param pairedEvents The set containing pairs of corresponding (lists of) events for the two automata. All events
     *     in the first list of events are equivalent to all the events in the second list of events.
     * @return {@code true} if the two automata are language equivalent, {@code false} otherwise.
     */
    public boolean check(Automaton automaton1, Map<Location, Annotation> stateAnnotations1, Set<Event> epsilonEvents1,
            Automaton automaton2, Map<Location, Annotation> stateAnnotations2, Set<Event> epsilonEvents2,
            Set<Pair<List<Event>, List<Event>>> pairedEvents)
    {
        // Sanity check: epsilon events and non-epsilon events must be disjoint.
        Verify.verify(areDisjointEventSets(
                pairedEvents.stream().flatMap(p -> p.getLeft().stream()).collect(Collectors.toSet()), epsilonEvents1));
        Verify.verify(areDisjointEventSets(
                pairedEvents.stream().flatMap(p -> p.getRight().stream()).collect(Collectors.toSet()), epsilonEvents2));

        // Sanity check: marked locations should not have outgoing edges. Computes the set of marked locations.
        Set<Location> markedLocations1 = new LinkedHashSet<>();
        Set<Location> markedLocations2 = new LinkedHashSet<>();
        Verify.verify(markedLocsHaveOutgoingEdges(automaton1, markedLocations1),
                "Automaton 1 has outgoing edges from marked locations.");
        Verify.verify(markedLocsHaveOutgoingEdges(automaton2, markedLocations2),
                "Automaton 2 has outgoing edges from marked locations.");

        // Sanity check: all locations should be able to reach a marked location (be co-reachable).
        Map<Location, Set<Edge>> locToIncomingLoc1 = new LinkedHashMap<>();
        Map<Location, Set<Edge>> locToIncomingLoc2 = new LinkedHashMap<>();
        computeIncomingEdgesPerLoc(automaton1, locToIncomingLoc1);
        computeIncomingEdgesPerLoc(automaton2, locToIncomingLoc2);
        Verify.verify(
                getNonCoReachableLocsCount(automaton1, new LinkedHashSet<>(), markedLocations1, locToIncomingLoc1) != 0,
                "Model 1 contains non co-reachable locations.");
        Verify.verify(
                getNonCoReachableLocsCount(automaton2, new LinkedHashSet<>(), markedLocations2, locToIncomingLoc2) != 0,
                "Model 2 contains non co-reachable locations.");

        // Initialize queue. If null, the models are not equivalent.
        Queue<Pair<Set<Location>, Set<Location>>> queue = initializeQueue(automaton1, stateAnnotations1, automaton2,
                stateAnnotations2);
        if (queue == null) {
            return false;
        }

        Set<Pair<Set<Location>, Set<Location>>> visitedPairs = new LinkedHashSet<>();
        visitedPairs.addAll(queue);

        // Get absolute names of epsilon events.
        Set<String> absNamesEpsEvents1 = epsilonEvents1.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesEpsEvents2 = epsilonEvents2.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        while (!queue.isEmpty()) {
            // Pop first element of the queue.
            Pair<Set<Location>, Set<Location>> currentPair = queue.remove();

            // Compute epsilon-reachable locations and their projections.
            Set<Location> epsilonReachableLocations1 = getEpsilonReachableLocations(currentPair.getLeft(),
                    absNamesEpsEvents1);
            Set<Location> epsilonReachableLocations2 = getEpsilonReachableLocations(currentPair.getRight(),
                    absNamesEpsEvents2);
            List<Location> projectedLocations1 = projectLocations(epsilonReachableLocations1, stateAnnotations1);
            List<Location> projectedLocations2 = projectLocations(epsilonReachableLocations2, stateAnnotations2);

            // Sanity check: the locations projections should collapse into just one location.
            Verify.verify(projectedLocations1.size() == 1, "Epsilon reachability found extra locations.");
            Verify.verify(projectedLocations2.size() == 1, "Epsilon reachability found extra locations.");

            // Check if any epsilon reachable location is marked, for both automata.
            boolean anyMarked1 = epsilonReachableLocations1.stream().anyMatch(markedLocations1::contains);
            boolean anyMarked2 = epsilonReachableLocations2.stream().anyMatch(markedLocations2::contains);
            if (anyMarked1 != anyMarked2) {
                return false;
            }

            // Check that the pair of states is equivalent.
            if (!areEquivalentLocations(projectedLocations1.get(0), stateAnnotations1, projectedLocations2.get(0),
                    stateAnnotations2))
            {
                return false;
            }

            // The pair of states is equivalent. Check also all pairs of states reachable from this pair.
            for (Pair<List<Event>, List<Event>> events: pairedEvents) {
                Set<Location> targetLocations1 = getNextLocations(epsilonReachableLocations1, events.getLeft());
                Set<Location> targetLocations2 = getNextLocations(epsilonReachableLocations2, events.getRight());

                // If one location can reach some target with this action, but the other location cannot reach any,
                // the two models are different. Note that this is different from checking the sizes of the target
                // sets, which can be different. This works only if the size of one is zero while the size of the
                // other is not zero.
                if (targetLocations1.isEmpty() != targetLocations2.isEmpty()) {
                    return false;
                } else if (targetLocations1.size() > 0) {
                    // Add the next pair to the queue, if not already visited.
                    Pair<Set<Location>, Set<Location>> nextPair = Pair.of(targetLocations1, targetLocations2);
                    if (!visitedPairs.contains(nextPair)) {
                        visitedPairs.add(nextPair);
                        queue.add(nextPair);
                    }
                }
            }
        }

        return true;
    }

    private boolean areDisjointEventSets(Set<Event> set1, Set<Event> set2) {
        Set<String> absNamesEventsSet1 = set1.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
        Set<String> absNamesEventsSet2 = set2.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());

        for (String name: absNamesEventsSet2) {
            if (absNamesEventsSet1.contains(name)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Compute the set of marked locations and checks whether any marked location has outgoing edges.
     *
     * @param automa The automaton to check.
     * @param markedLocs The set containing marked locations, modified in-place.
     * @return {@code true} if any marked location has outgoing edges, {@code false} otherwise.
     */
    private boolean markedLocsHaveOutgoingEdges(Automaton automa, Set<Location> markedLocs) {
        boolean hasOutgoing = false;
        for (Location loc: automa.getLocations()) {
            if (CifLocationHelper.isMarked(loc)) {
                markedLocs.add(loc);
                if (!loc.getEdges().isEmpty()) {
                    hasOutgoing = true;
                }
            }
        }
        return hasOutgoing;
    }

    private void computeIncomingEdgesPerLoc(Automaton automa, Map<Location, Set<Edge>> locToIncomingEdge) {
        for (Location loc: automa.getLocations()) {
            locToIncomingEdge.computeIfAbsent(loc, k -> new LinkedHashSet<>());
            for (Edge edge: loc.getEdges()) {
                locToIncomingEdge.computeIfAbsent(CifEdgeUtils.getTarget(edge), k -> new LinkedHashSet<>()).add(edge);
            }
        }
    }

    /**
     * Find co-reachable locations and the number of non-co-reachable locations in an automaton. See also
     * AutomatonHelper#getNonCoreachableCount.
     *
     * @param automa Automaton to search.
     * @param coreachables Co-reachable locations of the automaton, modified in-place.
     * @param markedLocs The set of marked locations of the automaton.
     * @param locToIncomingEdges The map from locations to their incoming edges.
     * @return The number of non-co-reachable locations in the automaton.
     */
    public static int getNonCoReachableLocsCount(Automaton automa, Set<Location> coreachables, Set<Location> markedLocs,
            Map<Location, Set<Edge>> locToIncomingEdges)
    {
        Queue<Location> toExpand = new ArrayDeque<>(1000);
        coreachables.clear();

        // Add all marked states.
        int locCount = automa.getLocations().size();
        toExpand.addAll(markedLocs);
        coreachables.addAll(markedLocs);

        // Expand the marked states to all co-reachable states.
        while (!toExpand.isEmpty()) {
            Location loc = toExpand.remove();
            for (Edge e: locToIncomingEdges.get(loc)) {
                if (coreachables.add(CifEdgeUtils.getSource(e))) {
                    toExpand.add(CifEdgeUtils.getSource(e));
                }
            }
        }
        return locCount - coreachables.size();
    }

    private Queue<Pair<Set<Location>, Set<Location>>> initializeQueue(Automaton automaton1,
            Map<Location, Annotation> annotations1, Automaton automaton2, Map<Location, Annotation> annotations2)
    {
        Queue<Pair<Set<Location>, Set<Location>>> queue = new LinkedList<>();

        // Find initial locations of the first automaton. The check whether the location is initial assumes that the
        // automaton is generated by the state space exploration.
        Set<Location> initialLoc1 = new LinkedHashSet<>();
        for (Location loc: automaton1.getLocations()) {
            if (CifLocationHelper.isInitial(loc)) {
                initialLoc1.add(loc);
            }
        }

        // Find initial locations of the second automaton. The check whether the location is initial assumes that the
        // automaton is generated by the state space exploration.
        Set<Location> initialLoc2 = new LinkedHashSet<>();
        for (Location loc: automaton2.getLocations()) {
            if (CifLocationHelper.isInitial(loc)) {
                initialLoc2.add(loc);
            }
        }

        // Loop over all initial states of the two automata, find the equivalent ones (i.e. have the same annotations),
        // and pair them together.
        Set<Location> visited = new LinkedHashSet<>();
        for (Location loc1: initialLoc1) {
            for (Location loc2: initialLoc2) {
                if (areEquivalentLocations(loc1, annotations1, loc2, annotations2)) {
                    queue.add(Pair.of(Set.of(loc1), Set.of(loc2)));
                    visited.add(loc1);
                    visited.add(loc2);
                }
            }
        }

        // All initial states must be used in some initial pair. If not, return null.
        if (visited.size() == initialLoc1.size() + initialLoc2.size()) {
            return queue;
        } else {
            return null;
        }
    }

    private boolean areEquivalentLocations(Location loc1, Map<Location, Annotation> stateAnnotations1, Location loc2,
            Map<Location, Annotation> stateAnnotations2)
    {
        // Locations are equivalent if their annotations are equivalent.
        return areEquivalentAnnotations(stateAnnotations1.get(loc1), stateAnnotations2.get(loc2));
    }

    private boolean areEquivalentAnnotations(Annotation ann1, Annotation ann2) {
        AnnotationEqHashWrap annotationWrapped1 = new AnnotationEqHashWrap(ann1);
        AnnotationEqHashWrap annotationWrapped2 = new AnnotationEqHashWrap(ann2);
        return annotationWrapped1.equals(annotationWrapped2);
    }

    private Set<Location> getEpsilonReachableLocations(Set<Location> locations, Set<String> epsilonEvents) {
        Set<Location> visited = new LinkedHashSet<>(locations);
        Queue<Location> queue = new LinkedList<>(locations);

        while (!queue.isEmpty()) {
            Location currentLoc = queue.remove();

            for (Edge edge: currentLoc.getEdges()) {
                Set<Event> eventsOnEdge = CifEventUtils.getEvents(edge);
                for (Event edgeEvent: eventsOnEdge) {
                    if (epsilonEvents.contains(CifTextUtils.getAbsName(edgeEvent))) {
                        // Add target location if not yet visited.
                        Location target = CifEdgeUtils.getTarget(edge);
                        if (!visited.contains(target)) {
                            queue.add(target);
                            visited.add(target);
                        }
                    }
                }
            }
        }
        return visited;
    }

    private List<Location> projectLocations(Set<Location> locations, Map<Location, Annotation> locToAnnotations) {
        // Find the projection for all locations, and store them in two dedicated lists.
        List<Annotation> projectedAnnotationsAllLocations = new LinkedList<>();
        List<Location> projectedLocations = new LinkedList<>();

        for (Location loc: locations) {
            if (projectedAnnotationsAllLocations.isEmpty()) {
                // Add the first annotation and the first location into the lists, as a representative element of the
                // sets.
                projectedAnnotationsAllLocations.add(locToAnnotations.get(loc));
                projectedLocations.add(loc);
            } else {
                // If there is one element in the projected annotations list which is equivalent to the current one, do
                // not add to the list.
                if (!projectedAnnotationsAllLocations.stream()
                        .anyMatch(s -> areEquivalentAnnotations(s, locToAnnotations.get(loc))))
                {
                    projectedAnnotationsAllLocations.add(locToAnnotations.get(loc));
                    projectedLocations.add(loc);
                }
            }
        }
        return projectedLocations;
    }

    private Set<Location> getNextLocations(Set<Location> sourceLocations, List<Event> events) {
        Set<String> eventsAbsNames = events.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
        LinkedHashSet<Location> targetLocations = new LinkedHashSet<>();

        for (Location loc: sourceLocations) {
            for (Edge edge: loc.getEdges()) {
                Set<Event> eventsOnEdge = CifEventUtils.getEvents(edge);
                for (Event event: eventsOnEdge) {
                    // Comparison is by name, since the events might be different object.
                    if (eventsAbsNames.contains(CifTextUtils.getAbsName(event))) {
                        targetLocations.add(CifEdgeUtils.getTarget(edge));
                    }
                }
            }
        }
        return targetLocations;
    }
}
