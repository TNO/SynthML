\documentclass{article}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[english]{babel}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{mathpar}
\usepackage{mathtools}

\addto\extrasenglish{
  \renewcommand{\sectionautorefname}{Section}
}
\addto\extrasenglish{
  \renewcommand{\subsectionautorefname}{Section}
}

\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]
\newtheorem{lemma}{Lemma}[section]

\newcommand{\act}[0]{\textsf{act}}
\newcommand{\action}[0]{\textsf{action}}
\newcommand{\Action}[0]{\textsf{Action}}
\newcommand{\actlabel}[0]{\textsf{label}}
\newcommand{\andlabel}[0]{\textsf{and}}
\newcommand{\andnode}[1]{\andlabel\langle#1\rangle}
\newcommand{\Bool}[0]{\mathbb{B}}
\newcommand{\ConcrNode}[0]{\textsf{ConcrNode}}
\newcommand{\ConcrNodeType}[0]{\textsf{ConcrNodeType}}
\newcommand{\Config}[0]{\textsf{Config}}
\newcommand{\decision}[0]{\textsf{decision}}
\newcommand{\denot}[1]{[\![#1]\!]}
\newcommand{\denote}[1]{\denot{#1}_\textsf{e}}
\newcommand{\denotn}[1]{\denot{#1}_\textsf{n}}
\newcommand{\Effects}[0]{\textsf{Effects}}
\newcommand{\effects}[0]{\textsf{effects}}
\newcommand{\enabled}[0]{\textsf{enabled}}
\newcommand{\fork}[0]{\textsf{fork}}
\newcommand{\final}[0]{\textsf{final}}
\newcommand{\Guard}[0]{\textsf{Guard}}
\newcommand{\guard}[0]{\textsf{guard}}
\newcommand{\identity}[1]{\lambda{#1}.{#1}}
\newcommand{\incoming}[0]{\textsf{in}}
\newcommand{\init}[0]{\textsf{init}}
\newcommand{\join}[0]{\textsf{join}}
\newcommand{\Label}[0]{\textsf{Label}}
\newcommand{\merge}[0]{\textsf{merge}}
\newcommand{\NodeID}[0]{\textsf{NodeID}}
\newcommand{\orlabel}[0]{\textsf{or}}
\newcommand{\ornode}[1]{\orlabel\langle#1\rangle}
\newcommand{\outgoing}[0]{\textsf{out}}
\newcommand{\simpleedge}[0]{\varepsilon}
\newcommand{\SimpleNode}[0]{\textsf{SimpleNode}}
\newcommand{\SimpleNodeType}[0]{\textsf{SimpleNodeType}}
\newcommand{\simplenode}[0]{\eta}
\newcommand{\source}[0]{\textsf{source}}
\newcommand{\State}[0]{\textsf{State}}
\newcommand{\target}[0]{\textsf{target}}
\newcommand{\traces}[0]{\textsf{traces}}
\newcommand{\true}[0]{\textsf{true}}

\title{Operational Semantics of Poka Yoke Activities}

\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

This document defines a concise token passing style operational semantics of (simple UML-like) activities.
These activities and their semantics are slightly different from fUML activities.
For example, every action has an associated guard and effects that specify how action execution influences the system state.

The strategy for defining the operational semantics of activities is to first define a notion of \emph{simple activities} (\autoref{sec:simpleactivities}) with an intuitive and concise semantics, and then define the semantics of concrete UML activities by means of translating them to simple activities (\autoref{sec:concractivities}).

The reason for such a translation is two-fold.
Firstly, even though UML activities have various sorts of nodes (`fork', `join', `decision', etc.), their semantics can fundamentally be divided into two categories: $\andlabel$-type nodes and $\orlabel$-type nodes, which are explained later.
If one would specify separate execution rules for all the various sorts of UML activity nodes, then one would find out they are all much the same and would fall into these two categories.

Secondly, the semantics of $\andlabel$-type and $\orlabel$-type nodes is intuitive as well as easy to define.
Instead of having to think about all kinds of corner cases with UML activities\footnote{For example: what would happen if an action node has multiple incoming/outgoing edges? What would happen if a fork node has a self-loop? What if a final node has an outgoing edge, or an initial node has an incoming edge? What if a merge node has no outgoing edges? What if the activity actually contains disjoint disconnected parts? What if there is a non-trivial guard on an edge not coming out of a decision node? Do I need a legion of well-formedness conditions in order to be able to still make sense of activity diagrams at all?}, the semantics of simple activities requires no structural well-formedness conditions.
When thinking of the semantics of some node, ideally one would only need to think about: is it an $\andlabel$-type or an $\orlabel$-type node?

\section{Simple Activities}
\label{sec:simpleactivities}

This section defines the (static) structure and (dynamic) behavior of simple activities, in \autoref{sec:simplestatics} and \autoref{sec:simpledynamics}, respectively.

\subsection{Statics}
\label{sec:simplestatics}

This section defines the static structure of simple activities, consisting of nodes and (guarded) edges.
Nodes contain an action to be executed, and describe how the action should be executed.
Actions contain guards, which are predicates over a global state, as well as (nondeterministic) effects that determine potential successor states.
The concept of state is left abstract in this document, and could later be instantiated in any way you like (e.g., by taking CIF expressions and updates).

\paragraph{State.}
Activities are defined in the presence of \emph{state}, for example a set of variables and their current valuation.
We keep the notion of state more abstract for the purpose of defining the semantics, and let $\State$ be the set of all states.
Users of this semantics could later instantiate $\State$ as desired, e.g., as variable valuation mappings.
Let $\sigma \in \State$ be a typical state.

\paragraph{Guards and effects.}
Guards are defined to be state predicates, while effects are defined to be state transformers, i.e., functions that map states to any number of `successor states', to be able to model nondeterministic action behavior.

Let $\Guard = \State \rightarrow \Bool$ be the set of all \emph{guards} and $\Effects = \State \rightarrow 2^{\State}$ be the set of all \emph{effects functions} over states, with $2^{\State}$ the powerset of $\State$.
We use $g \in \Guard$ and $u \in \Effects$ to denote a typical guard and effects function, respectively.

\paragraph{Actions.}
The main building blocks of activities are the action nodes, which are nodes that carry out a certain \emph{action}.
Any action consists of three parts: an action label to identify it, a guard that must hold in order for the action to be performed, and an effects function that determines possible successor states after having performed the action.
For any action it holds that, if its guard does not hold, or if there is no successor state determined by the effects (i.e., the effects function maps to an empty set), then the action cannot be performed.
In case action execution leads to multiple possible successor states, one of them will be selected nondeterministically, which is further explained in \autoref{sec:simpledynamics}.

More formally, let $\Action = \cramped{\Label \times \Guard \times \Effects}$ be the set of all \emph{actions}, where $\Label$ is the set of all \emph{action labels}.
We use $a \in \Label$ to denote a typical label, and $\alpha \in \Action$ to denote a typical action, such that $\alpha = (a, g, u)$.
So actions are triples consisting of an action label $a$, a guard $g$, and effects function $u$.
Instead of effects function, we may say that $u$ are the \emph{effects of $\alpha$}.

Let $\actlabel : \Action \rightarrow \Label$, $\guard : \Action \rightarrow \Guard$, and $\effects : \Action \rightarrow \Effects$ be projection functions that give the label, guard, and effects function of any action, respectively, so that:
\begin{mathpar}
	\actlabel((a, g, u)) = a
	\and
	\guard((a, g, u)) = g
	\and
	\effects((a, g, u)) = u
\end{mathpar}

\paragraph{Simple nodes.}
Now that actions have been defined, we can define the \emph{nodes} of simple activities, which carry out these actions during executions of the activity.
Simple activity nodes consist of two parts: a node identifier, and a node type that also contains (wraps) the action to perform.
The node identifiers are used to give identity to nodes, which are needed to allow having multiple nodes in an activity that perform the same action.
In simple activities, actions can be executed in one of two ways: in $\andlabel$-style or in $\orlabel$-style, as indicated by the node type.
An $\andlabel$-style execution of an action node requires that \emph{all} its incoming edges must have a token, and after having performed the action, \emph{all} outgoing edges will get a token (under some additional conditions that are explained later).
In contrast, an $\orlabel$-style execution of an action node requires just \emph{a single} incoming edge to have a token, and after having performed the action, \emph{a single} outgoing edge will receive a token (again, under some extra conditions).
This distinction between $\andlabel$-type and $\orlabel$-type nodes is also made in~\cite{DawC2015} with respect to a token firing semantics, explaining that most UML node types can be divided into these two groups.
For example, UML nodes like `fork' and `join' can be represented as $\andlabel$-nodes, while `decision' and `merge' can be represented in terms of $\orlabel$-nodes.
\autoref{sec:concractivities} further details such representations of concrete UML nodes.

More formally, let $\NodeID$ be a set of all \emph{node identifiers}, used to give identity to activity nodes, and let $\ell \in \NodeID$ be a typical node identifier.
Then the set $\SimpleNode$ of all possible \emph{simple activity nodes} is defined as follows:
\begin{mathpar}
	\SimpleNode = \NodeID \times \SimpleNodeType
	\and
	\SimpleNodeType ::= \andnode{\alpha} ~|~ \ornode{\alpha}
\end{mathpar}

Simple activity nodes are pairs consisting of a node identifier $\ell$ and an action $\alpha$ to execute, either in $\andlabel$-style or in $\orlabel$-style.
We write $\simplenode \in \SimpleNode$ to denote a typical node.
Let $\action : \SimpleNode \rightarrow \Action$ be a projection function for obtaining the actions of simple nodes, so that:
\begin{mathpar}
	\action((\ell,\andnode{\alpha})) = \alpha
	\and
	\action((\ell,\ornode{\alpha})) = \alpha
\end{mathpar}

\paragraph{Simple activities.} 
Let us now define \emph{simple activities}, which are essentially graphs consisting of simple nodes, as defined in the previous paragraph, that are connected via guarded edges.
The edge guards are (later) used to restrict when an edge can \emph{receive} a token.
During activity execution, any edge can only receive a token while the activity is in a state where the edge guard holds.
This is for example needed to define the semantics of UML decision nodes, of which an outgoing edge can only receive a token if its guard holds.

More formally, simple activities $\mathcal{A} = (\mathcal{N},\mathcal{E})$ are graphs with nodes $\mathcal{N} \subseteq \SimpleNode$ and edges $\mathcal{E} \subseteq \cramped{\mathcal{N} \times \Guard \times \mathcal{N}}$.
Any edge $\simpleedge \in \mathcal{E}$ so that $\simpleedge = (\simplenode,g,\simplenode')$ consists of a \emph{source node} $\simplenode \in \mathcal{N}$, a \emph{target node} $\simplenode' \in \mathcal{N}$ and a \emph{guard} $g \in \Guard$.
Let $\source : \mathcal{E} \rightarrow \mathcal{N}$, $\target : \mathcal{E} \rightarrow \mathcal{N}$ and $\guard : \mathcal{E} \rightarrow \Guard$ be projection functions to obtain the source, target, and guard of any edge, respectively.

We define the following shorthand notations for any $\simplenode \in \mathcal{N}$ and $\sigma \in \State$:
\begin{itemize}
	\item $\incoming(\simplenode) = \{ \simpleedge \in \mathcal{E} ~|~ \target(\simpleedge) = \simplenode \}$ be the set of all incoming edges of $\simplenode$.
	\item $\outgoing(\simplenode) = \{ \simpleedge \in \mathcal{E} ~|~ \source(\simpleedge) = \simplenode \}$ be the set of all outgoing edges of $\simplenode$.
	\item $\incoming(\simplenode,\sigma) = \{ \simpleedge \in \incoming(\eta) ~|~ \guard(\simpleedge)(\sigma) \}$ be all incoming edges of $\simplenode$ whose guard holds with respect to $\sigma$.
	\item $\outgoing(\simplenode,\sigma) = \{ \simpleedge \in \outgoing(\eta) ~|~ \guard(\simpleedge)(\sigma) \}$ be all outgoing edges of $\simplenode$ whose guard holds with respect to $\sigma$.
\end{itemize}

\subsection{Dynamics}
\label{sec:simpledynamics}

This section defines the dynamic behavior of simple activities, by means of a token passing style operational semantics.
Its reduction rules describe how to go from one configuration to another, where a configuration is essentially a set of edges holding a token together with a `current' state.
There are two reduction rules: one for $\andlabel$-style and one for $\orlabel$-style action execution, as explained earlier.
Finally, we introduce initial configurations and execution traces.

\paragraph{Configurations.}
The semantics of simple activities is essentially defined as a relation between \emph{configurations}, in the sense that an execution step in an activity gets you from one configuration to another configuration.
A configuration describes which edges currently hold a token, and what the current state is.

More formally, let $\Config = \cramped{2^\mathcal{E} \times \State}$ be the set of all configurations.
A configuration $(\Sigma, \sigma) \in \Config$ is a pair with $\Sigma \subseteq \mathcal{E}$ a set of edges---the ones currently holding a token---and $\sigma$ a `current' state.
We write $c \in \Config$ to denote a typical configuration, such that $c = (\Sigma, \sigma)$.

Any edge $\simpleedge$ is said to be \emph{enabled in $c$} if it has a token in $c$, i.e., if $\simpleedge \in \Sigma$.
If $c$ is clear from the context, we may just say that $\simpleedge$ is \emph{enabled}.
Note that edge guards control/restrict/regulate when an edge can \emph{receive} a token, as opposed to whether they can hold a token.

\paragraph{Reductions.}
Let us now define the operational semantics of simple activities, in token passing style.
The reduction rules of the operational semantics describe how edge tokens are distributed, and how state changes, while executing the nodes of the activity.
There are two reduction rules: one for $\andlabel$-style execution and one for $\orlabel$-style execution of actions.
As explained earlier, these rules only differ in their requirement on, and distribution of, edge tokens.

More formally, the operational semantics of simple activities $\mathcal{A} = (\mathcal{N},\mathcal{E})$ is defined in terms of labeled reduction rules $\rightarrow~\subseteq \cramped{\Config \times \mathcal{N} \times \Config}$.
The notation $c \xrightarrow{\simplenode} c'$ is used as shorthand for $(c, \simplenode, c') \in~\rightarrow$.
The two rules are:
\begin{mathpar}
	\inferrule[And] {
		\incoming(\simplenode) \subseteq \Sigma
		\\
		(\outgoing(\simplenode) \setminus \incoming(\simplenode)) \cap \Sigma = \emptyset
		\\
		\guard(\alpha)(\sigma)
		\\
		\sigma' \in \effects(\alpha)(\sigma)
		\\
		\outgoing(\simplenode) = \outgoing(\simplenode, \sigma')
	} {
		(\Sigma,\sigma) \xrightarrow{\simplenode} ((\Sigma \setminus \incoming(\simplenode)) \cup \outgoing(\simplenode),\sigma')
	} { 
		\text{ for } \simplenode = (\ell, \andnode{\alpha})
	}
	
	\inferrule[Or] {
		\simpleedge \in \incoming(\simplenode) \cap \Sigma
		\\
		\simpleedge' \in \outgoing(\simplenode, \sigma') \setminus (\Sigma \! \setminus \! \{\simpleedge\})
		\\
		\guard(\alpha)(\sigma)
		\\
		\sigma' \in \effects(\alpha)(\sigma)
	} {
		(\Sigma,\sigma) \xrightarrow{\simplenode} ((\Sigma \setminus \{\simpleedge\}) \cup \{\simpleedge'\}, \sigma')
	} { 
		\text{ for } \simplenode = (\ell, \ornode{\alpha})
	}
\end{mathpar}

The \textsc{And} rule defines the execution of $\andlabel$-type nodes $\simplenode$, for which $\action(\simplenode) = \andnode{\alpha}$.
\textsc{And} has five premises.
It requires: (1) all incoming edges into $\simplenode$ to have a token; (2) none of the outgoing edges of $\simplenode$ except self-loops to have a token, otherwise action execution might attempt to put more than one token on a single edge, which is not allowed; (3) the action guard $\guard(\alpha)$ to hold with respect to the current state $\sigma$; (4) a successor state $\sigma'$ to be available from the effects $\effects(\alpha)$ of $\alpha$; and (5) the guards of all outgoing edges to hold with respect to $\sigma'$.
If all five premises are met, \textsc{And} removes all tokens from $\incoming(\simplenode)$ and puts tokens on $\outgoing(\simplenode)$, making $\cramped{(\Sigma \setminus \incoming(\simplenode)) \cup \outgoing(\simplenode)}$ the new token arrangement.


The \textsc{Or} rule defines the execution of $\orlabel$-type nodes $\simplenode$, for which $\action(\simplenode) = \ornode{\alpha}$.
\textsc{Or} has four premises.
It requires: (1) the existence of an incoming edge $\simpleedge$ of $\simplenode$ that is enabled; (2) the existence of an outgoing edge $\simpleedge'$ of $\simplenode$ that is not enabled unless it equals $\simpleedge$, and whose guard holds with respect to $\sigma'$; (3) the guard of $\alpha$ to hold with respect to the current state $\sigma$; and (4) a successor state $\sigma'$ to be available from $\alpha$'s effects.
The \textsc{Or} rule allows multiple input edges to be enabled, but only one of them will participate per application of the \textsc{Or} rule.
Similarly, if multiple outgoing edges could potentially participate, one of them actually participates.
If all five premises are met, \textsc{Or} removes the token from $\simpleedge$ and puts it on $\simpleedge'$, making $\cramped{(\Sigma \setminus \{\simpleedge\}) \cup \{\simpleedge'\}}$ the new arrangement of tokens.

Finally, as a shorthand notation, we may write $c \xrightarrow{\alpha} c'$ if there exists an $\simplenode \in \mathcal{N}$ such that $c \xrightarrow{\simplenode} c'$ and $\action(\simplenode) = \alpha$.

\paragraph{Traces.}
\textsc{And} and \textsc{Or} describe single-step executions.
However, when executing or simulating an activity, typically multiple steps are performed, perhaps even infinitely many, leading to the concept of traces, i.e., sequences of steps.

Given any finite action sequence $\pi = \alpha_0 \alpha_1 \dots \alpha_m$ we write $c \xrightarrow{\pi}_{\ast} c'$ if there exists a reduction sequence $c_0 \xrightarrow{\alpha_0} c_1 \xrightarrow{\alpha_1} \dots \xrightarrow{\alpha_m} c_{m+1}$ such that $c = c_0$ and $c' = c_{m+1}$.
Moreover, given any infinite action sequence $\pi = \alpha_0 \alpha_1 \dots$ we write $c \xrightarrow{\pi}_{\omega}$ if there exists a reduction sequence $c_0 \xrightarrow{\alpha_0} c_1 \xrightarrow{\alpha_1} \dots$ where $c = c_0$.

\section{Concrete Activities}
\label{sec:concractivities}

This section defines concrete activities (\autoref{sec:concrstatics}) that more closely resemble UML activities than simple activities, and defines their operational semantics in terms of translations to simple activities (\autoref{sec:concrdynamics}).
\autoref{sec:concractivities:extensions} discusses how to deal with several extensions to concrete activities, like hierarchy and nonatomic actions.
Finally, some similarities and differences of concrete activities with respect to fUML semantics are highlighted (\autoref{sec:fuml}).

\subsection{Statics}
\label{sec:concrstatics}

First we define concrete activities, as a subset of UML activities.

\paragraph{Nodes.}
In contrast to simple nodes as defined earlier in \autoref{sec:simplestatics}, which come only in two flavours ($\andlabel$ and $\orlabel$), UML activities have many more flavours of activity nodes, like initial nodes, fork nodes, etc.
We focus on a basic subset of UML, leaving out more advanced concepts like signals, object flows, exception handlers, interruptible regions, etc.

Let $\ConcrNode = \cramped{\NodeID \times \ConcrNodeType}$ be the set of all \emph{concrete activity nodes}, consisting of an identifier and a (concrete) node type that is defined as:
$$\ConcrNodeType ::= \init ~|~ \final ~|~ \fork ~|~ \join ~|~ \decision ~|~ \merge ~|~ \act(\alpha)$$

We denote a typical activity node by $n \in \ConcrNode$.
Action-typed nodes $\act(\alpha)$ closely relate to opaque actions in UML in the sense that their execution updates the current state according to $\alpha$ (possibly nondeterministically so in case $\alpha$'s effects has multiple successor states to choose from).
The other node types are standard in UML: initial and final nodes ($\init$ and $\final$), fork and join nodes ($\fork$ and $\join$), and decision and merge nodes ($\decision$ and $\merge$)

\paragraph{Activities.}
Concrete activities $A = (N, E)$ are graphs with $N \subseteq \ConcrNode$ a set of concrete activity nodes and $E \subseteq N \times \Guard \times N$ a set of guarded edges.

Any number of additional well-formedness conditions may be imposed on activities, e.g., action nodes having exactly one incoming and outgoing edge, or final nodes not being allowed to have outgoing edges.
However, the semantics of activities, as defined in \autoref{sec:concrdynamics}, is not dependent on any such additional structural well-formedness conditions, making the semantics easier to define.

Moreover, note that all edges have guards, rather than just the ones coming out of decision nodes.
This is consistent with UML activities (except that, in UML, guards are ignored unless the edge comes out of a decision node).

\subsection{Dynamics}
\label{sec:concrdynamics}

We now define the operational semantics of concrete activities, by translating concrete activities to simple activities, and using the reduction rules defined earlier.
The advantage is that the semantics of the various concrete activity nodes can be defined by means of just two reduction rules: \textsc{And} and \textsc{Or}.

\paragraph{Node translation.}
First we translate activity nodes.
We do this by defining a translation function $\denotn{~\cdot~} : \ConcrNode \rightarrow \SimpleNode$ that translates concrete nodes to simple nodes.
To be able to define this translation function, we assume that the set $\Label$ of action labels is chosen in such a way to contain `reserved labels' for all concrete node types, so that $\ConcrNodeType \subseteq \Label$.

Let $\denotn{~\cdot~}$ be defined as follows, where $\lambda\sigma.\true$ is the constant guard that is always $\true$, and $\identity{\sigma}$ is the identity effects function that does not change the state:
\begin{mathpar}
	\denotn{(\ell, \init)} = (\ell,\ornode{(\init, \lambda\sigma.\true, \identity{\sigma})})
	\and
	\denotn{(\ell, \final)} = (\ell,\ornode{(\final, \lambda\sigma.\true, \identity{\sigma})})
	\and
	\denotn{(\ell, \fork)} = (\ell, \andnode{(\fork, \lambda\sigma.\true, \identity{\sigma})})
	\and
	\denotn{(\ell, \join)} = (\ell, \andnode{(\join, \lambda\sigma.\true, \identity{\sigma})})
	\and
	\denotn{(\ell, \decision)} = (\ell, \ornode{(\decision, \lambda\sigma.\true, \identity{\sigma})})
	\and
	\denotn{(\ell, \merge)} = (\ell, \ornode{(\merge, \lambda\sigma.\true, \identity{\sigma})})
	\\
	\denotn{(\ell, \act(\alpha))} = (\ell, \andnode{\alpha})
\end{mathpar}

This translation function maps concrete nodes to either $\andlabel$-typed or $\orlabel$-typed simple nodes, where the type determines the execution semantics.

Initial nodes ($\init$) are translated as $\orlabel$-type nodes, since they typically do not have incoming edges, and in case they have multiple outgoing edges, one of them is followed.
In fUML semantics, when firing an initial node, a single token is created and offered to all outgoing edges, and exactly one of those edges then gets this token (\cite{fUMLSemantics}, page 221).
Final nodes ($\final$) are translated likewise to initial nodes: they typically do not have outgoing edges, and in case they have multiple incoming edges, it is sufficient that one of them is enabled.
In fUML semantics, when firing a final node, all incoming tokens are consumed  (\cite{fUMLSemantics}, page 218).
Note that executing a final node does not mean that all edge tokens in an activity will disappear.
For example, it may be possible that a final node is being executed while there are still tokens at other (forked) parts of the activity.
In such cases, the execution of the final node will not mean that these other tokens dissapear.
In other words, the execution of a final node does not necessarily mean that the activity is done executing.
In case there are still tokens left, execution may resume.

Fork nodes ($\fork$) are translated to $\andlabel$-typed nodes: their execution requires all incoming edges (usually just one) to be enabled, and puts a token on all outgoing edges (usually more than one).
In fUML semantics, when firing a fork node, tokens are consumed from all incoming edges and offered to all outgoing edges (\cite{fUMLSemantics}, page 218--220).
Join nodes ($\join$) are executed likewise to fork nodes: their executions requires all incoming edges (usually multiple) to be enabled and puts a token on all outgoing edges (usually just one).
In fUML semantics, join nodes can only fire when all incoming edges have tokens (\cite{fUMLSemantics}, page 222).

Decision nodes ($\decision$) are translated as $\orlabel$-typed nodes, as their execution requires a single incoming edge (usually there is only one) to be enabled and nondeterministically chooses a single outgoing edge whose guard holds to receive a token.
In fUML semantics, when firing a decision node, a token is offered to all outgoing edges whose guard holds\footnote{The actual description as given in~\cite{fUMLSemantics} is slightly more complex, since it involves decision input flows that supply extra values to decision nodes (e.g., object flows), which somehow are used as tokens. However, this is the gist of it.} (\cite{fUMLSemantics}, page 213). 
Merge nodes ($\merge$) are translated similarly: their execution requires a single incoming edge (usually multiple) to be enabled, and puts a token on one outgoing edge (usually there is one).
The description of the semantics of merge nodes in~\cite{fUMLSemantics} is not super clear.

Finally, action nodes are translated as $\andlabel$-typed nodes.
This is consistent with fUML semantics which describes that, once action execution has completed, “a control token is offered on all control flows outgoing from the action”~(\cite{fUMLSemantics}, page 267).
Moreover, in case of fUML action nodes “the semantics of the offering of a token on control flows outgoing from an action are those of an implicit fork”~(\cite{fUMLSemantics}, page 267).

Appendix A of~\cite{DawC2015} shows how more complex behavior of UML activities can be defined in terms of $\andlabel$ and $\orlabel$ nodes, covering also other node types like `send' and `accept' nodes, which are out of scope for the purpose of this document.

\paragraph{Edge translation.}
The translation of edges is straightforward, and simply amounts to translating the source and target node.
Let $\denote{~\cdot~} : \ConcrNode \times \Guard \times \ConcrNode \rightarrow \SimpleNode \times \Guard \times \SimpleNode$ be the translation function for edges, defined such that
$\denote{(n,g,n')} = (\denotn{n},g, \denotn{n'})$.

\paragraph{Activity semantics.}
Now that we can translate the nodes and edges of concrete activities, let us combine these translations.
Let the translation of any concrete activity $A = (N,E)$ be defined as $\denot{A} = (\{ \denotn{n} ~|~ n \in N \}, \{ \denote{e} ~|~ e \in E \})$.
Then the semantics of $A$ is defined to be the semantics of $\denot{A}$.

\paragraph{Initial configuration.}
Obviously, any execution of an activity requires some starting point.
In other words, since activity execution describes how to go from one configuration to another, there has to be a notion of an initial configuration.

The starting point of executing concrete activities are their $\init$ nodes.
Since initial nodes are translated to $\orlabel$-type nodes, the execution of an activity is started along exactly one outgoing edge of a (single) $\init$ node.
In case an activity has multiple initial nodes, or in case there are initial nodes with multiple outgoing edges, the activity has multiple potential initial configurations.
In esoteric cases, an activity might have no initial configurations in case there are no initial nodes, or in case there are only initial nodes without outgoing edges.

Let $A = (N,E)$ be an activity.
Then $(\{\simpleedge\}, \sigma_I) \in \Config$ is defined to be an \emph{initial configuration of $A$} for any choice of initial state $\sigma_I \in \State$, if there exists an initial node $(\ell, \init) \in N$ such that $\simpleedge \in \outgoing(\denotn{(\ell, \init)},\sigma_I)$.
In other words, any outgoing edge of any initial node can form an initial configuration together with some initial state $\sigma_I$, given that this edge is allowed by its guard to receive an (initial) token in the initial state $\sigma_I$.
This initial state $\sigma_I$ could for example be chosen to be the initial valuation of all variables defined in the context of $A$.
Recall that the current definitions abstract over details like variables and their values\footnote{We are not going to define a custom expression/effects language and its semantics. There are plenty of good existing languages that could be picked off-the-shelf, like for example CIF.}.
The formalization could later be instantiated with such details.

\subsection{Extensions}
\label{sec:concractivities:extensions}

Let us now discuss several extensions to the activities as defined so far.

\paragraph{Hierarchy.}
We may want to use activities in a \emph{hierarchical} manner, to allow larger activity specifications to be composed out of smaller ones.
With hierarchy we then mean allowing activities to call other activities by means of \emph{call actions}.

To support call actions, we first have to take into account that activities are defined and executed in a broader context, namely together with a number of contextual activities, $A_0,\dots,A_n$, that may be called.
Then we would have to extend activities by an additional type, $\ConcrNodeType ::= \cdots~|~\textsf{call}(\imath)$, where $\imath \in \{0,\dots,n\}$ is a reference to one of those contextual activities to call.

We disallow (in)direct recursion of action calls, i.e., we disallow the underlying call graph to contain cycles, so that hierarchy is maintained.
By doing so, the extended activities can be \emph{flattened} into single activities without any $\textsf{call}$ actions by inlining any activity being called.
The semantics of these extended hierarhical activities is then defined to be the semantics of the flattened activity.

\paragraph{Nonatomic actions.}
The execution semantics of activities is defined as a single-step reduction relation, meaning that actions are executed atomically.
Nevertheless, in reality, actions may not always be atomic.
For example, an action could be the movement of a robot.
The implication of considering this to be an atomic action, is that nothing can happen while the robot is moving.
Hence, considering actions to always be atomic may sometimes be too strict.

We can support \emph{nonatomic actions} by splitting them into two actions which are atomic: one for starting the nonatomic action and one for ending it.
Elaborating further on that, let $\alpha \in \Action$ be an action that we want to execute nonatomically, so that $\alpha = (a, g, u)$.
Then we can `split' $\alpha$ and $a$ into two actions: $\alpha_{\mathit{start}} = (a_{\mathit{start}}, g, \identity{\sigma})$ and $\alpha_{\mathit{end}} = (a_{\mathit{end}}, \lambda\sigma.\true, u)$.
Finally, any activity node for executing $\alpha$ can be replaced by a node that executes $\alpha_{\mathit{start}}$, followed by a node that executes $\alpha_{\mathit{end}}$ with an edge between them.
Alternatively, one might also exploit hierarchy (as described above) by modeling a nonatomic action as a separate activity that starts by doing $\alpha_{\mathit{start}}$, and then ends by doing $\alpha_{\mathit{end}}$.
If needed, it is possible to extend $\ConcrNodeType$ by an additional type for nonatomic action nodes, like done for call actions as described above.
In that case, one could eliminate such extensions like done for call actions.

\subsection{Similarities and differences with fUML}
\label{sec:fuml}

Below is a list of similarities and differences with respect to fUML semantics:
\begin{itemize}
	\item Nodes of type $\act(\alpha)$ roughly correspond to opaque actions in UML.
	However, opaque actions in UML do not have guards nor effects.
	This is something we added to $\alpha$ in our definition of activities.
	\item Our definition of activities imposes a \emph{waiting semantics}, meaning that execution of some action $\alpha$ `waits' until $\guard(\alpha)$ holds, and likewise for edge guards.
	In fUML, action nodes are not guarded and do not have a waiting semantics.
	Instead of waiting, in fUML, the activity typically terminates whenever a state is encountered in which no immediate progress can be made, e.g., in case of decision nodes where none of the outgoing edges can be taken.
	\item Nodes of type $\act(\alpha)$ execute \emph{atomically}.
	In particular, this means that $\effects(\alpha)$ is executed without interference from effects of other nodes.
	In fUML atomicity is not guaranteed.
	Instead, fUML semantics only guarantees that nodes in-between a fork and a join are executed after forking and before joining.
	\item In fUML the edges out of decision nodes have a declaration order, and the first enabled edge in the declaration order is taken\footnote{We could not directly find this clearly stated in~\cite{fUMLSemantics}. However, this is how the Cameo simulator handles decision nodes, and it claims to implement fUML semantics. Therefore, we assume that this statement is true in fUML.}.
	Moreover, if none of the edges can be taken, the activity terminates (or rather crashes).
	Instead, in our version of activities, a nondeterministic choice is made among all enabled edges out of decision nodes.
	In case none of the edges are enabled, a waiting semantics is imposed, as described earlier.
	\item The execution of $\final$ nodes as defined in this document is different from fUML.
	As explained in \autoref{sec:concrdynamics}, final nodes are translated to $\orlabel$-type activity nodes, which means that only a single incoming edge should be enabled for the node to fire, and when this happens, only a single token will be consumed.
	In fUML however, all tokens on enabled incoming edges will be consumed.
	The implication is that, in our semantics, $\final$ nodes may have to fire multiple times in case multiple incoming edges are enabled, to consume all their tokens.
	One might consider whether it is not better to translate $\final$ nodes to $\andlabel$-type nodes instead.
	However, such a translation would mean that all incoming edges into $\final$ must be enabled, which is in a way even more different from fUML semantics.
\end{itemize}

\bibliographystyle{plain}
\bibliography{refs}

\newpage

\appendix

\section*{Appendix A: List of Symbols}

\begin{tabular}{cl}
	$\action$ & projection function for getting the action of an activity node \\
	$\mathcal{A}$ & A simple activity \\
	$A$ & A concrete (UML-like) activity \\
	$a$ & An action label \\
	$\alpha$ & An action, consisting of an action label, a guard and an effects function \\
	$\andnode{\alpha}$ & A simple node type describing an $\andlabel$-style execution of $\alpha$ \\
	$\textsf{call}$ & A call action node (extension) \\
	$\Config$ & The set of all configurations \\
	$\ConcrNode$ & The set of all concrete activity nodes \\
	$\ConcrNodeType$ & The set of all concrete activity node types \\
	$c$ & A configuration, consisting of a set of edges holding a token, and a state \\
	$\denote{~\cdot~}$ & Operation for translating concrete activity edges to simple ones \\
	$\denotn{~\cdot~}$ & Operation for translating concrete activity nodes to simple ones \\
	$\decision$ & The decision node type of concrete activities \\
	$\Effects$ & The set of all effects functions \\
	$\effects$ & Projection function for obtaining the effects of an action \\
	$\mathcal{E}$ & A set of simple edges of a simple activity \\
	$E$ & A set of concrete edges of a concrete (UML-like) activity \\
	$\simpleedge$ & A simple edge of a simple activity \\
	$e$ & A concrete edge of a concrete activity \\
	$\final$ & The final node type of concrete activities \\
	$\fork$ & The fork node type of concrete activities \\
	$\Guard$ & The set of all guards \\
	$\guard$ & Projection function for obtaining the guard of an action \\
	$g$ & A guard, which is a state predicate \\
	$\ell$ & A node identifier, used to give identity to simple and concrete activity nodes \\
	$\incoming$ & Function for getting all incoming edges of a node \\
	$\init$ & The initial node type of concrete activities \\
	$\Label$ & The set of all action labels \\
	$\actlabel$ & Projection function for obtaining the action label of an action \\
	$\join$ & The join node type of concrete activities \\
	$\merge$ & The merge node type of concrete activities \\
	$\NodeID$ & The set of all node identifiers \\
	$\mathcal{N}$ & A set of simple nodes of a simple activity \\
	$N$ & A set of concrete nodes of a concrete (UML-like) activity \\
	$\simplenode$ & A simple node of a simple activity \\
	$n$ & A concrete node of a concrete activity
\end{tabular}

\begin{tabular}{cl}
	$\ornode{\alpha}$ & A simple node type describing an $\orlabel$-style execution of $\alpha$ \\
	$\pi$ & A trace, i.e., a sequence of actions \\
	$\SimpleNode$ & The set of all simple activity nodes \\
	$\SimpleNodeType$ & The set of all simple activity node types \\
	$\Sigma$ & A set of simple edges holding a token, as part of a configuration \\
	$\sigma$ & An (execution) state, e.g., the valuation of some set of variables \\
	$\source$ & Projection function for getting the source node of an edge \\
	$\State$ & The set of all states \\
	$\target$ & Projection function for getting the target node of an edge \\
	$\outgoing$ & Function for getting all outgoing edges of a node \\
	$u$ & An effects function, mapping a state to zero or more successor states \\
	$\rightarrow$ & Reduction relation defining the semantics of simple activities \\
	$\xrightarrow{\alpha}$ & Reduction relation for a simple node with action $\alpha$ \\
	$\xrightarrow{\simplenode}$ & Reduction relation for a simple node $\simplenode$ \\
	$\xrightarrow{\pi}_{\ast}$ & Multi-step reduction relation for the finite action sequence $\pi$ \\
	$\xrightarrow{\pi}_{\omega}$ & Multi-step reduction relation for the infinite action sequence $\pi$
\end{tabular}

\end{document}
