
package com.github.tno.pokayoke.transform.app;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.AnnotationEqHashWrap;
import org.eclipse.escet.cif.common.CifEdgeUtils;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.eventbased.automata.AutomatonHelper;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Edge;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;

import com.github.tno.pokayoke.transform.activitysynthesis.CifLocationHelper;
import com.google.common.base.Verify;

/**
 * Weak trace equivalence checker of two CIF models that considers state annotations. The two models must contain a
 * single automaton, and have a compatible alphabet. Alphabets are compatible when they have the same number of events,
 * with possibly different names. Assumes the two models are generated by the CIF state space exploration.
 */
public class StateAwareWeakTraceEquivalenceChecker {
    /**
     * Checks whether two CIF state space automata are weak-trace equivalent, considering state annotations.
     *
     * @param automaton1 The first CIF automaton.
     * @param stateAnnotations1 The map from CIF states to their projected state annotations, for the first model. The
     *     state annotations contain solely the relevant information used for comparison of the model states.
     * @param epsilonEvents1 The set containing events that represent an epsilon transition for the first model.
     * @param automaton2 The second CIF automaton.
     * @param stateAnnotations2 The map from CIF states to their projected state annotations, for the second model. The
     *     state annotations contain solely the relevant information used for comparison of the model states.
     * @param epsilonEvents2 The set containing events that represent an epsilon transition for the second model.
     * @param pairedEvents The set containing pairs of corresponding (lists of) events for the two automata. All events
     *     in the first list of events are equivalent to all the events in the second list of events.
     * @return {@code true} if the two automata are language equivalent, {@code false} otherwise.
     */
    public boolean check(Automaton automaton1, Map<Location, Annotation> stateAnnotations1, Set<Event> epsilonEvents1,
            Automaton automaton2, Map<Location, Annotation> stateAnnotations2, Set<Event> epsilonEvents2,
            Set<Pair<List<Event>, List<Event>>> pairedEvents)
    {
        // Sanity check: epsilon events and non-epsilon events must be disjoint.
        Verify.verify(areDisjointEventSets(
                pairedEvents.stream().flatMap(p -> p.getLeft().stream()).collect(Collectors.toSet()), epsilonEvents1));
        Verify.verify(areDisjointEventSets(
                pairedEvents.stream().flatMap(p -> p.getRight().stream()).collect(Collectors.toSet()), epsilonEvents2));

        // Sanity check: marked states should not have outgoing edges. Computes the set of marked locations.
        Set<Location> markedStates1 = new LinkedHashSet<>();
        Set<Location> markedStates2 = new LinkedHashSet<>();
        Verify.verify(!markedStatesHaveOutgoingEdges(automaton1, markedStates1),
                "Automaton 1 has outgoing edges from marked states.");
        Verify.verify(!markedStatesHaveOutgoingEdges(automaton2, markedStates2),
                "Automaton 2 has outgoing edges from marked states.");

        // Sanity check: all states should be able to reach a marked state (be non-blocking).
        Map<Location, Set<Edge>> stateToIncomingEdges1 = computeIncomingEdgesPerState(automaton1);
        Map<Location, Set<Edge>> stateToIncomingEdges2 = computeIncomingEdgesPerState(automaton2);
        Verify.verify(getBlockingStatesCount(automaton1, markedStates1, stateToIncomingEdges1) == 0,
                "Model 1 contains blocking states.");
        Verify.verify(getBlockingStatesCount(automaton2, markedStates2, stateToIncomingEdges2) == 0,
                "Model 2 contains blocking states.");

        // Initialize queue. If null, the models are not equivalent.
        Queue<Pair<Set<Location>, Set<Location>>> queue = initializeQueue(automaton1, stateAnnotations1, automaton2,
                stateAnnotations2);
        if (queue == null) {
            return false;
        }

        Set<Pair<Set<Location>, Set<Location>>> visitedPairs = new LinkedHashSet<>();
        visitedPairs.addAll(queue);

        // Get absolute names of epsilon events.
        Set<String> absNamesEpsEvents1 = epsilonEvents1.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesEpsEvents2 = epsilonEvents2.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        while (!queue.isEmpty()) {
            // Pop first element of the queue.
            Pair<Set<Location>, Set<Location>> currentPair = queue.remove();

            // Compute epsilon-reachable states from the current pair.
            Set<Location> epsilonReachableStates1 = getEpsilonReachableStates(currentPair.getLeft(),
                    absNamesEpsEvents1);
            Set<Location> epsilonReachableStates2 = getEpsilonReachableStates(currentPair.getRight(),
                    absNamesEpsEvents2);

            // Sanity check: the states should represent the same external state, since epsilon transitions may only
            // change internal state.
            Verify.verify(areAllEquivalent(epsilonReachableStates1, stateAnnotations1),
                    "Epsilon reachability found multiple external states.");
            Verify.verify(areAllEquivalent(epsilonReachableStates2, stateAnnotations2),
                    "Epsilon reachability found multiple external states.");

            // Check if any epsilon reachable state is marked, for both automata.
            boolean anyMarked1 = epsilonReachableStates1.stream().anyMatch(markedStates1::contains);
            boolean anyMarked2 = epsilonReachableStates2.stream().anyMatch(markedStates2::contains);
            if (anyMarked1 != anyMarked2) {
                return false;
            }

            // Check that the pair of sets of epsilon reached states is equivalent.
            if (!areEquivalentStates((new ArrayList<>(epsilonReachableStates1)).get(0), stateAnnotations1,
                    (new ArrayList<>(epsilonReachableStates2)).get(0), stateAnnotations2))
            {
                return false;
            }

            // The pair of states is equivalent. Check also all pairs of states reachable from this pair.
            for (Pair<List<Event>, List<Event>> events: pairedEvents) {
                Set<Location> targetStates1 = getNextStates(epsilonReachableStates1, events.getLeft());
                Set<Location> targetStates2 = getNextStates(epsilonReachableStates2, events.getRight());

                // If one set of states can reach some target with this action, but the other set cannot reach any,
                // the two models are different. Note that this is different from checking the sizes of the target
                // sets, which can be different. This works only if the size of one is zero while the size of the
                // other is not zero.
                if (targetStates1.isEmpty() != targetStates2.isEmpty()) {
                    return false;
                } else if (targetStates1.size() > 0) {
                    // Add the next pair to the queue, if not already visited.
                    Pair<Set<Location>, Set<Location>> nextPair = Pair.of(targetStates1, targetStates2);
                    if (!visitedPairs.contains(nextPair)) {
                        visitedPairs.add(nextPair);
                        queue.add(nextPair);
                    }
                }
            }
        }

        return true;
    }

    private boolean areDisjointEventSets(Set<Event> set1, Set<Event> set2) {
        Set<String> absNamesEventsSet1 = set1.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
        Set<String> absNamesEventsSet2 = set2.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());

        for (String name: absNamesEventsSet2) {
            if (absNamesEventsSet1.contains(name)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Compute the set of marked states and checks whether any marked state has outgoing edges.
     *
     * @param automa The automaton to check.
     * @param markedStates The set containing marked states, modified in-place.
     * @return {@code true} if any marked state has outgoing edges, {@code false} otherwise.
     */
    private boolean markedStatesHaveOutgoingEdges(Automaton automa, Set<Location> markedStates) {
        boolean hasOutgoing = false;
        for (Location state: automa.getLocations()) {
            if (CifLocationHelper.isMarked(state)) {
                markedStates.add(state);
                if (!state.getEdges().isEmpty()) {
                    hasOutgoing = true;
                }
            }
        }
        return hasOutgoing;
    }

    private Map<Location, Set<Edge>> computeIncomingEdgesPerState(Automaton automa) {
        Map<Location, Set<Edge>> stateToIncomingEdge = new LinkedHashMap<>();
        for (Location state: automa.getLocations()) {
            stateToIncomingEdge.computeIfAbsent(state, k -> new LinkedHashSet<>());
            for (Edge edge: state.getEdges()) {
                stateToIncomingEdge.computeIfAbsent(CifEdgeUtils.getTarget(edge), k -> new LinkedHashSet<>()).add(edge);
            }
        }
        return stateToIncomingEdge;
    }

    /**
     * Find non-blocking states and the number of blocking states in an automaton. See also
     * {@link AutomatonHelper#getNonCoreachableCount}.
     *
     * @param automa Automaton to search.
     * @param markedStates The set of marked states of the automaton.
     * @param stateToIncomingEdges The map from states to their incoming edges.
     * @return The number of blocking states in the automaton.
     */
    public static int getBlockingStatesCount(Automaton automa, Set<Location> markedStates,
            Map<Location, Set<Edge>> stateToIncomingEdges)
    {
        Queue<Location> toExpand = new ArrayDeque<>(1000);
        Set<Location> nonblocking = new LinkedHashSet<>();

        // Add all marked states.
        int stateCount = automa.getLocations().size();
        toExpand.addAll(markedStates);
        nonblocking.addAll(markedStates);

        // Expand the marked states to all non-blocking states.
        while (!toExpand.isEmpty()) {
            Location state = toExpand.remove();
            for (Edge incomingEdge: stateToIncomingEdges.get(state)) {
                Location edgeSource = CifEdgeUtils.getSource(incomingEdge);
                if (nonblocking.add(edgeSource)) {
                    toExpand.add(edgeSource);
                }
            }
        }
        return stateCount - nonblocking.size();
    }

    private Queue<Pair<Set<Location>, Set<Location>>> initializeQueue(Automaton automaton1,
            Map<Location, Annotation> annotations1, Automaton automaton2, Map<Location, Annotation> annotations2)
    {
        Queue<Pair<Set<Location>, Set<Location>>> queue = new LinkedList<>();

        // Find initial states of the first automaton.
        Set<Location> initialStates1 = new LinkedHashSet<>();
        for (Location state: automaton1.getLocations()) {
            if (CifLocationHelper.isInitial(state)) {
                initialStates1.add(state);
            }
        }

        // Find initial states of the second automaton.
        Set<Location> initialStates2 = new LinkedHashSet<>();
        for (Location state: automaton2.getLocations()) {
            if (CifLocationHelper.isInitial(state)) {
                initialStates2.add(state);
            }
        }

        // Loop over all initial states of the two automata, find the equivalent ones (i.e. have the same annotations),
        // and pair them together.
        Set<Location> visited = new LinkedHashSet<>();
        for (Location state1: initialStates1) {
            for (Location state2: initialStates2) {
                if (areEquivalentStates(state1, annotations1, state2, annotations2)) {
                    queue.add(Pair.of(Set.of(state1), Set.of(state2)));
                    visited.add(state1);
                    visited.add(state2);
                }
            }
        }

        // All initial states must be used in some initial pair. If not, return null.
        if (visited.size() == initialStates1.size() + initialStates2.size()) {
            return queue;
        } else {
            return null;
        }
    }

    private boolean areEquivalentStates(Location state1, Map<Location, Annotation> stateAnnotations1, Location state2,
            Map<Location, Annotation> stateAnnotations2)
    {
        // States are equivalent if their annotations are equivalent.
        return areEquivalentAnnotations(stateAnnotations1.get(state1), stateAnnotations2.get(state2));
    }

    private boolean areEquivalentAnnotations(Annotation ann1, Annotation ann2) {
        AnnotationEqHashWrap annotationWrapped1 = new AnnotationEqHashWrap(ann1);
        AnnotationEqHashWrap annotationWrapped2 = new AnnotationEqHashWrap(ann2);
        return annotationWrapped1.equals(annotationWrapped2);
    }

    private Set<Location> getEpsilonReachableStates(Set<Location> states, Set<String> epsilonEvents) {
        Set<Location> visited = new LinkedHashSet<>(states);
        Queue<Location> queue = new LinkedList<>(states);

        while (!queue.isEmpty()) {
            Location currentState = queue.remove();

            for (Edge edge: currentState.getEdges()) {
                Set<Event> eventsOnEdge = CifEventUtils.getEvents(edge);
                for (Event eventOnEdge: eventsOnEdge) {
                    if (epsilonEvents.contains(CifTextUtils.getAbsName(eventOnEdge))) {
                        // Add target state if not yet visited.
                        Location target = CifEdgeUtils.getTarget(edge);
                        if (!visited.contains(target)) {
                            queue.add(target);
                            visited.add(target);
                        }
                    }
                }
            }
        }
        return visited;
    }

    private boolean areAllEquivalent(Set<Location> states, Map<Location, Annotation> stateAnnotations) {
        // Find if the states of the set are all equivalent. Pick the first state, and compare it to all the others: if
        // there is one non-equivalent state, return false.
        List<Location> statesList = new ArrayList<>(states);
        Annotation firstStateAnnotation = stateAnnotations.get(statesList.get(0));

        for (int i = 1; i < statesList.size(); i++) {
            if (!areEquivalentAnnotations(firstStateAnnotation, stateAnnotations.get(statesList.get(i)))) {
                return false;
            }
        }
        return true;
    }

    private Set<Location> getNextStates(Set<Location> sourceStates, List<Event> events) {
        Set<String> eventsAbsNames = events.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
        LinkedHashSet<Location> targetStates = new LinkedHashSet<>();

        for (Location state: sourceStates) {
            for (Edge edge: state.getEdges()) {
                Set<Event> eventsOnEdge = CifEventUtils.getEvents(edge);
                for (Event event: eventsOnEdge) {
                    // Comparison is by name, since the events might be different object.
                    if (eventsAbsNames.contains(CifTextUtils.getAbsName(event))) {
                        targetStates.add(CifEdgeUtils.getTarget(edge));
                    }
                }
            }
        }
        return targetStates;
    }
}
