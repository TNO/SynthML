\documentclass{article}

% Packages.
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[english]{babel}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{mathpar}
\usepackage{mathtools}

% Color of comments in algorithms.
\newcommand{\commfont}[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{commfont}

% Keywords in algorithms.
\SetKwFunction{synthAll}{synthesize-all}
\SetKwFunction{synthSingle}{synthesize-single}
\SetKwProg{procedure}{procedure}{}{}
\SetKw{KwEveryAbstrActivity}{every abstract activity}
\SetKw{KwReplace}{replace}
\SetKw{KwBy}{by}
\SetKw{KwIn}{in}

% Redefine reference names for \autoref.
\addto\extrasenglish{\renewcommand{\algorithmautorefname}{Algorithm}}
\addto\extrasenglish{\renewcommand{\sectionautorefname}{Section}}
\addto\extrasenglish{\renewcommand{\subsectionautorefname}{Section}}
\addto\extrasenglish{\renewcommand{\subsubsectionautorefname}{Section}}

% Convenient auxiliary commands.
\newcommand{\keyw}[1]{\texttt{#1}}
\newcommand{\var}[1]{\ensuremath{\mathit{#1}}}

% Activity synthesis steps.
\newcommand{\transformUmlToCifLabel}[0]{\keyw{transform-uml-to-cif}}
\newcommand{\dataBasedSynthesisLabel}[0]{\keyw{data-based-synthesis}}
\newcommand{\generateStatespaceLabel}[0]{\keyw{generate-statespace}}
\newcommand{\ensureSingleSourceAndSinkLabel}[0]{\keyw{ensure-single-source-and-sink}}
\newcommand{\eventBasedProjectionLabel}[0]{\keyw{event-based-projection}}
\newcommand{\dfaMinimizationLabel}[0]{\keyw{dfa-minimization}}
\newcommand{\petrinetSynthesisLabel}[0]{\keyw{petrinet-synthesis}}
\newcommand{\transformToActivityLabel}[0]{\keyw{transform-to-activity}}
\newcommand{\reduceNonAtomicPatternsLabel}[0]{\keyw{reduce-non-atomic-patterns}}
\newcommand{\computeEdgeGuardsLabel}[0]{\keyw{compute-edge-guards}}
\newcommand{\postprocessActivityLabel}[0]{\keyw{postprocess-activity}}

\newcommand{\transformUmlToCif}[1]{\transformUmlToCifLabel(\ensuremath{#1})}
\newcommand{\dataBasedSynthesis}[1]{\dataBasedSynthesisLabel(\ensuremath{#1})}
\newcommand{\generateStatespace}[1]{\generateStatespaceLabel(\ensuremath{#1})}
\newcommand{\ensureSingleSourceAndSink}[1]{\ensureSingleSourceAndSinkLabel(\ensuremath{#1})}
\newcommand{\eventBasedProjection}[1]{\eventBasedProjectionLabel(\ensuremath{#1})}
\newcommand{\dfaMinimization}[1]{\dfaMinimizationLabel(\ensuremath{#1})}
\newcommand{\petrinetSynthesis}[1]{\petrinetSynthesisLabel(\ensuremath{#1})}
\newcommand{\transformToActivity}[1]{\transformToActivityLabel(\ensuremath{#1})}
\newcommand{\reduceNonAtomicPatterns}[1]{\reduceNonAtomicPatternsLabel(\ensuremath{#1})}
\newcommand{\computeEdgeGuards}[1]{\computeEdgeGuardsLabel(\ensuremath{#1})}
\newcommand{\postprocessActivity}[1]{\postprocessActivityLabel(\ensuremath{#1})}

\newcommand{\doneLabel}[0]{\texttt{\_\_done}}
\newcommand{\initLabel}[0]{\texttt{\_\_init}}
\newcommand{\loopLabel}[0]{\texttt{\_\_loop}}
\newcommand{\startLabel}[0]{\texttt{\_\_start}}
\newcommand{\stopLabel}[0]{\texttt{\_\_end}} % Note: the command name \endLabel cannot be used since \end seems reserved.
\newcommand{\toLabel}[0]{\texttt{\_\_to\_\_}}
\newcommand{\tauLabel}[0]{\texttt{\_\_tau}}

\title{Synthesis of Poka Yoke Activity Diagrams}

\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

This document describes the Poka Yoke activity synthesis algorithm and discusses its internal steps.
This document does not explain  what the code implementation of the algorithm is doing exactly in full detail.
Instead, it explains more abstractly what the different steps are conceptually, why they are needed, and what they require and ensure.
Therefore, the explanation may sometimes deviate slightly from how the code implementation is organized, and may sometimes be more abstract.
This document is intended to be a living document, to be extended continuously while further developing the synthesis algorithm.

The remainder of this document is organized as follows.
\autoref{sec:prelims} gives preliminaries for understanding the activity synthesis algorithm, in particular the formalisms and tools that are involved.
\autoref{sec:algorithm} discusses the activity synthesis algorithm.
First a high-level overview of the algorithm is given, and then its steps are discussed in more detail.

\section{Preliminaries}
\label{sec:prelims}

\subsection{Formalisms}
\label{sec:prelims:formalisms}

The activity synthesis algorithm deals with various different formalisms that each have their own terminology.
A high-level overview is presented below.

\begin{description}
	\item[Finite automata.]
	Finite automata are finite directed graphs consisting of \emph{locations}, and \emph{edges} that are labeled with an \emph{event}.
	Locations can be \emph{initial} when they are `starting' locations.
	Locations can also be \emph{marked} when they are accepting locations, with the standard meaning of acceptance from automata theory.
	
	A deterministic finite automaton (DFA) is a finite automaton that is deterministic.
	Any finite automaton that is nondeterministic is a nondeterministic finite automaton (NFA).
	
	Rather than a single DFA or NFA, we typically consider multiple automata that interact, e.g., by means of synchronizing events.
	We will not give a full introduction of all these concepts here.
	
	\item[Extended finite automata (EFA).]
	EFAs are finite automata that are used in the presence of \emph{data (properties)}, i.e., variables that have a value.
	The \emph{(execution) state} of an EFA typically refers to the current valuation of all data properties, plus the locations that are currently active.
	
	The edges of EFAs have \emph{guards} which are state predicates, as well as \emph{updates} which are state transformers.
	Semantically, an edge can be taken when its guard holds with respect to the state of the EFA are the current execution point, and this state is then updated (transformed) according to the edge update.
	
	\item[UML models and activities.]
	For our purposes we use a subset of the UML2 metamodel\footnote{See \url{https://www.omg.org/spec/UML/2.5.1} (Accessed 2024-08-28) for the full UML2 specification.}.
	In our restricted scope, UML models consist of any number of UML enum declarations, and exactly one UML class.
	A UML class contains:
	\begin{itemize}
		\item Any number of UML properties.
		UML properties have a type and optionally a default value.
		There are three supported types: Booleans, bounded integers, and enums.
		Default property values are then expressions of the appropriate type.
		\item Any number of UML opaque behaviors that have exactly one \emph{guard} and zero or more \emph{effects}.
		These opaque behaviors model \emph{actions} to be performed in synthesized UML activities.
		Likewise to EFAs, action guards are state predicates, and action updates are state transformers, both of which are expressed over the UML properties as defined in the UML model.
		Moreover:
		\begin{itemize}
			\item Any action is either deterministic or nondeterministic.
			An action is defined to be \emph{deterministic} if the action has at most one effect.
			An action that is not deterministic is defined to be \emph{nondeterministic}.
			The execution semantics of nondeterministic actions is that by executing the action, one of its effects is nondeterministically chosen and executed.
			\item Any action is either atomic or nonatomic.
			The atomicity of an action can be indicated in UML Designer via a checkbox in the Properties view.
			If an action is indicated to be \emph{atomic}, then no other actions can be performed during the execution of the atomic action.
			If an action is indicated to be \emph{nonatomic}, then other actions may be performed in-between the start and end of the nonatomic action.
			A nonatomic action can only be started when its guard holds, and the effects of a nondeterministic action are applied when the action ends.
		\end{itemize}
		\item Any number of UML constraints that model the requirements for synthesis.
		A UML constraint can be a state invariant that is expressed over the UML properties in the UML model.
		A UML constraint can also be an action exclusion invariant, which indicates that the execution of some action requires the system to be in a certain state as expressed by a state invariant.
		\item Any number of UML activities, which can either be \emph{abstract} or \emph{concrete}.
		\begin{itemize}
			\item An abstract UML activity consists of preconditions, postconditions, and occurrence constraints.
			The preconditions and postconditions are state invariants that are expressed over the specified UML properties.
			Occurrence constraints\footnote{Note that occurrence constraints are temporary, and intended to be removed later.} are roughly of the form `action $A$ must happen at least $M$ times and at most $N$ times' and thus limit the number of occurrences of some action in a to-be-synthesized activity.
			Abstract UML activities are `empty' in the sense that they contain no nodes nor control flow.
			\item A concrete UML activity is a finite directed graph consisting of \emph{nodes} and \emph{control flows}\footnote{The UML2 metamodel uses \textsf{ActivityNode} and \textsf{ActivityEdge}, but here it may be better to talk about control flow rather than edges due to the possible ambiguity with automata edges.}.
			A node can be a \emph{control node} (initial, final, fork, join, decision, or merge node), be an \emph{call opaque behavior node} which executes an action by calling an opaque behavior, or be an \emph{opaque action node} containing a guard and zero or more effects, thereby essentially `inlining' an action.
			So likewise to UML opaque behaviors, also opaque action nodes are either deterministic or nondeterministic, and either atomic or nonatomic.
			Concrete UML activities cannot contain preconditions, postconditions, or occurrence constraints.
		\end{itemize}
	\end{itemize}
	
	The activity synthesis algorithm takes UML models as input, containing any number of abstract UML activities.
	The goal of activity synthesis is then to synthesize a concrete UML activity for every abstract UML activity, and updating the UML model by replacing all abstract UML activities by the concrete synthesized ones.
	
	We will only consider UML models that are \emph{valid} with respect to the Poka Yoke validator.
	For example, UML models should not contain abstract UML activities that have nodes or control flows, and should not use double underscores `\_\_' in any names of UML elements.
	
	\item[Petri Nets.]
	A Petri Net is a finite directed graph consisting of \emph{places}, \emph{transitions}, and \emph{arcs}.
	We consider \emph{elementary Petri Nets}, where (by definition) any place holds at most one \emph{token}.
	Transitions in a Petri Net can be \emph{fired} to move tokens around between adjacent places.
	If some transition can fire, we say that it is \emph{enabled}.
	Any arc in a Petri Net must be connected to a place with a transition.
	That is, there cannot be an arc from a place to some other place, or from a transition to some other transition.
	Further details on Petri Nets and their semantics can be found in the standard literature.
	
	The activity synthesis algorithm may use a particular category of Petri Nets, namely \emph{free-choice Petri Nets}.
	This is because we have observed that free-choice Petri Nets can be translated to concrete UML activities that are more intuitive for users to understand than general Petri Nets.
	Intuitively, free-choice means that all choices (i.e., places with multiple outgoing arcs) can be made without additional constraints (i.e., the target transitions of these outgoing arcs do not have additional token requirements).
	Free-choice Petri Nets thus have simpler choice patterns compared to general Petri Nets, which may translate to more intuitive UML activities.
\end{description}

\subsection{Standard and tooling}
\label{sec:prelims:standards}

The activity synthesis algorithm deals with various different standards and tools.
A brief overview is given below.

\begin{description}
	\item[CIF.]
	CIF is a specification language for discrete event systems (as well as timed and hybrid ones), as well as a toolset that supports the development process of supervisory controllers.
	CIF is part of the Eclipse ESCET toolkit, see \url{https://eclipse.dev/escet} (accessed 2024-07-31) for further details.
	We use the data-based synthesis tool of CIF to do supervisory controller synthesis, and the CIF explorer tool for state space generation.
	\item[Petrify.]
	Petrify is a tool for Petri Net synthesis.
	Given some state machine (or finite automaton), the goal of Petri Net synthesis is to synthesize a (minimal) Petri Net that is trace-equivalent to the input state machine.
	Petrify has its own input and output specification language.
	We use Petrify to synthesize a Petri Net from a state machine, as a stepping stone for synthesizing UML activities.
	This is because Petri Nets can more compactly represent concurrency, by forking/joining from a Petri Net transition.
	In contrast, in state machines, concurrency is represented by explicit interleaving, i.e., as diamond patterns.
	Petri Net synthesis can automatically turn such diamond patterns in the input state machine to more compact fork/join patterns in the resulting Petri Net.
	Further information on Petrify can be found here: \url{https://www.cs.upc.edu/~jordicf/petrify} (accessed 2024-07-31).
	\item[PNML.]
	PNML stands for Petri Net Markup Language, and is an XML-based syntax for representing Petri Nets.
	We use the PNML metamodel to represent Petri Nets internally in the code implementation.
	Further information can be found here: \url{https://pnml.lip6.fr} (accessed 2024-07-31).
	\item[UML.]
	We use the UML metamodel to represent UML models and UML activities in the code implementation.
	Further information can be found here: \url{https://wiki.eclipse.org/MDT-UML2} (accessed 2024-07-31).
\end{description}

\subsection{Algorithms for synthesis}
\label{sec:prelims:synthesis}

The activity synthesis procedure internally uses two types of synthesis algorithms, namely supervisory controller synthesis (currently using CIF), and Petri Net synthesis (currently using Petrify).

Supervisory controller synthesis is used to compute a minimally restrictive supervisor, which is essentially a state machine that describes all safe system behavior. 
After that, Petri Net synthesis is used to synthesize a (possibly free-choice) Petri Net from this state machine, which is then transformed to a concrete UML activity.
The intermediate step of synthesizing a Petri Net is performed since Petri Nets are structurally much closer to UML activities compared to state machines, and thus easier to translate.

The field of Petri Net synthesis is developed around the \emph{theory of regions}.
Intuitively, the idea is to find groups of locations in the input state machine that can be turned into single places in the output Petri Net.
These groups are then called regions.
Depending on the type of Petri Net you aim to synthesize (e.g., general or free-choice ones), there are slightly different requirements of what exactly constitutes a region.
Petrify is essentially an implementation of the theory of regions, and is able to synthesize both general and free-choice Petri Nets (among other kinds of Petri Nets).
	
We will not explain data-based synthesis and Petri Net synthesis here.
More information on these types of syntheses can be found on the webpages of Eclipse ESCET and Petrify linked above.

\section{Activity Synthesis}
\label{sec:algorithm}

\autoref{alg:activity-synthesis} shows the high-level activity synthesis algorithm.
The entry point is \synthAll, which iterates over all abstract UML activities in the given input UML model, synthesizes a concrete UML activity for them, and replaces the abstract activity by the concrete synthesized one.
The algorithm for synthesizing a single UML activity, \synthSingle, is a sequence of operations performed on the input UML abstract activity.

\begin{algorithm}[t!]
	\tcp{Synthesizes a concrete activity for every abstract one in the model.}
	\procedure{\synthAll{\var{umlModel}}}{
		\For{\KwEveryAbstrActivity \var{umlActivity_{abstr}} \KwIn \var{umlModel}}{
			\var{umlActivity_{concr}} := \synthSingle{\var{umlActivity_{abstr}}}\;
			\KwReplace \var{umlActivity_{abstr}} \KwBy \var{umlActivity_{concr}} \KwIn \var{umlModel}\;
		}
	}
	
	\BlankLine
	\BlankLine
	
	\tcp{Synthesizes a concrete activity for the given abstract activity.}
	\procedure{\synthSingle{\var{umlActivity_{abstr}}}}{
		\tcp{Synthesize a CIF supervisor using data-based synthesis.}
		\var{cifSpec} := \transformUmlToCif{\var{umlActivity_{abstr}}}\;
		\var{cifSupervisor} := \dataBasedSynthesis{\var{cifSpec}}\;
		\tcp{Generate the CIF state space as a minimal DFA.}
		\var{cifStatespace} := \generateStatespace{\var{cifSupervisor}}\;
		\var{cifStatespace} := \ensureSingleSourceAndSink{\var{cifStatespace}}\;
		\var{cifStatespace_{proj}} := \eventBasedProjection{\var{cifStatespace}}\;
		\var{cifStatespace_{min}} := \dfaMinimization{\var{cifStatespace_{proj}}}\;
		\tcp{Synthesize a minimal Petri Net.}
		$(\var{petriNet}, \var{regionMapping})$ := \petrinetSynthesis{\var{cifStatespace_{min}}}\;
		\tcp{Transform the Petri Net to an activity without control flow guards.}
		\var{umlActivity_{concr}} := \transformToActivity{\var{petriNet}}\;
		\var{umlActivity_{red}} := \reduceNonAtomicPatterns{\var{umlActivity}_{concr}}\;
		\tcp{Compute the control flow guards for the UML decision nodes.}
		\var{umlActivity_{guards}} := \computeEdgeGuards{\var{umlActivity_{red}}, \, \dots}\;
		\tcp{Post-process the synthesized UML activity.}
		\var{umlActivity_{post}} := \postprocessActivity{\var{umlActivity_{guards}}}\;
		\Return \var{umlActivity_{post}}\;
	} 

	\caption{Synthesis of Poka Yoke activity diagrams}
	\label{alg:activity-synthesis}
\end{algorithm}

The remainder of this section explains all operations in \synthSingle.
A short explanation is given for every operation, followed by the motivation for having that operation, followed by its preconditions and postconditions.

\subsection{Transforming the UML model to CIF}
\label{sec:transform-uml-to-cif}

The \transformUmlToCif{\var{umlActivity_{abstr}}} operation translates a given abstract UML activity, \var{umlActivity_{abstr}}, together with all relevant context from the UML model (e.g., UML class properties, constraints, opaque behaviors, etc.) to a CIF specification to be used for supervisory controller synthesis.

\paragraph{Motivation.}
With respect to supervisory controller synthesis, the UML model of the abstract input activity \var{umlActivity_{abstr}} specifies the plant and requirements, i.e., the UML opaque behaviors and UML constraints.
Moreover, the abstract activity itself contains the name of the to-be-synthesized activity as well as its preconditions, postconditions, and occurrence constraints.
These plant and requirement constructs are translated one-to-one to CIF, to enable running its data-based synthesis tool.

\paragraph{Preconditions.}
This operation requires the UML model of the abstract input activity to be valid.

\paragraph{Postconditions.}
This operation produces a CIF specification that:
\begin{itemize}
	\item For every UML enum declaration in the UML model, contains a corresponding CIF enum declaration.
	\item Contains a CIF plant for the single UML class.
	This plant is a flower automaton, containing one location that is initial and marked, and only self-loops.
	\item Contains a discrete variable for every UML class property.
	If a UML class property has a default value, then this value is translated as the default value of the CIF variable.
	If not, then the corresponding CIF variable is specified to have any value initially, with the `in any' CIF construct.
	\item Contains CIF event declarations corresponding to all defined UML opaque behaviors.
	All opaque behaviors that model actions that are both atomic and deterministic are translated as single controllable events.
	All other opaque behaviors, that model nonatomic and/or nondeterministic actions, are translated to multiple CIF events, namely a controllable one for starting the action, and uncontrollable ones for each of their effects to end the action.
	Such separate uncontrollable `end' events must be defined since:
	\begin{itemize}
		\item In case of a nonatomic action, we must allow other actions to be performed while executing the nonatomic action.
		Thus, we create separate start and end events, to allow other CIF events to be performed in between.
		Moreover, the end events are defined to be uncontrollable so that data-based synthesis cannot influence when a nonatomic action ends.
		An example of a nonatomic action could be a robot movement.
		A synthesized controller cannot influence when such a robot movement finishes.
		\item In case of a nondeterministic action, separate `end' events are needed since data-based synthesis in CIF requires controllable events to be deterministic.
		So, for data-based synthesis, we need a controllable event to (controllably) start some nondeterministic action, and uncontrollable events to nondeterministically perform one of its effects.
	\end{itemize}
	Moreover, in case the UML model contains nonatomic and/or atomic nondeterministic actions, extra internal CIF variables are created to ensure that the actions are properly executed:
	\begin{itemize}
		\item For every nonatomic action in the UML model, an \emph{active variable} is declared and maintained in the CIF specification.
		The active variable of a nonatomic action is a Boolean that indicates whether the action is currently being executed (\texttt{true}) or not (\texttt{false}).
		The start event of a nonatomic action can only be performed when the active variable of that action is \texttt{false}, and performing it will set the active variable to \texttt{true}.
		Any end event of a nonatomic action can only be performed when the active variable of the action is \texttt{true}, and performing it will set the active variable to \texttt{false}.
		\item In case the UML model contains atomic nondeterministic actions, a single internal \emph{atomicity variable} is declared and maintained in the CIF specification, to ensure that no event may occur between the start and end event of the atomic nondeterministic action.
		This atomicity variable is defined to be an integer between $0$ and $n$, with $n$ the total number of atomic nondeterministic actions.
		If the atomicity variable is $0$, then no atomic nondeterministic action is being executed.
		The start event of any atomic nondeterministic action will set the atomicity variable to be the index of that action.
		If the atomicity variable is greater than $0$, then only an end event of the corresponding (indexed) action can be performed, and performing such an end event will reset the active variable to $0$.
		We add necessary guards to all created CIF edges to ensure that indeed no other CIF event can be performed when the active variable is not $0$.
	\end{itemize}
	\item Contains an `initial' predicate from the conjunction of all translated preconditions of the abstract UML activity.
	There may be multiple preconditions defined for this activity.
	Each of these preconditions are translated as Boolean algebraic variables in CIF, for better traceability.
	The conjunction of all these Boolean algebraic variables then forms the activity precondition, for which an algebraic variable is created as well.
	This algebraic variable is then used as the `initial' predicate, which limits the number of initial states to only the ones satisfying the precondition.
	\item Contains a `marked' predicate from the conjunction of all translated postconditions of the abstract UML activity.
	There may be multiple postconditions defined for this activity.
	Each of these postconditions are translated as Boolean algebraic variables in CIF, for better traceability.
	The conjunction of all these Boolean algebraic variables then forms the activity postcondition, for which an algebraic variable is created as well.
	This algebraic variable is then used as the `marked' predicate.
	Thus, a marked state is a state where the (combined) activity postcondition is satisfied.
	\item Contains requirement invariants stating that the postcondition disables any CIF event.
	In other words, if you would reach a system state where the activity postcondition holds, then no further actions would have to be taken as they will not contribute to coming closer to a postcondition state.
	These requirements can be seen as an optimization for synthesis and later state space generation, to avoid considering unnecessary steps.
	And they ensure that the synthesized UML activity will have no further actions after having reached a final node.
	\item In case any internal active variables or atomicity variable were declared as described earlier, extra requirement invariants are generated which express that, whenever the activity postcondition holds, no nonatomic and/or nondeterministic actions can be active.
	These requirements are expressed by means of logical implication: the activity postcondition implies that no nonatomic/nondeterministic action are active.
	By generating such requirements, we can ask data-based synthesis to synthesize a supervisor that prevents taking a step to satisfy the postcondition whenever some action is still being executed.
	As a result, no nonatomic/nondeterministic action is active in any marked state in the controlled system.
	\item Contains an edge in the flower automaton plant for every defined CIF event declaration.
	An edge is defined for every declared CIF event, both controllable and uncontrollable ones.
	Every controllable CIF event corresponds one-to-one to a UML opaque behavior definition, and thus their edge guards are the translated action guards.
	Moreover, in case of an atomic deterministic action, the edge update is the translated action effect.
	In case of a nonatomic and/or nondeterministic action, the action effects are translated on the corresponding uncontrollable events instead.
	We do not put the user-written action guards as guards for uncontrollable events, since we don't want conditions on any `end' events, and by making them uncontrollable, any synthesized constraints are pushed back to the corresponding controlled `start' events.
	However, we do put guards and effects on the (un)controllable events to correctly handle and maintain the atomicity variable and the active variables.
	
	Furthermore, edges are guaranteed not to contain conditional `if'-updates, since these are not supported by data-based synthesis.
	Any conditional updates have been eliminated from the CIF specification.
	They are turned into conditional expressions, which are supported by data-based synthesis.
	\item Contains requirement automata for the occurrence constraints defined for \var{umlActivity_{abstr}}.
	Occurrence constraints are roughly of the form `action $A$ must happen at least $M$ times and at most $N$ times'.
	Such constraints are translated as requirement automata, containing a discrete variable that maintains how often the action has already occurred.
	This variable can then be incremented every time the action occurs.
	The occurrence requirement can then be expressed over this requirement (using edge guards and marked predicates).
\end{itemize}

\subsection{Data-based synthesis with CIF}
\label{sec:data-based-synthesis}

The operation \dataBasedSynthesis{\var{cifSpec}} executes the data-based synthesis tool of CIF.
Data-based synthesis is thereby configured to do forward reachability (\texttt{--forward-reach=true}), and to do no BDD predicate simplification (i.e., removing all simplifications from \texttt{--bdd-simplify}).
Forward reachability is done for performance reasons, and because it may lead to more readable results (in particular UML edge guards).
And by disabling all simplifications, we ensure that the synthesized conditions fully capture under which conditions the controllable events are enabled in the controlled system.

\paragraph{Motivation.}
Our goal of performing data-based synthesis is to compute all extra restrictions on actions that must be considered by the to-be-synthesized activity to never violate specified requirements.
Data-based synthesis computes a minimally restrictive supervisor for going from a state that satisfies the activity precondition, to a state that satisfies the postcondition, without violating requirements, running into blocking situations, etc.
We will later make the behavior of this supervisor explicit (\autoref{sec:state-space-generation}), to be able to synthesize a compact Petri Net for it (\autoref{sec:petrinet-synthesis}) that is then transformed to a concrete activity (\autoref{sec:transform-petrinet-to-activity}).

After this transformation, we need to separately compute the guards of the control flows that go out of UML decision nodes (\autoref{sec:compute-control-flow-guards}).
This computation make use of the extra restrictions that are synthesized by data-based synthesis.
Moreover, this computation requires that these extra restriction predicates are \emph{not} simplified, which CIF does by default, hence the extra configuration.

Forward reachability is configured simply for performance reasons, and might make synthesized conditions smaller.
We should later evaluate if, and how much, forward reachability actually contributes to that. 

\paragraph{Preconditions.}
All preconditions of the data-based synthesis tool apply.

\paragraph{Postconditions.}
All guarantees of the data-based synthesis tool apply.
Moreover, since BDD predicate simplification is disabled, the resulting CIF supervisor contains no requirement invariants.
These requirements are instead included in the synthesized conditions.
The guards of the supervisor automaton, for each controllable event, are the full/complete conditions under which these controllable events are enabled in the controlled system.

\subsection{State space generation}
\label{sec:state-space-generation}

The operation \generateStatespace{\var{cifSupervisor}} executes the CIF explorer tool, which unfolds the state space of the given CIF specification, \var{cifSupervisor}.

\paragraph{Motivation.}
We need to explicitly unfold the (safe) state space of the synthesized supervisor \var{cifSupervisor} to be able to construct input for Petri Net synthesis, in order to later synthesize a concrete UML activity.
With `explicitly unfold' we mean that all data (e.g., discrete variables) is eliminated, leading to a state space that is a DFA/NFA.
The reason is that Petrify does not have symbolic Petri Net synthesis algorithms, i.e., it cannot handle data.
As input Petrify requires a DFA or NFA (i.e., a traditional supervisor in the form of a single DFA/NFA), rather than an EFA.
Petrify does not support variables.

The state space that is generated by $\generateStatespaceLabel$ from the synthesized supervisor expresses all possible orderings of events, taking into account the extra synthesized guards and the original action guards as specified in the UML model.
The goal of Petri Net synthesis is then to find a compact Petri Net representation of all these possible orderings, whose structure can then be translated to a concrete UML activity.

As a side remark; state space generation could later become a performance bottleneck, e.g., in case there are many initial states or large diamond patterns.
If this problem materializes, we could consider symbolic state space generation instead of explicit state space generation, and possibly adapting the Petri Net synthesis algorithms to directly use these symbolic specifications.

\paragraph{Preconditions.}
All preconditions of the CIF explorer tool apply.

\paragraph{Postconditions.}
All guarantees of the CIF explorer tool apply.
The CIF explorer produces a CIF specification that contains exactly one automaton---the CIF state space.
Noteworthy is that this state space will have state annotations $\texttt{@state(\dots)}$ that indicate the values of every variable in every location, as well as the current location of each automaton that has at least two locations.
This information will later be used for computing control flow guards (in \autoref{sec:compute-control-flow-guards}).

Moreover, due to the way our UML/CIF input for synthesis is constructed (as result of \autoref{sec:transform-uml-to-cif}), the resulting state space has the following properties:
\begin{itemize}
	\item All initial locations in the state space correspond to states that satisfy the precondition of the to-be-synthesized activity.
	\item All marked locations in the state space correspond to states that satisfy the postcondition of the to-be-synthesized activity.
	Moreover, no nonatomic and/or nondeterministic actions are active in those states.
	\item Marked locations do not have outgoing edges.
	This is because it does not make sense to perform further actions after the activity postcondition has been satisfied.
	\item The state space is non-blocking.
	That is, any path from any location in the state space will either end up in a marked location (if it's not a marked location itself), or will loop.
	In other words, the only locations from which no further edges can be taken are the marked locations.
	\item Unless the supervisor was empty (in which case the activity synthesis chain will have terminated already before having generated the state space), there is at least one initial location and at least one marked location.
	\item Any edge with an atomic nondeterministic event will end up in a location where only the uncontrollable end events of that nondeterministic action are possible.
	This property is a consequence of the execution semantics of atomic actions.
	If an atomic nondeterministic action is being executed in some location in the CIF state space, then by the atomicity constraint that we generated earlier, the only thing that could happen is an uncontrollable event to finish the atomic action.
\end{itemize}

\subsection{Ensuring a single source and sink location}
\label{sec:single-source-and-sink}

The operation \ensureSingleSourceAndSink{\var{cifStatespace}} transforms the single automaton in the given CIF specification, \var{cifStatespace}, to ensure it has exactly one initial (source) location and exactly one marked (sink) location.

\paragraph{Motivation.}
Having exactly one initial location is required for event-based projection and DFA minimization, described in Sections~\ref{sec:event-based-projection} and~\ref{sec:dfa-minimization}, resp.

Moreover, having exactly one initial location makes it easier to synthesize activities that must handle multiple initial states.
To elaborate on that: we would like to synthesize activities that have exactly one initial node and exactly one final node in order to keep the activities themselves, as well as their execution semantics, understandable.
However, it may happen that \var{cifStatespace} has multiple initial locations, for example when the activity precondition allows having more than one initial state.
In such cases, we want the synthesized activity to have one initial node, and from there have a decision node that has outgoing edges for the multiple things that can happen.
Thus, the single CIF initial location that is guaranteed by \ensureSingleSourceAndSinkLabel{} will then directly correspond to the single initial node in the to-be-synthesized activity.

The situation is likewise for marked locations.
The single CIF marked location that is guaranteed by \ensureSingleSourceAndSinkLabel{} will directly correspond to the single final node in the to-be-synthesized activity.
In case the to-be-synthesized activity has multiple different ways to satisfy the activity postcondition, then this single final node will be preceded by a merge node at which these different ways are merged.
So \ensureSingleSourceAndSinkLabel{} ensures that the CIF specification already has the right structure with respect to that.

\paragraph{Preconditions.}
The input CIF specification is required to:
\begin{itemize}
	\item Not contain any (non-trivial) CIF initialization predicates nor any CIF marker predicates in components.
	(This is ensured if \var{cifStatespace} is generated by the CIF explorer.)
	\item Contain exactly one automaton with an explicit alphabet.
	(Which is already guaranteed by the CIF explorer.)
	\item Not contain declarations/identifiers with the names \initLabel{}, \doneLabel{}, \startLabel{}, or \stopLabel{}.
	These will be the names of the new initial (source) location, the new marked (sink) location, and the auxiliary events that connect these locations to the original initial/marked locations.
\end{itemize}

\paragraph{Postconditions.}
This operation guarantees that:
\begin{itemize}
	\item The resulting CIF specification has two new declared controllable events, \startLabel{} and \stopLabel{}, which have been added to the automaton alphabet.
	\item The resulting CIF specification has a single new initial location named \initLabel{}, even when it already had a single initial location.
	Auxiliary edges with event \startLabel{} have been added that go from \initLabel{} to all original initial locations.
	The new single initial location has all state annotations of every original initial location.
	The original initial locations are now no longer initial.
	\item The resulting CIF specification has a single new marked location named \doneLabel{}, even when it already had a single marked location.
	Auxiliary edges with event \stopLabel{} have been added that go from all original marked locations to \doneLabel{}.
	The new single marked location has all state annotations of every original marked location.
	The original marked locations are no longer marked.
	\item Apart from initial/marked locations, the CIF specification is unchanged.
\end{itemize}

\subsection{Event-based projection}
\label{sec:event-based-projection}

The operation \eventBasedProjection{\var{cifStatespace}} projects the single automaton in the given CIF specification for all controllable events and all uncontrollable end events of nonatomic actions.
This means that all uncontrollable end events of atomic nondeterministic actions are projected away, i.e., \var{cifStatespace} is transformed to a DFA without keeping any uncontrollable events related to atomic nondeterministic actions.

\paragraph{Motivation.}
Recall that uncontrollable CIF events were created for atomic nondeterministic actions (in \autoref{sec:transform-uml-to-cif}), to model the nondeterministic yet atomic execution of their effects.
However, these uncontrollable events and their corresponding edges are an internal, intermediate step that should not be visible in the synthesized UML activity.
So at some point, these uncontrollable events have to be eliminated.
This elimination should be done before Petri Net synthesis due to the atomicity constraint.
To clarify this further, recall that the goal of Petri Net synthesis is to find a minimal Petri Net whose behavior is trace-equivalent to the CIF state space that was given as input to Petri Net synthesis.
While doing so, Petri Net synthesis aims to reduce diamond patterns in the state space to fork/join constructs in Petri Nets as much as possible.
However, due to the atomicity constraint, the uncontrollable events of atomic nondeterministic actions do not give perfect diamond patterns, since whenever some atomic nondeterministic action is being executed, the atomicity constraint enforces that no other action can be performed, thus impacting interleaving.
Therefore, we perform event-based projection on the CIF state space, to restore the diamond patterns that got disrupted by the atomicity constraint, before performing Petri Net synthesis.
We do not eliminate the uncontrollable end events of nonatomic actions since no atomicity constraints are imposed on such actions, i.e., their diamond patterns are still intact.

Note that Petrify, which is the tool we use for Petri Net synthesis, also has a built-in option \texttt{--hide} to hide a list of given events.
We used this option in earlier versions of our implementation instead of doing event-based projection on the level of CIF.
However, Petrify's hiding option seems broken, in the sense that we observed that Petrify does not always hide all events in the specified list.
This further motivates doing hiding/projection on the level of CIF instead.

\paragraph{Preconditions.}
Since \eventBasedProjectionLabel{} uses the automaton projection tool that comes with CIF\footnote{See \url{https://eclipse.dev/escet/cif/tools/eventbased/projection.html} (accessed 2024-08-01).}, all preconditions from that tool apply.
Notably, the input should be a valid CIF specification, e.g., it does not accept automata where some locations have state annotations and some do not.
The input CIF specification must contain a single automaton, which in our case is the CIF state space, which in turn must have exactly one initial location.

\paragraph{Postconditions.}
All guarantees of the automaton projection tool from CIF apply.
Notably, event-based projection guarantees that the resulting automaton after projection is a DFA that contains only the projected events, and that is trace-equivalent to the input specification with respect to those events.
In our case, this means that the resulting CIF specification no longer contains the uncontrollable events of atomic nondeterministic actions, and is trace-equivalent to the input modulo those events. 
The resulting DFA is not guaranteed to be minimal.
We will minimize it in the next step.

\subsection{DFA minimization}
\label{sec:dfa-minimization}

The \dfaMinimization{\var{cifStatespace_{proj}}} operation minimizes the single deterministic automaton in the given CIF specification, \var{cifStatespace_{proj}}.

\paragraph{Motivation.}
We use DFA minimization to minimize the input for Petri Net synthesis, such that we get the smallest possible UML activity that is still optimal.

Moreover, note that Petrify, which is the tool we use for Petri Net synthesis, also has a built-in option \texttt{--mints} to minimize the input graph modulo trace equivalence.
From the documentation of Petrify\footnote{Which is included in the distribution that can be downloaded from the Petrify webpage.} this option seems to have some interaction with the \texttt{--hide} option.
However, as explained in \autoref{sec:event-based-projection}, \texttt{--hide} does not seem to always work.
Therefore, in addition to event-based projection, we also do the minimization on the level of CIF.

\paragraph{Preconditions.}
Since \dfaMinimizationLabel{} uses the event-based DFA minimization tool that comes with CIF\footnote{See \url{https://eclipse.dev/escet/cif/tools/eventbased/dfa-minimize.html}(accessed 2024-08-01).}, all preconditions from that tool apply.

Notably, the input should be a CIF specification containing exactly one deterministic automaton with exactly one initial location.
In our case this is the projected CIF state space.
Note that the previous event-based projection step ensures that the input we give to \dfaMinimizationLabel{} is indeed deterministic and has exactly one initial location, thus allowing DFA minimization.

\paragraph{Postconditions.}
All guarantees of the DFA minimization tool from CIF apply.
Notably, the result is a CIF specification containing a single minimal DFA that is trace-equivalent to the DFA in the input CIF specification.

The resulting automaton is a DFA with exactly one initial location.
Moreover, this operation preserves the property from \autoref{sec:single-source-and-sink} that there is exactly one marked (sink) location.
To see why, suppose that event-based projection and/or DFA minimization would somehow have split-up the single marked location into multiple ones.
Let us take two of them and refer to these locations as $m_1$ and $m_2$.
Neither $m_1$ nor $m_2$ can have outgoing edges.
But then there can be no word in the automaton language that would distinguish $m_1$ and $m_2$.
Hence they must be the same location.

\subsection{Petri Net synthesis}
\label{sec:petrinet-synthesis}

The operation \petrinetSynthesis{\var{cifStatespace_{min}}} performs Petri Net synthesis to compute a minimal Petri Net whose behavior is trace-equivalent to the single automaton in the given CIF specification, \var{cifStatespace_{min}}.
This operation attempts to synthesize a free-choice Petri Net, and if that fails, it synthesizes an ordinary Petri Net instead.
Moreover, this operation produces a \emph{region mapping}, which is a mapping that relates the input specification \var{cifStatespace_{min}} to the synthesized Petri Net.

We use the Petrify tool for performing Petri Net synthesis.
We thereby use the following options of Petrify: \texttt{-opt} to try to find the best possible result; \texttt{-fc} to synthesize a free-choice Petri Net;
\texttt{-ip} to produce a Petri Net with intermediate places (otherwise certain places could be omitted to make the result a bit smaller for visualization purposes); and \texttt{-log} to generate a log file.
If synthesis fails with the \texttt{-fc} option, Petrify will be invoked again without \texttt{-fc}.

In our activity synthesis algorithm, we use PNML as the intermediate format for representing Petri Nets.
Therefore, part of the \petrinetSynthesisLabel{} operation is to translate \var{cifStatespace_{min}} to the input language of Petrify, and transforming the output of Petrify to PNML.

Moreover, although Petrify constructs a region mapping internally, there is no way to retrieve this region mapping by, e.g., some command-line option.
The developers of Petrify recommended us to write a separate algorithm to `recover' this region mapping, by co-simulating the input and output of Petrify to find out which CIF locations correspond to which Petri Net places.
Therefore, the implementation of \petrinetSynthesisLabel{} also requires recovering this region mapping, at least as long a Petrify is being used.

\paragraph{Motivation.}
By having computed a (projected and minimal) CIF state space, \var{cifStatespace_{min}}, we are still quite distant from a concrete UML activity.
The main reason is that concurrency can more concisely be represented in UML activities, via their fork and join nodes, compared to state machines and automata.
In contrast, \var{cifStatespace_{min}} has all concurrent interleaving explicitly unfolded as diamond patterns.
We now somehow have to detect all diamond patterns of concurrent interleaving in \var{cifStatespace_{min}} and translate those to fork/join patterns in the to-be-synthesized UML activity.
This is done by means of Petri Net synthesis, which is a field of research aiming to do exactly that, but then on Petri Nets rather than UML activities.
Nevertheless, Petri Nets and activities are quite closely related, in the sense that the semantics of activities is usually defined as a token-based semantics.
Our main strategy is therefore to synthesize a minimal Petri Net from \var{cifStatespace_{min}} (in this section), and translate that to a UML activity (in \autoref{sec:transform-petrinet-to-activity}).
We thus use Petri Nets as an intermediate formalism in our activity synthesis algorithm.

Moreover, there are particular classes of Petri Nets, like \emph{free-choice} Petri Nets, that are likely to lead to more intuitive UML activities.
(This is based on our observations from earlier experiments.
We haven't yet done an extensive study or comparison to see whether this is always the case.)
Therefore we attempt to synthesize a free-choice Petri Net whenever possible.

However, translating a Petri Net to a UML activity structure is not yet sufficient: we then still need to compute the control flow guards for the decision nodes of the synthesized UML activity.
These control flow guards are needed, since without them any UML decision node could freely follow any of its outgoing control flows, leading to executions that are not allowed by the synthesized CIF supervisor.
This step must be done separately (in \autoref{sec:compute-control-flow-guards}), since to the best of our knowledge, Petri Net synthesis with data/state is an open research field for which tooling is not available.
Therefore, we must be able to relate the output of Petri Net synthesis to the input specification, \var{cifStatespace_{min}}.
Such a relation is (or should be) produced by the Petri Net synthesis algorithm, and is called a \emph{region mapping}.
The reason for this, is that Petri Net synthesis is based on the \emph{theory of regions}.
Without going too deep into this theory; the main idea is to group locations from \var{cifStatespace_{min}} together so that every such group (roughly) corresponds to a Petri Net place.
These groups are then called \emph{regions}.
So the Petri Net algorithm can produce a mapping from Petri Net places to the regions from which they are formed, thereby providing an input-output relation.
With this relation, we can later find the relevant data/state and synthesized guards on the level of CIF, for the Petri Net places that will become UML decision nodes, and from those calculate the control flow guards.
\autoref{sec:compute-control-flow-guards} explains this further.

\paragraph{Preconditions.}
Since Petrify is used for Petri Net synthesis, all preconditions from that tool apply.
However, these preconditions do not seem to be well-documented.
In any case the input CIF specification should not contain identifiers which are reserved keywords in the input formalism of Petrify.
But since all Petrify reserved keywords seem to start with a dot, e.g., \texttt{.inputs} and \texttt{.graph}, this is (probably) already ensured as valid UML models do not contain identifiers containing a dot.

Moreover, the input CIF specification must contain exactly one automaton, i.e., the minimized CIF state space computed in the previous steps.
This automaton must have an explicit alphabet that contains no duplicate events.

Furthermore, the event name \loopLabel{} must not be in the automaton alphabet.
This is because \petrinetSynthesisLabel{} will create an auxiliary self-loop edge named \loopLabel{} before Petrify is invoked, which is removed later from the output of Petrify.
This auxiliary self-loop is added to make Petrify work.
This is because Petrify seems unable to do Petri Net synthesis in case the input automaton has deadlock locations, i.e., locations without outgoing edges.
And recall that \var{cifStatespace_{min}} has a single marked location which is a sink location, and thus when you get into this location during some execution, the execution deadlocks.
Hence, to resolve this, we add an extra self-loop edge that connects the single marked location to itself, to still allow `progress' from this sink location.
After having invoked Petrify, the synthesized Petri Net will contain exactly one transition for \loopLabel{} (since the input automaton has exactly one marked location and we added exactly one \loopLabel{} edge), so it's easy to remove it again.

Finally, the string \toLabel{} must not occur in any event name in the input automaton.
This is later needed for transforming Petrify output to PNML, where \toLabel{} will be used as part of PNML arc identifiers.

\paragraph{Postconditions.}
All guarantees from Petrify apply.
In particular, the output is an optimal (possibly free-choice) Petri Net that is trace-equivalent to the input automaton.
The synthesized Petri Net is returned in PNML format.

As explained above, the \loopLabel{} event has been removed from this Petri Net.
The synthesized Petri Net contains exactly one place that initially holds a token.
This place has no incoming arcs and exactly one outgoing arc to a transition named \startLabel{}.
The returned Petri Net also contains exactly one sink place with no outgoing arcs and at least one incoming arc from a transition named \stopLabel{} (there could be multiple such arcs, in contrast to the initial place).
These two places will later become the initial and final node of the synthesized activity.

Petrify may have performed \emph{label splitting}.
This means that Petrify may have chosen to split up certain events $e$ in \var{cifStatespace_{min}} into events that are named $e/1$, $e/2$, etc.
This is done by Petrify for technical reasons that are not explained further here, but which are needed to enable Petri Net synthesis.
The consequence of label splitting is that the synthesized Petri Net may have multiple transitions for some CIF events $e$ that are then labeled incrementally, as $e/1$, $e/2$, etc.
We can later easily detect such duplication and remove these `duplication markers'.

Moreover, as an internal step, the synthesized Petri Net has been normalized (i.e., all its places have been relabeled).
This is needed since Petrify seems able to produce nondeterministic results in the sense that running Petrify multiple times on the same input model may give different results.
But these different results are the same modulo names of places.
We therefore normalize synthesized Petri Nets, for example to allow proper regression testing.

Furthermore, a region mapping is computed that indicates how Petri Net places correspond to locations in the input CIF automaton.
This region mapping is thus a mapping from Petri Net places to sets of automaton locations.

\subsection{Transforming the Petri Net to an activity}
\label{sec:transform-petrinet-to-activity}

The operation \transformToActivity{\var{petriNet}} transforms the given (possibly free-choice) Petri Net \var{petriNet} in PNML format to a concrete UML activity.

\paragraph{Motivation.}
The overall aim of the activity synthesis chain is to synthesize concrete UML activities.
Since activities are reasonably close to Petri Nets, we do this by first synthesizing a Petri Net using known techniques, and transforming this Petri Net to a concrete UML activity using \transformToActivityLabel{}.

\paragraph{Preconditions.}
The input \var{petriNet} must be in PNML format.
It must have exactly one place that has an initial token, which must additionally have no incoming arcs and exactly one outgoing arc to a transition named \startLabel{}.
It must have exactly one (sink) place that does not have any outgoing arcs, which must additionally have at least one incoming arc from a transition named \stopLabel{}.

\paragraph{Postconditions.}
The output is a concrete UML activity which has been translated from \var{petriNet}.
The returned concrete UML activity contains:
\begin{itemize}
	\item Exactly one initial node and exactly one final node, which have been translated from the two places described above in the preconditions paragraph.
	\item One auxiliary opaque action named \startLabel{}, which has been created for the start event introduced earlier, as explained in \autoref{sec:single-source-and-sink}.
	Then the initial node has exactly one outgoing control flow to this \startLabel{} action.
	\item An auxiliary opaque action named \stopLabel{} for every end event introduced earlier, as explained in \autoref{sec:single-source-and-sink}.
	\item No other opaque action, apart from the \startLabel{} and \stopLabel{} opaque actions.
	Then all these opaque \stopLabel{} actions have exactly one outgoing control flow that goes to the final node.
	\item Fork/join/decision/merge control nodes, as translated from similar patterns in \var{petriNet}.
	For example, a Petri Net place with multiple incoming arcs and one outgoing arc is translated to a UML merge node.
	The only control nodes that have multiple incoming control flows are join and merge nodes.
	The only control nodes that have multiple outgoing control flows are fork and decision nodes.
	\item Call behavior nodes for every transition in \var{petriNet} that performs an action.
	These nodes then call the appropriate UML opaque behavior of the action.
	Any duplication that was introduced by label splitting (recall from \autoref{sec:petrinet-synthesis}) has been removed during the process of finding the right UML opaque behavior corresponding to a Petri Net transition.
	\item No guards on any control flows.
	Control flow guards are computed later, in \autoref{sec:compute-control-flow-guards}.
\end{itemize}

Furthermore, \transformToActivityLabel{} ensures that every control flow that goes out of a decision node will end in either some (call behavior) action node, or in the final node (in which case there was also an action, but it was the auxiliary internal $\stopLabel$ action).
This is a consequence of the structure of the Petri Nets that are synthesized by Petrify, and the patterns that they could have.
To give another example of a pattern that cannot occur: it is not possible for the concrete UML activity to have a control flow that goes from some decision node to some other decision node, because in the Petri Net there cannot be an arc from a place to another place.

\subsection{Reducing nonatomic patterns}
\label{sec:reducing-non-atomic-patterns}

The operation \reduceNonAtomicPatternsLabel{} merges any nonatomic patterns in the input concrete UML activity that can be merged.

Note that, in the code implementation, this reduction step is actually done on the Petri Net level rather than the UML level, as well as the next step of computing control flow guards, described in \autoref{sec:compute-control-flow-guards}.
This is done for technical reasons that for now are too detailed for the purpose of this document, which is why we chose to explain this (and the next) step on the UML level instead.
The underlying reason is that the intermediate Petri Net representations have a nicer structure than the translated UML activities when it comes to computing control flow guards.
Moreover, we have to reduce nonatomic patterns before computing control flow guards, which is why the code implementation performs also this reduction step on Petri Net level.

\paragraph{Motivation.}
Recall that in the UML-to-CIF transformation (\autoref{sec:transform-uml-to-cif}) we created separate controllable start events and uncontrollable end events for nonatomic and atomic nondeterministic actions.
Then, in the earlier event-based projection step (\autoref{sec:event-based-projection}) we got rid of the end events of the atomic nondeterministic actions, by projecting those out.
However, the end events of nonatomic actions are still in the CIF specifications, and thus also in the Petri Net specifications, and thus also in the UML activity specifications.
The \reduceNonAtomicPatternsLabel{} operation will attempt to merge the starts and ends of nonatomic actions back to single call behavior actions wherever possible.

\begin{figure}[t]
	\begin{center}
		\includegraphics[scale=0.6]{images/non-atomic-pattern}
	\end{center}
	\caption{Left: a nonatomic pattern for a nonatomic nondeterministic action \textsf{A} with two nondeterministic effects, presented on UML activity level.
	Right: the same pattern, but rewritten by \reduceNonAtomicPatternsLabel{}.}
	\label{fig:non-atomic-pattern}
\end{figure}

However, merging these starts and ends is rather delicate, and not always possible.
To see why, let us have a look at nonatomic action patterns.
Consider a nonatomic nondeterministic action \textsf{A} that has two nondeterministic effects.
Then one (controllable) start event and two (uncontrollable) end events were defined for \textsf{A} during the UML-to-CIF translation.
Let us call these $\textsf{A}_{\textsf{start}}$, $\textsf{A}_{\textsf{end1}}$, and $\textsf{A}_{\textsf{end2}}$, respectively.
\autoref{fig:non-atomic-pattern} (left) then shows an example of a nonatomic pattern for \textsf{A} as it may currently look on the UML activity level.
The action $\textsf{A}_{\textsf{start}}$ has the original guard of \textsf{A} but no effects.
The actions $\textsf{A}_{\textsf{end1}}$ and $\textsf{A}_{\textsf{end2}}$ both have guard \texttt{true}, and have the first and the second nondeterministic effect of \textsf{A}, respectively.
The intermediate decision node is not allowed to be connected to any other nodes than the starts and ends of \textsf{A}, otherwise the pattern doesn't apply.
We aim to (eventually) merge this pattern back into a single call behavior node that simply calls \textsf{A}.

However, we cannot directly merge this pattern here since that would complicate choice guard computation later on.
If we would merge the pattern here, then we would have to push down the decision node to below the merged `call $\textsf{A}$' action.
By doing so, it would become (more) difficult to compute the control flow guards, as there may be all kinds of forking/joining/branching/merging constructions in the `$\dots$' parts below the decision node that we then would have pushed down\footnote{This is also the main reason why we actually do the guard computation on the Petri Net level rather than on UML activity level. On Petri Net level, there are only places and transitions, in contrast to the various different types of nodes that UML has for forking, joining, branching, merging, etc., which might also be composed in arbitrary ways.
Nevertheless, the high-level synthesis algorithm is easier to explain on UML activity level, since then the explanation doesn't have to rely on details such as the connection/relation between the Petri Net and the translated UML activity.}.
These constructions make it more difficult (though not impossible) to gather all necessary state information for the guard computation.

Therefore, instead of directly merging the nonatomic pattern, we replace the $\textsf{A}_{\textsf{start}}$ node by a `call $\textsf{A}$' node, and replace the end nodes by internal `tau' nodes, which are later eliminated (in \autoref{sec:activity-post-processing}).
The result is shown on the right in \autoref{fig:non-atomic-pattern}.
With this rewritten pattern, it becomes easier to later compute the control flow guards for the decision node, since the decision node structure is now fixed by means of the internal `tau' nodes.
This allows computing the guards for this decision node, while any (potentially complicated) structure that's below the `tau' nodes can be handled separately.
However, to compute the choice guards for this decision node, we do have to consider that, when comparing the left pattern with the right pattern in \autoref{fig:non-atomic-pattern}, the nondeterministic effects are evaluated at different points.
In the left pattern, the nondeterministic effect applies after the decision node, whereas in the rewritten pattern on the right, the effect applies before the decision node, as part of the `call $\textsf{A}$' action.
\autoref{sec:compute-control-flow-guards} explains how to deal with this when computing control flow guards.

Finally, merging nonatomic starts and ends is not always possible, since the nonatomic pattern may not always apply.
This may, e.g., happen in case of imperfect concurrent interleaving.
For example, consider some atomic action \textsf{B} such that, after data-based synthesis, the synthesized supervisor allows \textsf{B} to happen before \textsf{A}, during \textsf{A} (i.e., in between its start and end events), but not after \textsf{A}.
Then there is no full diamond pattern with respect to the interleavings of \textsf{A} and \textsf{B} that can be reduced to a forking construct by Petri Net synthesis.
As a result, the intermediate decision node in \autoref{fig:non-atomic-pattern} (left) will have an extra outgoing control flow to \textsf{B}, which breaks the nonatomic pattern.
In such cases, we do not merge the starts and ends of nonatomic actions, but keep them separated.
These cases are further handled during activity post-processing (\autoref{sec:activity-post-processing}).

\paragraph{Preconditions.}
This operation requires a concrete UML activity resulting from the previous step (the code implementation actually requires its earlier Petri Net representation).
This model should not use the string \tauLabel{} in any of its identifiers, as \reduceNonAtomicPatternsLabel{} will use it to represent rewritten end points of nonatomic patterns.

\paragraph{Postconditions.}
This operation returns the input activity, where all nonatomic patterns have been rewritten as shown on the right in \autoref{fig:non-atomic-pattern}.
Any starts and ends of nonatomic actions whose occurrences do not fit the nonatomic pattern will not have been rewritten, and are handled during activity post-processing.

\subsection{Computing control flow guards in the activity}
\label{sec:compute-control-flow-guards}

The operation \computeEdgeGuards{\var{umlActivity_{red}}, \, \dots} computes guards for every control flow in the single concretized UML activity \var{umlActivity_{red}} that goes out of a decision node.
These guards are computed by using intermediate results from earlier steps in the activity synthesis algorithm, notably the extra conditions that have been synthesized earlier by data-based synthesis, the CIF state annotations in the generated/projected/minimized CIF state space, the region mapping, the tracing information from the earlier steps in the synthesis chain, etc.
Rather than listing all items explicitly, we abbreviate them as `$\dots$'.

\paragraph{Motivation.}
At this point in the activity synthesis algorithm we managed to synthesize the structure of the concrete UML activity.
This activity may have decision nodes.
The execution of these decision nodes should follow one of its outgoing control flows, based on the current state of the system.
However, the guards that determine which control flow should be followed are missing at this point.
These choice guards could not have yet been computed since Petrify (or any other known algorithm for Petri Net synthesis) cannot handle data.
So we need to compute them separately, and add them to the concrete UML activity.

The three essential ingredients for computing control flow guards are:
\begin{itemize}
	\item The \emph{uncontrolled system guards}, as a mapping from actions to their corresponding guards as defined in the input UML model.
	These guards can thus be obtained by querying the original UML input model.
	\item The \emph{controlled system guards}, as a mapping from actions that were controllable on the CIF level, to their corresponding synthesized guards.
	The synthesized guards thus are the full conditions computed by data-based synthesis, under which the action is enabled in the controlled system.
	\item The \emph{state information}, as a mapping from control flows (or, equivalently, Petri Net places), to the predicate that describes all states the system can be in whenever the control flow is enabled (i.e., whenever their is a token on the corresponding Petri Net place).
\end{itemize}

These three ingredients can be computed from the intermediate results of earlier steps in the synthesis chain, as indicated in the preamble of this section.

Constructing the state information mapping requires some backtracking.
For every execution point (roughly corresponding to control flows) in the synthesized UML activity, we need to know the set of all states in which the system may be at that point.
These sets of states can be found by tracing back the CIF state annotations from the earlier generated CIF state space (see \autoref{sec:state-space-generation}), through the various CIF event-based toolkit steps.
So for every control flow we must: (1) determine the Petri Net place corresponding to it, (2) use the region mapping produced in \autoref{sec:petrinet-synthesis} to determine which CIF locations correspond to that Petri Net place, and (3) collect the state annotations from these locations in the generated CIF state space.
Step (3) is slightly tricky in case there were atomic nondeterministic actions, as we should not consider the state annotations of any `intermediate' CIF locations in which an atomic nondeterministic action is being executed (e.g., since the atomicity variable is true in any such intermediate state, and choice guards should not depend on internal details).
Therefore, any such state annotations must be filtered out first.
The set of all system states can then be represented as a single predicate.

Note that all the predicates are internally represented in the code implementation as Binary Decision Diagrams (BDD).
This is because BDDs allow easy manipulation of Boolean functions, like BDD simplification, i.e., \texttt{simplify}.
CIF contains functionality for translating BDD representations of predicates, to CIF expressions, which can in turn be translated to strings.

Now let us explain how control flow guards are computed.
To start, let us first determine an \emph{uncontrolled guard} and a \emph{controlled guard} for every UML action node, which form the basis for computing control flow guards.
Let $N$ be any action node in the UML activity for which we want to compute control flow guards.
We define $\mathit{uncontrolled}(N)$ to be the uncontrolled guard predicate for $N$ such that:
\begin{itemize}
	\item In case $N$ is a call behavior action node, $\mathit{uncontrolled}(N)$ is the uncontrolled system guard for that action.
	\item In case $N$ is an internal \startLabel{} action node, $\mathit{uncontrolled}(N)$ is the activity precondition.
	That is, $N$ is only executed in states where the activity precondition holds.
	\item In case $N$ is an internal \stopLabel{} action node, $\mathit{uncontrolled}(N)$ is the activity postcondition.
	That is, $N$ is only executed in states where the activity postcondition holds.
	\item In case $N$ is an internal \tauLabel{} action node, $\mathit{uncontrolled}(N)$ is the conjunction of the state info predicates of all outgoing control flows of the \tauLabel{} node.
	That is, $N$ is only executed from system states where the corresponding effect of the nonatomic action has applied.
	With \emph{state info predicates} we mean the predicates from the state information mapping, in this case for all outgoing control flows of the \tauLabel{} node.
	We compute the \emph{conjunction} of all these state info predicates, since that predicate describes all states the system can be in right after the corresponding effect has been executed.
	Especially in case the activity forks after the \tauLabel{} action node, computing the conjunction ensures that we get the state info predicate that applies right after the \tauLabel{} node and right before the fork node.
	This computation of $\mathit{uncontrolled}(N)$ is needed since we've rewritten the nonatomic pattern in the previous step, meaning that we have to calculate the new uncontrolled guards of the \tauLabel{}-s for the new situation.
	\item In all other cases, $\mathit{uncontrolled}(N)$ is the predicate \texttt{true}.
	That is, the execution of $N$ is not restricted by any guard predicate, which may happen, e.g., if $N$ is an nonatomic end event that's not reduced earlier.
\end{itemize}
Let us define $\mathit{controlled}(N)$ to be the controlled guard predicate for $N$ such that:
\begin{itemize}
	\item In case $N$ is a call behavior action node, $\mathit{controlled}(N)$ is the controlled system guard for that action.
	That is, $\mathit{controlled}(N)$ is the controlled-system condition resulting from synthesis, for the action called by $N$.
	\item In all other cases, $\mathit{controlled}(N)$ is undefined.
	That is, no conditions were synthesized that further restrict $N$ in the controlled system.
\end{itemize}
Next we define $\mathit{extra}(N)$ as a predicate describing the extra synthesized condition for executing $N$, such that:
\begin{itemize}
	\item If $\mathit{controlled}(N)$ is not defined, then $\mathit{extra}(N) = \mathit{uncontrolled}(N)$.
	\item If $\mathit{controlled}(N)$ is defined, then $$\mathit{extra}(N) =\texttt{simplify}(\mathit{controlled}(N), \mathit{uncontrolled}(N)),$$ where $\texttt{simplify}(p,q)$ is an operation that simplifies some given predicate $p$ with respect to some predicate $q$, and returns the simplified predicate.
	This simplification is based on heuristics.
	Various algorithms exist for simplifying (symbolic representations of) predicates.
	We can simplify here since any restrictions covered by the controlled guard for $N$ are already considered by the execution semantics of activities.
\end{itemize}

Now, given any control flow $\mathit{cf}$ in the UML activity that goes from some decision node to some action node $N$, we may use $\mathit{extra}(N)$ as the control flow guard for $\mathit{cf}$.
This would be a valid guard, but it can also be quite lengthy since we configured data-based synthesis to not perform any simplifications.
It is known that data-based synthesis may synthesize long control conditions that are difficult to read and understand by engineers.
To make the guard (hopefully) human readable, we can further simplify it by state information.
Another reason for further simplification is that $\mathit{extra}(N)$ may be expressed over internal state, like internal CIF variables for encoding occurrence constraints that keep track of the number of occurrences of actions, which should not end up in control flow guards.
It therefore makes sense to simplify $\mathit{extra}(N)$ by using any contextual information we have at hand, if $\mathit{extra}(N)$ happens to be non-trivial.

Also note that, in UML activities, the control flows that go out of decision nodes do not have to always target an action node.
The target node could in principle also, e.g., be a fork or join node introduced by \transformToActivityLabel{}.
This is why the code implementation actually computes choice guards on the Petri Net level, and then adds them to the UML activity.
Any UML decision node corresponds to a Petri Net place, and by the structure of Petri Nets, all outgoing arcs of that place will have a Petri Net transition as target, corresponding to some action.
This makes guard computation easier to do on the Petri Net representations as then you don't have to deal with any additional structure introduced by \transformToActivityLabel{}.
Yet the high-level ideas can well be explained on the level of UML activities.

To allow further simplification, we first define the state information predicate $\mathit{stateinfo}(D)$ for any decision node $N$, so that:
\begin{itemize}
	\item If $D$ is an intermediate decision node of a rewritten nonatomic action pattern, then $\mathit{stateinfo}(D)$ is defined to be disjunction of the predicates $\mathit{uncontrolled}(\tauLabel{}_i)$ of all the internal $\tauLabel{}_0, \tauLabel{}_1, \dots$ nodes connected to $D$ by an outgoing control flow.
	In other words, the system states you can be in while executing $D$, are all the system states you can be in directly after the nonatomic action has taken effect.
	Note that this computation of $\mathit{stateinfo}(D)$ is needed since we've rewritten the nonatomic pattern, meaning that we have to recompute the relevant state information for $D$.
	\item Otherwise, if $D$ is not part of any nonatomic pattern, then $\mathit{stateinfo}(D)$ is defined to be the state information predicate of its incoming control flow.
	(Recall that \transformToActivityLabel{} guarantees that $D$ has a single incoming control flow.)
\end{itemize}

Now we can further simplify the extra guard predicates defined earlier, which finishes guard computation.
Given any control flow $\mathit{cf}$ in the UML activity that goes from some decision node \var{D} to some node \var{N}, we define the guard for $\mathit{cf}$ to be $\texttt{simplify}(\mathit{extra}(N), \mathit{stateinfo}(D))$.
With these simplifications we can hopefully also eliminate any parts of the control flow guard that depends on internal state.
We are not sure though whether such parts can always be eliminated.

\paragraph{Preconditions.}
The input UML activity \var{umlActivity_{red}} should be a synthesized concrete UML activity, with its nonatomic patterns reduced wherever possible (as result of \autoref{sec:reducing-non-atomic-patterns}).
Moreover, all intermediate information from earlier steps of the activity synthesis algorithm must be available, like the original UML input model, the synthesized Petri Net, the region mapping, the state annotations of the generated/projected/minimized CIF state space, the CIF supervisor, etc.

As indicated earlier in \autoref{sec:data-based-synthesis}, the CIF data-based synthesis tool should have been configured to disable all BDD simplification.
This is needed for computing choice guards, since if synthesized conditions were simplified, they may no longer capture restrictions that are imposed by CIF requirements as those would have been simplified away.
Instead, we want the synthesized conditions to completely capture all imposed restrictions, including requirements.

Moreover, all nonatomic patterns must have been reduced, since their reduction has an impact on the computation of choice guards, as motivated earlier.

\paragraph{Postconditions.}
The output is a UML activity that is equal to \var{umlActivity_{red}}, but with proper choice guards added to all control flows that go out of decision nodes.
These added choice guards are Boolean predicates that express extra guard conditions for taking the control flow, that are not yet captured by the original action guards nor other known system state information.

Moreover, the added choice guards do (hopefully) not use internal variables, like the atomicity variable.
We are not sure that the computed choice guards will indeed never use internal variables.
On the other hand, we have not found a counterexample yet where the computed guards use internally generated variables.
To be sure, we have added an assertion in the code to check for use of internal variables, and if such use is detected, the \computeEdgeGuardsLabel{} operation will terminate exceptionally.
So if the operation terminates, then the choice guards do not use internal variables.

\subsection{Post-processing of the activity}
\label{sec:activity-post-processing}

The operation \postprocessActivity{\var{umlActivity_{guards}}} post-processes the synthesized activity \var{umlActivity_{guards}}, to:
\begin{itemize}
	\item Rewrite any leftover nonatomic actions that were not merged earlier by \reduceNonAtomicPatternsLabel{}.
	\item Remove any internal actions have been introduced in earlier steps, like the opaque \startLabel{}, \stopLabel{}, and \tauLabel{} actions.
	\item Further simplify the synthesized activity.
	\item Remove some names from UML control nodes and control flows, for better readability in UML Designer.
\end{itemize}

\paragraph{Motivation.}

The \postprocessActivityLabel{} operation first rewrites any leftover nonatomic actions that were not merged earlier.
Recall from \autoref{sec:reducing-non-atomic-patterns} that not all occurrences of nonatomic actions can be reduced as part of a nonatomc pattern.
This means that the activity might still contain separate actions for the starts and ends of nonreduced nonatomic actions.
We rewrite these to ensure that the synthesized activity is valid.
We do this by turning all such starts to opaque actions that have the original action guard and no effects, and turning all ends to opaque actions that have guard \texttt{true} and the corresponding effect of the nonatomic action as their (single) effect.
We also rename all these opaque actions, to ensure that they are no longer considered to be internal actions.

Next, we remove any internal actions.
Any auxiliary actions that were not part of the original input UML model should be removed from the synthesized result, as these should not be visible to the user.

After that, we further simplify the synthesized activity.
This is done for two reasons: (1) we know that translating a minimal Petri Net to a UML activity does not imply that the translated activity is minimal, and (2) the removal of internal actions may lead to patterns in the UML activity that may further be reduced.
This simplification step searches for several predefined patterns in the UML activity, and rewrites any found instances of these patterns.

Finally, activity post-processing gives the opportunity to do some other minor improvements, e.g., to improve readability a bit by removing some names.

\paragraph{Preconditions.}
This operation requires a concrete synthesized UML activity \var{umlActivity_{guards}} resulting from the earlier steps.

\paragraph{Postconditions.}
This operation ensures that the synthesized UML activity no longer contains internal actions, is simplified, and has any leftover nonatomic starts and ends rewritten in order to get a valid activity.
Moreover, all names of control nodes (initial/final/fork/join/decision/merge nodes) and control flow have been removed for better readability.

\end{document}
