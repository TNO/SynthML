% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{graphicx} % support the \includegraphics command and options

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{mathpar}
\usepackage{xcolor}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% Custom commands
\newtheorem{definition}{Definition}[section]
\newtheorem{simplificationrule}{Simplification Rule}[section]

\newcommand{\action}[0]{\textsf{action}}
\newcommand{\Action}[0]{\textsf{Action}}
\newcommand{\andlabel}[0]{\textsf{and}}
\newcommand{\andnode}[1]{\andlabel\langle#1\rangle}
\newcommand{\Bool}[0]{\mathbb{B}}
\newcommand{\Config}[0]{\textsf{Config}}
\newcommand{\coreActivity}[0]{\mathcal{A}}
\newcommand{\coreedge}[0]{\varepsilon}
\newcommand{\CoreNode}[0]{\textsf{CoreNode}}
\newcommand{\corenode}[0]{\eta}
\newcommand{\CoreNodeType}[0]{\textsf{CoreNodeType}}
\newcommand{\Effects}[0]{\textsf{Effects}}
\newcommand{\Guard}[0]{\textsf{Guard}}
\newcommand{\incoming}[0]{\textsf{in}}
\newcommand{\incomingguard}[0]{\textsf{guard}_{\incoming}}
\newcommand{\NodeID}[0]{\textsf{NodeID}}
\newcommand{\orlabel}[0]{\textsf{or}}
\newcommand{\ornode}[1]{\orlabel\langle#1\rangle}
\newcommand{\outgoing}[0]{\textsf{out}}
\newcommand{\outgoingguard}[0]{\textsf{guard}_{\outgoing}}
\newcommand{\State}[0]{\textsf{State}}

%%% Comments and notes
\newcommand{\ap}{\textcolor{blue}}

%%% Title and headings
\title{Simplification Rules for Poka Yoke Activities}
%\author{}
%\date{} % Activate to display a given date or no date (if empty), otherwise the current date is printed 

\begin{document}
\maketitle

\section{Introduction}
\label{sec:intro}

This document defines simplification rules for (simple UML-like) activities. 
These activities and their semantics are slightly different from other UML semantics, e.g. fUML, activities. 
For example, every action has an associated guard and effects that specify how action execution influences the system state. 
Edges have two guards, named incoming and outgoing guard, that define when a token can be placed on an edge, and when it can be removed, respectively. 
This document aims at finding patterns of action, nodes, edges that can be transformed into simpler patterns, while maintaining the same operational semantic of the activity. 
We call these transformations \emph{simplifications}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preliminaries and Notation}
\label{sec:prelim}

We largely refer to the Operation Semantics of Poka Yoke Activities document for the static structure and dynamics behaviors of activities. 
We recall here only the elements that are useful for this document. 

\subsection{Statics}
\label{subsec:statics}

\paragraph{State.}
Activities are defined in the presence of \emph{state}, for example a set of variables and their current valuation.
We keep the notion of state more abstract for the purpose of defining the semantics, and let $\State$ be the set of all states.
Users of this semantics could later instantiate $\State$ as desired, e.g., as variable valuation mappings.
Let $\sigma \in \State$ be a typical state.

\paragraph{Guards and effects.}
Guards are defined to be state predicates, while effects are defined to be state transformers, i.e., functions that map states to any number of `successor states', to be able to model nondeterministic action behavior.

Let $\Guard = \State \rightarrow \Bool$ be the set of all \emph{guards} and $\Effects = \State \rightarrow 2^{\State}$ be the set of all \emph{effects functions} over states, with $2^{\State}$ the powerset of $\State$.
We use $g \in \Guard$ and $u \in \Effects$ to denote a typical guard and effects function, respectively.

\paragraph{Core nodes.}
Now that actions have been defined, we can define the \emph{nodes} of core activities, which carry out these actions during executions of the activity.
Core activity nodes consist of two parts: a node identifier, and a node type that also contains (wraps) the action to perform.
The node identifiers are used to give identity to nodes, which are needed to allow having multiple nodes in an activity that perform the same action.
In core activities, actions can be executed in one of two ways: in $\andlabel$-style or in $\orlabel$-style, as indicated by the node type.
An $\andlabel$-style execution of an action node requires that \emph{all} its incoming edges must have a token, and after having performed the action, \emph{all} outgoing edges will get a token (under some additional conditions that are explained later).
In contrast, an $\orlabel$-style execution of an action node requires just \emph{a single} incoming edge to have a token, and after having performed the action, \emph{a single} outgoing edge will receive a token (again, under some extra conditions).
This distinction between $\andlabel$-type and $\orlabel$-type nodes is also made in our semantics document with respect to a token firing semantics, explaining that most UML node types can be divided into these two groups.
For example, UML nodes like `fork' and `join' can be represented as $\andlabel$-nodes, while `decision' and `merge' can be represented in terms of $\orlabel$-nodes.

More formally, let $\NodeID$ be a set of all \emph{node identifiers}, used to give identity to activity nodes, and let $\ell \in \NodeID$ be a typical node identifier.
Then the set $\CoreNode$ of all possible \emph{core activity nodes} is defined as follows:
\begin{mathpar}
	\CoreNode = \NodeID \times \CoreNodeType
	\and
	\CoreNodeType ::= \andnode{\alpha} ~|~ \ornode{\alpha}
\end{mathpar}

Core activity nodes are pairs consisting of a node identifier $\ell$ and an action $\alpha$ to execute, either in $\andlabel$-style or in $\orlabel$-style.
We write $\corenode \in \CoreNode$ to denote a typical node.
Let $\action : \CoreNode \rightarrow \Action$ be a projection function for obtaining the actions of core nodes, so that:
\begin{mathpar}
	\action((\ell,\andnode{\alpha})) = \alpha
	\and
	\action((\ell,\ornode{\alpha})) = \alpha
\end{mathpar}

\subsection{Dynamics}
\label{subsec:dynamics}

This section defines the dynamic behavior of core activities, by means of a token passing style operational semantics.
Its rules describe how to go from one configuration to another, where a configuration is essentially a set of edges holding a token together with a `current' state.
There are two token-passing rules: one for $\andlabel$-style and one for $\orlabel$-style action execution.

\paragraph{Configurations.}
The semantics of core activities is essentially defined as a relation between \emph{configurations}, in the sense that an execution step in an activity gets you from one configuration to another configuration.
A configuration describes which edges currently hold a token, and what the current state is.

More formally, let $\Config = 2^\mathcal{E} \times \State$ be the set of all configurations.
A configuration $(\Sigma, \sigma) \in \Config$ is a pair with $\Sigma \subseteq \mathcal{E}$ a set of edges---the ones currently holding a token---and $\sigma$ a `current' state.
We write $c \in \Config$ to denote a typical configuration, such that $c = (\Sigma, \sigma)$.

Any edge $\coreedge$ is said to be \emph{enabled in $c$} if $\coreedge \in \Sigma$ and $\outgoingguard(\coreedge)(\sigma)$ holds, i.e., if $\coreedge$ has a token in $c$ and if the outgoing guard of $\coreedge$ holds in $c$.
If $c$ is clear from the context, we may just say that $\coreedge$ is \emph{enabled}.
A (firing) schedule for core activity $\coreActivity$ is a \emph{finite} \footnote{\ap{do we need infinite?}} sequence of edges $e_i$ such that $e_1$ is fireable in the initial configuration of $\coreActivity$, and each  $e_i$ is fireable from the configuration reached by starting in the initial configuration and firing $e_j$ for $1\leq j \leq i$ in the schedule.

\subsection{Additional Notation}
\label{subsec:notation}

A core activity  $\mathcal{A} = (\mathcal{N},\mathcal{E})$ is fundamentally a graph with nodes $\mathcal{N} \subseteq \CoreNode$ and edges $\mathcal{E} \subseteq \mathcal{N} \times \Guard \times \Guard \times \mathcal{N}$.  
Let us define $F$ as the \emph{flow relation} of $\coreActivity$, defined as $F \subseteq (\mathcal{N} \times \mathcal{E}) \cup (\mathcal{E} \times \mathcal{N})$. 
We use the following symbols and notation for the set of predecessors and successors of a node $n \in \mathcal{N}$ and edge $e \in \mathcal{E}$:
\begin{itemize}
\item[] $^\bullet e = \{ n \mid (n, e) \in F \} =$ the set of input nodes of $e$
\item[] $e \, ^\bullet = \{ n \mid (e, n) \in F \} =$ the set of output nodes of $e$
\item[] $^\bullet n = \{ e \mid (e, n) \in F \} =$ the set of input edges of $n$
\item[] $n \, ^\bullet = \{ e \mid (n, e) \in F \} =$ the set of output edges of $n$
\end{itemize}
With slight abuse of notation, we extend this notation to sets of nodes and edges. 

A core activity $\coreActivity$ is \emph{safe} if all configurations reachable by legal sequences of edge firings from the initial configuration have either zero or one tokens in every edge. 
Note that edges already have at most one token by the definition of configuration: every core activity is safe by definition.
Further, the core activity is ordinary in the Petri net sense: all edges have a weight equal to 1; for this reason, we largely disregard edge weights. 

For every core activity $\coreActivity$, the language of $\coreActivity$, denoted $L(\coreActivity)$, is the set of all legal sequences $\omega \in \mathcal{N}^*$ of edges firings starting from the initial configuration of tokens $c_0$. 
Let $X$ be a set of nodes of core activity $\coreActivity$. 
We use $\coreActivity | X$ for the core activity obtained by restricting the underlying graph to $X$, and $\coreActivity - X$ to denote $\coreActivity | \bar{X}$, where $\bar{X}$ denotes the complement of $X$. 
This notation is also used for core activity states and firing schedules. 
For example, $\coreActivity - \{ e_1, e_2 \}$ refers to what is left of activity $\coreActivity$ once one removes the edges $e_1$ and $e_2$.
Finally, for a core activity $\coreActivity$ and $X \subset \mathcal{N}$, we define $L(\coreActivity) \mid X$ to be the set of all schedules of $\coreActivity$ with all pairs containing a transition \emph{not} from $X$ deleted. 
Further, $L(\coreActivity) - X = L(\coreActivity) \mid (\mathcal{N} \setminus X) $.
Note that this simply means that $L(\coreActivity) \mid X$ contains the same language of $L(\coreActivity)$ where each occurrence of nodes in $X$ and every edge $e$ whose source is in $X$ have been projected away from each sequence $\omega$. 
The firings, and the overall dynamics of the activity remains the same: just its sequence output is ``cleaned'' from the elements of $X$ and from any edge whose source is within $X$. 

\smallskip

We draw inspiration from \cite{sloan96reduction} for the following definition of equivalence of core activities. 

\paragraph{Equivalence of Core Activities}

The goal of this manuscript is to take a core activity $\coreActivity$ and to reduce it to a smaller activity $\coreActivity'$ that is more amenable to analysis. 
Of course, we want the activity $\coreActivity'$ to be in some sense the ``same'' as the original activity $\coreActivity$. 
We will focus on language preservation (among unmodified edges). 

\begin{definition}
\label{def:equivalence-of-core-activities}
Fix some rule for transforming a core activity $\coreActivity$ to a core activity $\coreActivity'$. 
Let $U$ be the set of edges of $\coreActivity$ which are left completely unmodified by this transformation. 
We say that the (simplified) core activity $\coreActivity'$ is equivalent to activity $\coreActivity$ after the transformation if 
$$
L(\coreActivity) | U = L(\coreActivity') | U.
$$
\end{definition}

\paragraph{Deadlock Preserving Equivalence}
\ap{prove that this notion is dealock preserving. }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Simplifications}
\label{sec:simplifications}

\subsection{Serial Fusion}

\begin{simplificationrule}
If there exist two edges $e_1$ with $\incomingguard(e_1)= g_1$, $\outgoingguard(e_1)= g_2$, and $e_2$ with $\incomingguard(e_2)= g_3$, $\outgoingguard(e_2)= g_4$, and a node $n$ satisfying: 
\begin{enumerate}
\item The initial configuration $c_0$ does not place any token on $e_2$
\item $e_1 \, ^\bullet = \{ n \} = \ ^\bullet e_2$, i.e. node $n$ is the unique output node of $e_1$ and the unique input node of $e_2$
\item Node $n$ is disconnected from all other edges, and has no effects
\item $(^\bullet e_1)^\bullet = \{ e_1 \}$, i.e. edge $e_1$ does not share any of its input place with any other edges
\end{enumerate}
then edges $e_1$ and $e_2$ can be replaced by a single edge $e_F$ with input set $^\bullet e_F = \ ^\bullet e_1$, with output set $ e_F \, ^\bullet = e_2 \, ^ \bullet$ and guards $\incomingguard(e_F)= g_1$, $\outgoingguard(e_F)= g_2 \wedge g_3 \wedge g_4$.
\end{simplificationrule}

\begin{figure}\centering
\subfloat[Original edge scenario.]{\label{a}\includegraphics[width=.33\linewidth]{images/edge_simplification_entire.png}}
\subfloat[Edge simplification.]{\label{b}\includegraphics[width=.39\linewidth]{images/edge_simplification_reduced2.png}}
\caption{The series edge merging scenario. \ap{Pictures to be improved}.}
\label{fig:series-edge-merging}
\end{figure}

\begin{proof}
To satisfy Definition~\ref{def:equivalence-of-core-activities}, we must show that $L(\coreActivity) - \{ e_1, e_2 \} \subseteq L(\coreActivity') - \{ e_F \}$ and that $L(\coreActivity) -\{ e_1, e_2 \} \supseteq L(\coreActivity') - \{ e_F \}$. 
For simplicity, let us assume that node $n$ does not have a guard. 
In presence of a guard, it is sufficient to conjunct it with either the outgoing guard $g_2$ or the incoming guard $g_3$.

Let us first show that $L(\coreActivity) - \{ e_1, e_2 \} \subseteq L(\coreActivity') - \{ e_F \}$; we do so by induction on the number of firings of $e_2$. 
Note that we are interested in \emph{non-blocking} sequences, so we should always be able to take edge $e_2$ and execute its outgoing node (which might be a final node or not). 
First, note that $\coreActivity - \{ e_1, e_2 \} = \coreActivity' - \{ e_F \}$.
For the base case, let $\varsigma$ be a schedule that contains no firing of $e_2$.
If also $e_1 \notin \varsigma$, then $\varsigma \in L(\coreActivity - \{ e_1, e_2, n \})$, and we can use $\varsigma' = \varsigma$ in $\coreActivity'$ to satisfy our claim. 
If instead $e_1 \in \varsigma$, note that there must be exactly one firing of $e_1$ in $\varsigma$ since $\coreActivity$ is safe. 
Let $\varsigma = \varsigma_1 (e_1) \varsigma_2$ where neither $e_1$ or $e_2$ appear in $\varsigma_1$, $\varsigma_2$.  
By definition, $g_1$ must be true at some point of $\varsigma_1$ in order to place a token in $e_1$. 
Similarly, both guards $g_2$ and $g_3$ must be true at the end of $\varsigma_1$ for the firing of $e_1$. 
Note that $e_1$ cannot be enabled at the end of $\varsigma_2$ -- since $e_2$ has not fired yet -- because the activity is safe and node $n$ has no other outgoing edges. 
Then, we can use $\varsigma' = \varsigma_1 (\cdot) \varsigma_2$ as a schedule for $\coreActivity'$ -- note that we can put a token on $e_F$ if and only if $g_1$ holds at some point, but we cannot remove it until also $g_4$ holds -- and our claim is satisfied. 

Let us now assume that the claim is true until $k$ firings of $e_2$, and consider a schedule $\varsigma$ of $\coreActivity$ where there are $k+1$ firings of $e_2$. 
Since  $e_1 \, ^\bullet = \{ n \} = \ ^\bullet e_2$, activity $\coreActivity$ is safe, and $e_2$ is not in the initial configuration, $e_1$ must fire exactly once before each firing of $e_2$. 
Hence, $\varsigma$ contains either $k+1$ or $k+2$ firings of $e_1$. 
Let consider a schedule with $k+1$ firings of $e_1$: we can write 
$$ \varsigma = \varsigma_1 (e_1) v_1 (e_2) \varsigma_2 (e_1) v_2 \ldots \varsigma_{k+1}(e_1) v_{k+1} (e_2) \varsigma_{k+2}, $$
where neither $e_1$ or $e_2$ appears in $\varsigma_i$ nor $v_i$. 
By inductive hypothesis, we can set $\varsigma' =  \varsigma_1 (e_1) v_1 (e_2) \varsigma_2 (e_1) v_2 \ldots \varsigma_{k+1}$ such that the two languages are equivalent (until step $k$). 
If edge $e_1$ does not share any input nodes, then then final firing in $\varsigma$  must happen when $g_2 \wedge g_3$ holds. 
Let us now analyze $v_{k+1}$: if during this sequence of firings the values of $g_2$, $g_3$, $g_4$, do not change -- and in particular must all be true, since we have a firing of $e_2$ afterwards -- we can simply adapt the final part of the schedule as $\varsigma_{k+1} (e_F) v_{k+1} \varsigma_{k+2}$ or $\varsigma_{k+1} v_{k+1} (e_F) \varsigma_{k+2}$ without loss of generality, and again our claim is satisfied. 
In general however, sequence $v_{k+1}$ can change the truth values of $g_2$ or $g_3$ (Note that at the end of $v_{k+1}$ guard $g_4$ must hold, since we have a firing of $e_2$). 
If that happens, we have a sequence in $\coreActivity$ that cannot be reproduced in $\coreActivity'$: to prevent this, we impose that if $g_4$ is true, then also $g_2 \wedge g_3$ must hold.
In this way, we ensure that at the end of $v_{k+1}$ all guards $g_2$, $g_3$, $g_4$ must hold, and we can use the adapted version of $\varsigma$ (see previous discussion) in $\coreActivity'$, and this concludes the proof. 

\smallskip

Let us now show that  $L(\coreActivity) - \{ e_1, e_2 \} \supseteq L(\coreActivity') - \{ e_F \}$. 
Similarly to the previous case, we consider schedules $\varsigma'$ in $\coreActivity'$ and prove that there exists a schedule $\varsigma$ in $\coreActivity$ that ensure language equivalence. 
We proceed by induction in the number of steps of $e_F$. 
If there are no firings of $e_F$, the proof follows analogously to the previous case scenario. 
Let us now take the inductive hypothesis, and consider a schedule
$$ \varsigma' = \varsigma'_1 (e_F) \varsigma'_2 (e_F) \ldots \varsigma'_{k+1}(e_F) \varsigma'_{k+2},  $$
that contains $k+1$ firings of $e_F$, and the $ \varsigma_i$ do not contain any firing of $e_F$.
Note that $\varsigma_{k+1}$ enables the firing of $e_F$ by definition: this means that, by inductive hypothesis, there exists a schedule $\varsigma$ in $\coreActivity$ where edge $e_1$ is enabled.
The guards as well simply mirror this, as if $g_2 \wedge g_3 \wedge g_4$ holds, so does $g_2 \wedge g_3$ (the condition to enable $e_1$). 
Thus, edge $e_1$ can freely fire: we extend the schedule $\varsigma$ for $\coreActivity$ by appending the firing of $e_1$ at the end of $\varsigma$. 
To that, we append also $(e_2) \varsigma'_{k+2}$: since $^\bullet e_F = \, ^\bullet e_1$, if the last edge of $\varsigma'_{k+1}$ enables $e_F$, then it also enables $e_1$. 
\end{proof}

\medskip

\begin{simplificationrule}
If there exist two edges $e_1$ with $\incomingguard(e_1)= g_1$, $\outgoingguard(e_1)= g_2$, and $e_2$ with $\incomingguard(e_2)= g_3$, $\outgoingguard(e_2)= g_4$, and a node $n$ satisfying: 
\begin{enumerate}
\item The initial configuration $c_0$ does not place any token on $e_1$
\item $e_1 \, ^\bullet = \{ n \} = \ ^\bullet e_2$, i.e. node $n$ is the unique output node of $e_1$ and the unique input node of $e_2$
\item Node $n$ is disconnected from all other edges, and has no effects
\item $(^\bullet e_1)^\bullet = \{ e_1 \}$, i.e. edge $e_1$ does not share any of its input place with any other edges
\end{enumerate}
then edges $e_1$ and $e_2$ can be replaced by a single edge $e_F$ with input set $^\bullet e_F = \ ^\bullet e_1$, with output set $ e_F \, ^\bullet = e_2 \, ^ \bullet$ and guards $\incomingguard(e_F)= g_1 \wedge g_2 \wedge g_3$, $\outgoingguard(e_F)=  g_4$.
\end{simplificationrule}

\begin{proof}
The proof *should* follow similarly, perhaps with induction on $e_1$ for the first part. \ap{\#TODO}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\begin{thebibliography}{9}
\bibitem{schatz96application}
Shatz, Sol M., et al. "An application of Petri net reduction for Ada tasking deadlock analysis." IEEE Transactions on Parallel and Distributed Systems 7.12 (1996): 1307-1322.
\bibitem{ehrig03grammars}
Ehrig, Hartmut, and Julia Padberg. "Graph grammars and Petri net transformations." Advanced Course on Petri Nets. Berlin, Heidelberg: Springer Berlin Heidelberg, 2003.
\bibitem{evangelista05syntactical}
Evangelista, Sami, Serge Haddad, and J-F. Pradat-Peyre. "Syntactical colored petri nets reductions." International Symposium on Automated Technology for Verification and Analysis. Berlin, Heidelberg: Springer Berlin Heidelberg, 2005.
\bibitem{sloan96reduction}
Sloan, Robert H., and Ugo Buy. "Reduction rules for time Petri nets." Acta Informatica 33 (1996): 687-706.
\end{thebibliography}

\end{document}
