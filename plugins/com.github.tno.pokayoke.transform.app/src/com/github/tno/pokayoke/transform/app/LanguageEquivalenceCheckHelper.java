
package com.github.tno.pokayoke.transform.app;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.escet.cif.common.CifEventUtils;
import org.eclipse.escet.cif.common.CifTextUtils;
import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.annotations.AnnotationArgument;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.cif.declarations.Event;
import org.eclipse.escet.cif.metamodel.java.CifConstructors;

import com.github.tno.pokayoke.transform.activitysynthesis.StateAnnotationHelper;
import com.google.common.base.Verify;

/**
 * Helper for the language equivalence check. Assumes that the CIF models are generated by the CIF state space explorer.
 */
public class LanguageEquivalenceCheckHelper {
    private LanguageEquivalenceCheckHelper() {
    }

    /**
     * Prepares two CIF models for the language equivalence check. Performs sanity checks, removes irrelevant state
     * annotations, and maps the events of one automaton to the events of the other. Returns a record containing the
     * mapped events, and the filtered state annotations.
     *
     * @param model1 The first CIF model.
     * @param namesToEvents1 The map from names of UML elements to CIF events, for the first automaton.
     * @param epsilonEvents1 The set of events that represent epsilon transitions, for the first automaton.
     * @param model2 The second CIF model.
     * @param namesToEvents2 The map from names of UML elements to CIF events, for the second automaton.
     * @param epsilonEvents2 The set of events that represent epsilon transitions, for the second automaton.
     * @param synthVariableNames The set containing synthesis variables names.
     * @return The model preparation result.
     */
    public static ModelPreparationResult prepareModels(Specification model1, Map<String, List<Event>> namesToEvents1,
            Set<Event> epsilonEvents1, Specification model2, Map<String, List<Event>> namesToEvents2,
            Set<Event> epsilonEvents2, Set<String> synthVariableNames)
    {
        // Sanity checks. The models should only have one component, an automaton.
        Verify.verify(model1.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model2.getComponents().size() == 1, "Found more than one component.");
        Verify.verify(model1.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");
        Verify.verify(model2.getComponents().get(0) instanceof Automaton, "Component is not an automaton.");

        Automaton automaton1 = (Automaton)model1.getComponents().get(0);
        Automaton automaton2 = (Automaton)model2.getComponents().get(0);

        // Filter irrelevant information from state annotations.
        Map<Location, Annotation> filteredStateAnn1 = cleanStateAnnotations(model1, synthVariableNames);
        Map<Location, Annotation> filteredStateAnn2 = cleanStateAnnotations(model2, synthVariableNames);

        // Sanity check: check that the epsilon and non-epsilon events represent the entire automaton alphabet.
        Verify.verify(checkAlphabetCoverage(automaton1, namesToEvents1, epsilonEvents1));
        Verify.verify(checkAlphabetCoverage(automaton2, namesToEvents2, epsilonEvents2));

        // Filter unused events from automaton alphabet.
        Set<String> unusedEvents1 = cleanAutomatonAlphabet(automaton1);
        Set<String> unusedEvents2 = cleanAutomatonAlphabet(automaton2);

        // Check that the two alphabets are compatible, and create a set of pairs with the corresponding list of events.
        Set<Pair<List<Event>, List<Event>>> pairedEvents = getPairedEvents(namesToEvents1, unusedEvents1,
                namesToEvents2, unusedEvents2);

        return new ModelPreparationResult(pairedEvents, filteredStateAnn1, filteredStateAnn2);
    }

    private static Map<Location, Annotation> cleanStateAnnotations(Specification model,
            Set<String> synthVariableNames)
    {
        // Get state annotations for the CIF model.
        Map<Location, List<Annotation>> locToAnnotations = StateAnnotationHelper.getStateAnnotations(model);

        // Verify that each location has only one annotation. This is always the case with CIF model generated with the
        // state space exploration.
        locToAnnotations.values().stream().forEach(
                a -> Verify.verify(a.size() == 1, "Found state that doesn't have exactly one state annotation."));

        // Clean the state annotations from irrelevant state info.
        Map<Location, Annotation> locToFilteredAnnotations = filterRelevantAnnotations(locToAnnotations,
                synthVariableNames);

        return locToFilteredAnnotations;
    }

    private static Map<Location, Annotation> filterRelevantAnnotations(Map<Location, List<Annotation>> locToAnnotations,
            Set<String> synthVariableNames)
    {
        Map<Location, Annotation> locToFilteredAnnotations = new LinkedHashMap<>();

        for (Entry<Location, List<Annotation>> locToAnnotation: locToAnnotations.entrySet()) {
            Location loc = locToAnnotation.getKey();
            List<Annotation> annotations = locToAnnotation.getValue();

            // Filter and create new annotation.
            List<AnnotationArgument> filteredList = annotations.get(0).getArguments().stream()
                    .filter(arg -> synthVariableNames.contains(arg.getName())).toList();
            Annotation filteredAnnotation = CifConstructors.newAnnotation(filteredList, annotations.get(0).getName(),
                    annotations.get(0).getPosition());
            locToFilteredAnnotations.put(loc, filteredAnnotation);
        }

        return locToFilteredAnnotations;
    }

    private static Set<String> cleanAutomatonAlphabet(Automaton automa) {
        // Removes the unused events from the alphabet, and returns the unused events names.
        Set<Event> preFilterAlphabet = CifEventUtils.getAlphabet(automa);
        automa.setAlphabet(null);
        Set<Event> postFilterAlphabet = CifEventUtils.getAlphabet(automa);
        preFilterAlphabet.removeAll(postFilterAlphabet);
        return preFilterAlphabet.stream().map(e -> CifTextUtils.getAbsName(e)).collect(Collectors.toSet());
    }

    private static boolean checkAlphabetCoverage(Automaton automa, Map<String, List<Event>> namesToEvents,
            Set<Event> epsilonEvents)
    {
        // Check that the alphabet of the automaton is equal to the union of non-epsilon and the epsilon events. This
        // check is performed by absolute names, since they are different objects.
        Set<Event> eventsMerged = new LinkedHashSet<>();
        namesToEvents.values().forEach(e -> eventsMerged.addAll(e));
        eventsMerged.addAll(epsilonEvents);

        Set<Event> automaAlphabet = CifEventUtils.getAlphabet(automa);
        Set<String> absNamesAutoma = automaAlphabet.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());
        Set<String> absNamesEventsMerged = eventsMerged.stream().map(e -> CifTextUtils.getAbsName(e))
                .collect(Collectors.toSet());

        return absNamesAutoma.equals(absNamesEventsMerged);
    }

    private static Set<Pair<List<Event>, List<Event>>> getPairedEvents(Map<String, List<Event>> namesToEvents1,
            Set<String> unusedEvents1, Map<String, List<Event>> namesToEvents2, Set<String> unusedEvents2)
    {
        Set<Pair<List<Event>, List<Event>>> pairedEvents = new LinkedHashSet<>();
        for (Entry<String, List<Event>> entry: namesToEvents1.entrySet()) {
            String umlElementName = entry.getKey();
            List<Event> events1 = entry.getValue();
            List<Event> events2 = namesToEvents2.getOrDefault(umlElementName, new ArrayList<>());

            // Remove events that are not used.
            List<Event> usedEvents1 = events1.stream().filter(e -> !unusedEvents1.contains(CifTextUtils.getAbsName(e)))
                    .toList();
            List<Event> usedEvents2 = events2.stream().filter(e -> !unusedEvents2.contains(CifTextUtils.getAbsName(e)))
                    .toList();
            // Remove the item from the second map, to later check that all items from the second map have been looped
            // through.
            namesToEvents2.remove(umlElementName);

            if (!usedEvents1.isEmpty() && !usedEvents2.isEmpty()) {
                // Pair the two lists of equivalent events.
                pairedEvents.add(Pair.of(usedEvents1, usedEvents2));
            } else if (usedEvents1.isEmpty() != usedEvents2.isEmpty()) {
                // If one set of events is empty and the other is not, one model can have a transition while the other
                // model cannot; this means that the two models are not compatible. Return 'null' to signal that the two
                // event sets are not compatible.
                return null;
            }
        }

        // If second map is not empty, the two automata are not compatible.
        return namesToEvents2.isEmpty() ? pairedEvents : null;
    }

    /**
     * The result of the manipulation of the two CIF models.
     *
     * @param pairedEvents The set containing the corresponding events from the two automata, stored in pairs.
     * @param stateAnnotations1 The filtered state annotations for the first automaton.
     * @param stateAnnotations2 The filtered state annotations for the second automaton.
     */
    record ModelPreparationResult(Set<Pair<List<Event>, List<Event>>> pairedEvents,
            Map<Location, Annotation> stateAnnotations1, Map<Location, Annotation> stateAnnotations2)
    {
    }
}
