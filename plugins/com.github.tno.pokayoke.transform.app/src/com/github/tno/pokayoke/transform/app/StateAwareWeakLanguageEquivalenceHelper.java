
package com.github.tno.pokayoke.transform.app;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.eclipse.escet.cif.metamodel.cif.Specification;
import org.eclipse.escet.cif.metamodel.cif.annotations.Annotation;
import org.eclipse.escet.cif.metamodel.cif.annotations.AnnotationArgument;
import org.eclipse.escet.cif.metamodel.cif.automata.Automaton;
import org.eclipse.escet.cif.metamodel.cif.automata.Location;
import org.eclipse.escet.cif.metamodel.java.CifConstructors;

import com.github.tno.pokayoke.transform.activitysynthesis.StateAnnotationHelper;
import com.google.common.base.Verify;

/**
 * Helper for the language equivalence check. Assumes that the CIF models are generated by the CIF state space explorer.
 */
public class StateAwareWeakLanguageEquivalenceHelper {
    private StateAwareWeakLanguageEquivalenceHelper() {
    }

    /**
     * Prepares two CIF models for the language equivalence check. Performs sanity checks, removes internal variables
     * from state annotations, and maps the events of one state space to the events of the other. Returns a record
     * containing the mapped events, and the filtered state annotations.
     *
     * @param model1 The first CIF model.
     * @param model2 The second CIF model.
     * @param externalVariableNames The set containing non-escaped external variable names.
     * @return The model preparation result.
     */
    public static ModelPreparationResult prepareModels(Specification model1, Specification model2,
            Set<String> externalVariableNames)
    {
        // Sanity checks. The models should only have one component, an automaton.
        Verify.verify(model1.getComponents().size() == 1, StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                + "the first model contains more than one component.");
        Verify.verify(model2.getComponents().size() == 1, StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                + "the second model contains more than one component.");
        Verify.verify(model1.getComponents().get(0) instanceof Automaton,
                StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + "the first model's component is not an automaton.");
        Verify.verify(model2.getComponents().get(0) instanceof Automaton,
                StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX
                        + "the second model's component is not an automaton.");

        // Filter internal variables from state annotations.
        Map<Location, Annotation> filteredStateAnn1 = filterStateAnnotations(model1, externalVariableNames);
        Map<Location, Annotation> filteredStateAnn2 = filterStateAnnotations(model2, externalVariableNames);

        return new ModelPreparationResult(filteredStateAnn1, filteredStateAnn2);
    }

    private static Map<Location, Annotation> filterStateAnnotations(Specification model,
            Set<String> externalVariableNames)
    {
        // Get state annotations for the CIF model.
        Map<Location, List<Annotation>> locToAnnotations = StateAnnotationHelper.getStateAnnotations(model);

        // Verify that each location has only one annotation. This is always the case with CIF model generated with the
        // state space exploration.
        List<String> locsWithErrors = locToAnnotations.entrySet().stream().filter(e -> e.getValue().size() != 1)
                .map(a -> a.getKey().getName()).toList();
        if (!locsWithErrors.isEmpty()) {
            throw new RuntimeException(StateAwareWeakLanguageEquivalenceChecker.ERROR_PREFIX + String.format(
                    "state space '%s' contains state(s) %s that don't have exactly one state annotation.",
                    model.getComponents().get(0).getName(), String.join(", ", locsWithErrors)));
        }

        // Filter the state annotations, by removing the internal variables from them.
        Map<Location, Annotation> locToFilteredAnnotations = new LinkedHashMap<>();

        for (Entry<Location, List<Annotation>> locToAnnotation: locToAnnotations.entrySet()) {
            Location loc = locToAnnotation.getKey();
            List<Annotation> annotations = locToAnnotation.getValue();
            Annotation annotation = annotations.get(0);

            // Filter and create new annotation. External variable names are not escaped.
            List<AnnotationArgument> filteredArgs = annotation.getArguments().stream()
                    .filter(arg -> externalVariableNames.contains(arg.getName())).toList();
            Annotation filteredAnnotation = CifConstructors.newAnnotation(filteredArgs, annotation.getName(),
                    annotation.getPosition());
            locToFilteredAnnotations.put(loc, filteredAnnotation);
        }

        return locToFilteredAnnotations;
    }

    /**
     * The result of the preparation of the two CIF state spaces.
     *
     * @param stateAnnotations1 The filtered state annotations for the first state space.
     * @param stateAnnotations2 The filtered state annotations for the second state space.
     */
    record ModelPreparationResult(Map<Location, Annotation> stateAnnotations1,
            Map<Location, Annotation> stateAnnotations2)
    {
    }
}
